(()=>{var __webpack_modules__={106:function(module){eval('/*!\n  * Bootstrap v5.1.3 (https://getbootstrap.com/)\n  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n  */\n!function (t, e) {\n   true ? module.exports = e() : 0;\n}(this, function () {\n  "use strict";\n\n  const t = "transitionend",\n        e = t => {\n    let e = t.getAttribute("data-bs-target");\n\n    if (!e || "#" === e) {\n      let i = t.getAttribute("href");\n      if (!i || !i.includes("#") && !i.startsWith(".")) return null;\n      i.includes("#") && !i.startsWith("#") && (i = `#${i.split("#")[1]}`), e = i && "#" !== i ? i.trim() : null;\n    }\n\n    return e;\n  },\n        i = t => {\n    const i = e(t);\n    return i && document.querySelector(i) ? i : null;\n  },\n        n = t => {\n    const i = e(t);\n    return i ? document.querySelector(i) : null;\n  },\n        s = e => {\n    e.dispatchEvent(new Event(t));\n  },\n        o = t => !(!t || "object" != typeof t) && (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType),\n        r = t => o(t) ? t.jquery ? t[0] : t : "string" == typeof t && t.length > 0 ? document.querySelector(t) : null,\n        a = (t, e, i) => {\n    Object.keys(i).forEach(n => {\n      const s = i[n],\n            r = e[n],\n            a = r && o(r) ? "element" : null == (l = r) ? `${l}` : {}.toString.call(l).match(/\\s([a-z]+)/i)[1].toLowerCase();\n      var l;\n      if (!new RegExp(s).test(a)) throw new TypeError(`${t.toUpperCase()}: Option "${n}" provided type "${a}" but expected type "${s}".`);\n    });\n  },\n        l = t => !(!o(t) || 0 === t.getClientRects().length) && "visible" === getComputedStyle(t).getPropertyValue("visibility"),\n        c = t => !t || t.nodeType !== Node.ELEMENT_NODE || !!t.classList.contains("disabled") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled")),\n        h = t => {\n    if (!document.documentElement.attachShadow) return null;\n\n    if ("function" == typeof t.getRootNode) {\n      const e = t.getRootNode();\n      return e instanceof ShadowRoot ? e : null;\n    }\n\n    return t instanceof ShadowRoot ? t : t.parentNode ? h(t.parentNode) : null;\n  },\n        d = () => {},\n        u = t => {\n    t.offsetHeight;\n  },\n        f = () => {\n    const {\n      jQuery: t\n    } = window;\n    return t && !document.body.hasAttribute("data-bs-no-jquery") ? t : null;\n  },\n        p = [],\n        m = () => "rtl" === document.documentElement.dir,\n        g = t => {\n    var e;\n    e = () => {\n      const e = f();\n\n      if (e) {\n        const i = t.NAME,\n              n = e.fn[i];\n        e.fn[i] = t.jQueryInterface, e.fn[i].Constructor = t, e.fn[i].noConflict = () => (e.fn[i] = n, t.jQueryInterface);\n      }\n    }, "loading" === document.readyState ? (p.length || document.addEventListener("DOMContentLoaded", () => {\n      p.forEach(t => t());\n    }), p.push(e)) : e();\n  },\n        _ = t => {\n    "function" == typeof t && t();\n  },\n        b = (e, i, n = !0) => {\n    if (!n) return void _(e);\n\n    const o = (t => {\n      if (!t) return 0;\n      let {\n        transitionDuration: e,\n        transitionDelay: i\n      } = window.getComputedStyle(t);\n      const n = Number.parseFloat(e),\n            s = Number.parseFloat(i);\n      return n || s ? (e = e.split(",")[0], i = i.split(",")[0], 1e3 * (Number.parseFloat(e) + Number.parseFloat(i))) : 0;\n    })(i) + 5;\n\n    let r = !1;\n\n    const a = ({\n      target: n\n    }) => {\n      n === i && (r = !0, i.removeEventListener(t, a), _(e));\n    };\n\n    i.addEventListener(t, a), setTimeout(() => {\n      r || s(i);\n    }, o);\n  },\n        v = (t, e, i, n) => {\n    let s = t.indexOf(e);\n    if (-1 === s) return t[!i && n ? t.length - 1 : 0];\n    const o = t.length;\n    return s += i ? 1 : -1, n && (s = (s + o) % o), t[Math.max(0, Math.min(s, o - 1))];\n  },\n        y = /[^.]*(?=\\..*)\\.|.*/,\n        w = /\\..*/,\n        E = /::\\d+$/,\n        A = {};\n\n  let T = 1;\n  const O = {\n    mouseenter: "mouseover",\n    mouseleave: "mouseout"\n  },\n        C = /^(mouseenter|mouseleave)/i,\n        k = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);\n\n  function L(t, e) {\n    return e && `${e}::${T++}` || t.uidEvent || T++;\n  }\n\n  function x(t) {\n    const e = L(t);\n    return t.uidEvent = e, A[e] = A[e] || {}, A[e];\n  }\n\n  function D(t, e, i = null) {\n    const n = Object.keys(t);\n\n    for (let s = 0, o = n.length; s < o; s++) {\n      const o = t[n[s]];\n      if (o.originalHandler === e && o.delegationSelector === i) return o;\n    }\n\n    return null;\n  }\n\n  function S(t, e, i) {\n    const n = "string" == typeof e,\n          s = n ? i : e;\n    let o = P(t);\n    return k.has(o) || (o = t), [n, s, o];\n  }\n\n  function N(t, e, i, n, s) {\n    if ("string" != typeof e || !t) return;\n\n    if (i || (i = n, n = null), C.test(e)) {\n      const t = t => function (e) {\n        if (!e.relatedTarget || e.relatedTarget !== e.delegateTarget && !e.delegateTarget.contains(e.relatedTarget)) return t.call(this, e);\n      };\n\n      n ? n = t(n) : i = t(i);\n    }\n\n    const [o, r, a] = S(e, i, n),\n          l = x(t),\n          c = l[a] || (l[a] = {}),\n          h = D(c, r, o ? i : null);\n    if (h) return void (h.oneOff = h.oneOff && s);\n    const d = L(r, e.replace(y, "")),\n          u = o ? function (t, e, i) {\n      return function n(s) {\n        const o = t.querySelectorAll(e);\n\n        for (let {\n          target: r\n        } = s; r && r !== this; r = r.parentNode) for (let a = o.length; a--;) if (o[a] === r) return s.delegateTarget = r, n.oneOff && j.off(t, s.type, e, i), i.apply(r, [s]);\n\n        return null;\n      };\n    }(t, i, n) : function (t, e) {\n      return function i(n) {\n        return n.delegateTarget = t, i.oneOff && j.off(t, n.type, e), e.apply(t, [n]);\n      };\n    }(t, i);\n    u.delegationSelector = o ? i : null, u.originalHandler = r, u.oneOff = s, u.uidEvent = d, c[d] = u, t.addEventListener(a, u, o);\n  }\n\n  function I(t, e, i, n, s) {\n    const o = D(e[i], n, s);\n    o && (t.removeEventListener(i, o, Boolean(s)), delete e[i][o.uidEvent]);\n  }\n\n  function P(t) {\n    return t = t.replace(w, ""), O[t] || t;\n  }\n\n  const j = {\n    on(t, e, i, n) {\n      N(t, e, i, n, !1);\n    },\n\n    one(t, e, i, n) {\n      N(t, e, i, n, !0);\n    },\n\n    off(t, e, i, n) {\n      if ("string" != typeof e || !t) return;\n      const [s, o, r] = S(e, i, n),\n            a = r !== e,\n            l = x(t),\n            c = e.startsWith(".");\n\n      if (void 0 !== o) {\n        if (!l || !l[r]) return;\n        return void I(t, l, r, o, s ? i : null);\n      }\n\n      c && Object.keys(l).forEach(i => {\n        !function (t, e, i, n) {\n          const s = e[i] || {};\n          Object.keys(s).forEach(o => {\n            if (o.includes(n)) {\n              const n = s[o];\n              I(t, e, i, n.originalHandler, n.delegationSelector);\n            }\n          });\n        }(t, l, i, e.slice(1));\n      });\n      const h = l[r] || {};\n      Object.keys(h).forEach(i => {\n        const n = i.replace(E, "");\n\n        if (!a || e.includes(n)) {\n          const e = h[i];\n          I(t, l, r, e.originalHandler, e.delegationSelector);\n        }\n      });\n    },\n\n    trigger(t, e, i) {\n      if ("string" != typeof e || !t) return null;\n      const n = f(),\n            s = P(e),\n            o = e !== s,\n            r = k.has(s);\n      let a,\n          l = !0,\n          c = !0,\n          h = !1,\n          d = null;\n      return o && n && (a = n.Event(e, i), n(t).trigger(a), l = !a.isPropagationStopped(), c = !a.isImmediatePropagationStopped(), h = a.isDefaultPrevented()), r ? (d = document.createEvent("HTMLEvents"), d.initEvent(s, l, !0)) : d = new CustomEvent(e, {\n        bubbles: l,\n        cancelable: !0\n      }), void 0 !== i && Object.keys(i).forEach(t => {\n        Object.defineProperty(d, t, {\n          get: () => i[t]\n        });\n      }), h && d.preventDefault(), c && t.dispatchEvent(d), d.defaultPrevented && void 0 !== a && a.preventDefault(), d;\n    }\n\n  },\n        M = new Map(),\n        H = {\n    set(t, e, i) {\n      M.has(t) || M.set(t, new Map());\n      const n = M.get(t);\n      n.has(e) || 0 === n.size ? n.set(e, i) : console.error(`Bootstrap doesn\'t allow more than one instance per element. Bound instance: ${Array.from(n.keys())[0]}.`);\n    },\n\n    get: (t, e) => M.has(t) && M.get(t).get(e) || null,\n\n    remove(t, e) {\n      if (!M.has(t)) return;\n      const i = M.get(t);\n      i.delete(e), 0 === i.size && M.delete(t);\n    }\n\n  };\n\n  class B {\n    constructor(t) {\n      (t = r(t)) && (this._element = t, H.set(this._element, this.constructor.DATA_KEY, this));\n    }\n\n    dispose() {\n      H.remove(this._element, this.constructor.DATA_KEY), j.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach(t => {\n        this[t] = null;\n      });\n    }\n\n    _queueCallback(t, e, i = !0) {\n      b(t, e, i);\n    }\n\n    static getInstance(t) {\n      return H.get(r(t), this.DATA_KEY);\n    }\n\n    static getOrCreateInstance(t, e = {}) {\n      return this.getInstance(t) || new this(t, "object" == typeof e ? e : null);\n    }\n\n    static get VERSION() {\n      return "5.1.3";\n    }\n\n    static get NAME() {\n      throw new Error(\'You have to implement the static method "NAME", for each component!\');\n    }\n\n    static get DATA_KEY() {\n      return `bs.${this.NAME}`;\n    }\n\n    static get EVENT_KEY() {\n      return `.${this.DATA_KEY}`;\n    }\n\n  }\n\n  const R = (t, e = "hide") => {\n    const i = `click.dismiss${t.EVENT_KEY}`,\n          s = t.NAME;\n    j.on(document, i, `[data-bs-dismiss="${s}"]`, function (i) {\n      if (["A", "AREA"].includes(this.tagName) && i.preventDefault(), c(this)) return;\n      const o = n(this) || this.closest(`.${s}`);\n      t.getOrCreateInstance(o)[e]();\n    });\n  };\n\n  class W extends B {\n    static get NAME() {\n      return "alert";\n    }\n\n    close() {\n      if (j.trigger(this._element, "close.bs.alert").defaultPrevented) return;\n\n      this._element.classList.remove("show");\n\n      const t = this._element.classList.contains("fade");\n\n      this._queueCallback(() => this._destroyElement(), this._element, t);\n    }\n\n    _destroyElement() {\n      this._element.remove(), j.trigger(this._element, "closed.bs.alert"), this.dispose();\n    }\n\n    static jQueryInterface(t) {\n      return this.each(function () {\n        const e = W.getOrCreateInstance(this);\n\n        if ("string" == typeof t) {\n          if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);\n          e[t](this);\n        }\n      });\n    }\n\n  }\n\n  R(W, "close"), g(W);\n  const $ = \'[data-bs-toggle="button"]\';\n\n  class z extends B {\n    static get NAME() {\n      return "button";\n    }\n\n    toggle() {\n      this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"));\n    }\n\n    static jQueryInterface(t) {\n      return this.each(function () {\n        const e = z.getOrCreateInstance(this);\n        "toggle" === t && e[t]();\n      });\n    }\n\n  }\n\n  function q(t) {\n    return "true" === t || "false" !== t && (t === Number(t).toString() ? Number(t) : "" === t || "null" === t ? null : t);\n  }\n\n  function F(t) {\n    return t.replace(/[A-Z]/g, t => `-${t.toLowerCase()}`);\n  }\n\n  j.on(document, "click.bs.button.data-api", $, t => {\n    t.preventDefault();\n    const e = t.target.closest($);\n    z.getOrCreateInstance(e).toggle();\n  }), g(z);\n  const U = {\n    setDataAttribute(t, e, i) {\n      t.setAttribute(`data-bs-${F(e)}`, i);\n    },\n\n    removeDataAttribute(t, e) {\n      t.removeAttribute(`data-bs-${F(e)}`);\n    },\n\n    getDataAttributes(t) {\n      if (!t) return {};\n      const e = {};\n      return Object.keys(t.dataset).filter(t => t.startsWith("bs")).forEach(i => {\n        let n = i.replace(/^bs/, "");\n        n = n.charAt(0).toLowerCase() + n.slice(1, n.length), e[n] = q(t.dataset[i]);\n      }), e;\n    },\n\n    getDataAttribute: (t, e) => q(t.getAttribute(`data-bs-${F(e)}`)),\n\n    offset(t) {\n      const e = t.getBoundingClientRect();\n      return {\n        top: e.top + window.pageYOffset,\n        left: e.left + window.pageXOffset\n      };\n    },\n\n    position: t => ({\n      top: t.offsetTop,\n      left: t.offsetLeft\n    })\n  },\n        V = {\n    find: (t, e = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(e, t)),\n    findOne: (t, e = document.documentElement) => Element.prototype.querySelector.call(e, t),\n    children: (t, e) => [].concat(...t.children).filter(t => t.matches(e)),\n\n    parents(t, e) {\n      const i = [];\n      let n = t.parentNode;\n\n      for (; n && n.nodeType === Node.ELEMENT_NODE && 3 !== n.nodeType;) n.matches(e) && i.push(n), n = n.parentNode;\n\n      return i;\n    },\n\n    prev(t, e) {\n      let i = t.previousElementSibling;\n\n      for (; i;) {\n        if (i.matches(e)) return [i];\n        i = i.previousElementSibling;\n      }\n\n      return [];\n    },\n\n    next(t, e) {\n      let i = t.nextElementSibling;\n\n      for (; i;) {\n        if (i.matches(e)) return [i];\n        i = i.nextElementSibling;\n      }\n\n      return [];\n    },\n\n    focusableChildren(t) {\n      const e = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", \'[contenteditable="true"]\'].map(t => `${t}:not([tabindex^="-"])`).join(", ");\n      return this.find(e, t).filter(t => !c(t) && l(t));\n    }\n\n  },\n        K = "carousel",\n        X = {\n    interval: 5e3,\n    keyboard: !0,\n    slide: !1,\n    pause: "hover",\n    wrap: !0,\n    touch: !0\n  },\n        Y = {\n    interval: "(number|boolean)",\n    keyboard: "boolean",\n    slide: "(boolean|string)",\n    pause: "(string|boolean)",\n    wrap: "boolean",\n    touch: "boolean"\n  },\n        Q = "next",\n        G = "prev",\n        Z = "left",\n        J = "right",\n        tt = {\n    ArrowLeft: J,\n    ArrowRight: Z\n  },\n        et = "slid.bs.carousel",\n        it = "active",\n        nt = ".active.carousel-item";\n\n  class st extends B {\n    constructor(t, e) {\n      super(t), this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e), this._indicatorsElement = V.findOne(".carousel-indicators", this._element), this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = Boolean(window.PointerEvent), this._addEventListeners();\n    }\n\n    static get Default() {\n      return X;\n    }\n\n    static get NAME() {\n      return K;\n    }\n\n    next() {\n      this._slide(Q);\n    }\n\n    nextWhenVisible() {\n      !document.hidden && l(this._element) && this.next();\n    }\n\n    prev() {\n      this._slide(G);\n    }\n\n    pause(t) {\n      t || (this._isPaused = !0), V.findOne(".carousel-item-next, .carousel-item-prev", this._element) && (s(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null;\n    }\n\n    cycle(t) {\n      t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval));\n    }\n\n    to(t) {\n      this._activeElement = V.findOne(nt, this._element);\n\n      const e = this._getItemIndex(this._activeElement);\n\n      if (t > this._items.length - 1 || t < 0) return;\n      if (this._isSliding) return void j.one(this._element, et, () => this.to(t));\n      if (e === t) return this.pause(), void this.cycle();\n      const i = t > e ? Q : G;\n\n      this._slide(i, this._items[t]);\n    }\n\n    _getConfig(t) {\n      return t = { ...X,\n        ...U.getDataAttributes(this._element),\n        ...("object" == typeof t ? t : {})\n      }, a(K, t, Y), t;\n    }\n\n    _handleSwipe() {\n      const t = Math.abs(this.touchDeltaX);\n      if (t <= 40) return;\n      const e = t / this.touchDeltaX;\n      this.touchDeltaX = 0, e && this._slide(e > 0 ? J : Z);\n    }\n\n    _addEventListeners() {\n      this._config.keyboard && j.on(this._element, "keydown.bs.carousel", t => this._keydown(t)), "hover" === this._config.pause && (j.on(this._element, "mouseenter.bs.carousel", t => this.pause(t)), j.on(this._element, "mouseleave.bs.carousel", t => this.cycle(t))), this._config.touch && this._touchSupported && this._addTouchEventListeners();\n    }\n\n    _addTouchEventListeners() {\n      const t = t => this._pointerEvent && ("pen" === t.pointerType || "touch" === t.pointerType),\n            e = e => {\n        t(e) ? this.touchStartX = e.clientX : this._pointerEvent || (this.touchStartX = e.touches[0].clientX);\n      },\n            i = t => {\n        this.touchDeltaX = t.touches && t.touches.length > 1 ? 0 : t.touches[0].clientX - this.touchStartX;\n      },\n            n = e => {\n        t(e) && (this.touchDeltaX = e.clientX - this.touchStartX), this._handleSwipe(), "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(t => this.cycle(t), 500 + this._config.interval));\n      };\n\n      V.find(".carousel-item img", this._element).forEach(t => {\n        j.on(t, "dragstart.bs.carousel", t => t.preventDefault());\n      }), this._pointerEvent ? (j.on(this._element, "pointerdown.bs.carousel", t => e(t)), j.on(this._element, "pointerup.bs.carousel", t => n(t)), this._element.classList.add("pointer-event")) : (j.on(this._element, "touchstart.bs.carousel", t => e(t)), j.on(this._element, "touchmove.bs.carousel", t => i(t)), j.on(this._element, "touchend.bs.carousel", t => n(t)));\n    }\n\n    _keydown(t) {\n      if (/input|textarea/i.test(t.target.tagName)) return;\n      const e = tt[t.key];\n      e && (t.preventDefault(), this._slide(e));\n    }\n\n    _getItemIndex(t) {\n      return this._items = t && t.parentNode ? V.find(".carousel-item", t.parentNode) : [], this._items.indexOf(t);\n    }\n\n    _getItemByOrder(t, e) {\n      const i = t === Q;\n      return v(this._items, e, i, this._config.wrap);\n    }\n\n    _triggerSlideEvent(t, e) {\n      const i = this._getItemIndex(t),\n            n = this._getItemIndex(V.findOne(nt, this._element));\n\n      return j.trigger(this._element, "slide.bs.carousel", {\n        relatedTarget: t,\n        direction: e,\n        from: n,\n        to: i\n      });\n    }\n\n    _setActiveIndicatorElement(t) {\n      if (this._indicatorsElement) {\n        const e = V.findOne(".active", this._indicatorsElement);\n        e.classList.remove(it), e.removeAttribute("aria-current");\n        const i = V.find("[data-bs-target]", this._indicatorsElement);\n\n        for (let e = 0; e < i.length; e++) if (Number.parseInt(i[e].getAttribute("data-bs-slide-to"), 10) === this._getItemIndex(t)) {\n          i[e].classList.add(it), i[e].setAttribute("aria-current", "true");\n          break;\n        }\n      }\n    }\n\n    _updateInterval() {\n      const t = this._activeElement || V.findOne(nt, this._element);\n      if (!t) return;\n      const e = Number.parseInt(t.getAttribute("data-bs-interval"), 10);\n      e ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = e) : this._config.interval = this._config.defaultInterval || this._config.interval;\n    }\n\n    _slide(t, e) {\n      const i = this._directionToOrder(t),\n            n = V.findOne(nt, this._element),\n            s = this._getItemIndex(n),\n            o = e || this._getItemByOrder(i, n),\n            r = this._getItemIndex(o),\n            a = Boolean(this._interval),\n            l = i === Q,\n            c = l ? "carousel-item-start" : "carousel-item-end",\n            h = l ? "carousel-item-next" : "carousel-item-prev",\n            d = this._orderToDirection(i);\n\n      if (o && o.classList.contains(it)) return void (this._isSliding = !1);\n      if (this._isSliding) return;\n      if (this._triggerSlideEvent(o, d).defaultPrevented) return;\n      if (!n || !o) return;\n      this._isSliding = !0, a && this.pause(), this._setActiveIndicatorElement(o), this._activeElement = o;\n\n      const f = () => {\n        j.trigger(this._element, et, {\n          relatedTarget: o,\n          direction: d,\n          from: s,\n          to: r\n        });\n      };\n\n      if (this._element.classList.contains("slide")) {\n        o.classList.add(h), u(o), n.classList.add(c), o.classList.add(c);\n\n        const t = () => {\n          o.classList.remove(c, h), o.classList.add(it), n.classList.remove(it, h, c), this._isSliding = !1, setTimeout(f, 0);\n        };\n\n        this._queueCallback(t, n, !0);\n      } else n.classList.remove(it), o.classList.add(it), this._isSliding = !1, f();\n\n      a && this.cycle();\n    }\n\n    _directionToOrder(t) {\n      return [J, Z].includes(t) ? m() ? t === Z ? G : Q : t === Z ? Q : G : t;\n    }\n\n    _orderToDirection(t) {\n      return [Q, G].includes(t) ? m() ? t === G ? Z : J : t === G ? J : Z : t;\n    }\n\n    static carouselInterface(t, e) {\n      const i = st.getOrCreateInstance(t, e);\n      let {\n        _config: n\n      } = i;\n      "object" == typeof e && (n = { ...n,\n        ...e\n      });\n      const s = "string" == typeof e ? e : n.slide;\n      if ("number" == typeof e) i.to(e);else if ("string" == typeof s) {\n        if (void 0 === i[s]) throw new TypeError(`No method named "${s}"`);\n        i[s]();\n      } else n.interval && n.ride && (i.pause(), i.cycle());\n    }\n\n    static jQueryInterface(t) {\n      return this.each(function () {\n        st.carouselInterface(this, t);\n      });\n    }\n\n    static dataApiClickHandler(t) {\n      const e = n(this);\n      if (!e || !e.classList.contains("carousel")) return;\n      const i = { ...U.getDataAttributes(e),\n        ...U.getDataAttributes(this)\n      },\n            s = this.getAttribute("data-bs-slide-to");\n      s && (i.interval = !1), st.carouselInterface(e, i), s && st.getInstance(e).to(s), t.preventDefault();\n    }\n\n  }\n\n  j.on(document, "click.bs.carousel.data-api", "[data-bs-slide], [data-bs-slide-to]", st.dataApiClickHandler), j.on(window, "load.bs.carousel.data-api", () => {\n    const t = V.find(\'[data-bs-ride="carousel"]\');\n\n    for (let e = 0, i = t.length; e < i; e++) st.carouselInterface(t[e], st.getInstance(t[e]));\n  }), g(st);\n  const ot = "collapse",\n        rt = {\n    toggle: !0,\n    parent: null\n  },\n        at = {\n    toggle: "boolean",\n    parent: "(null|element)"\n  },\n        lt = "show",\n        ct = "collapse",\n        ht = "collapsing",\n        dt = "collapsed",\n        ut = ":scope .collapse .collapse",\n        ft = \'[data-bs-toggle="collapse"]\';\n\n  class pt extends B {\n    constructor(t, e) {\n      super(t), this._isTransitioning = !1, this._config = this._getConfig(e), this._triggerArray = [];\n      const n = V.find(ft);\n\n      for (let t = 0, e = n.length; t < e; t++) {\n        const e = n[t],\n              s = i(e),\n              o = V.find(s).filter(t => t === this._element);\n        null !== s && o.length && (this._selector = s, this._triggerArray.push(e));\n      }\n\n      this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();\n    }\n\n    static get Default() {\n      return rt;\n    }\n\n    static get NAME() {\n      return ot;\n    }\n\n    toggle() {\n      this._isShown() ? this.hide() : this.show();\n    }\n\n    show() {\n      if (this._isTransitioning || this._isShown()) return;\n      let t,\n          e = [];\n\n      if (this._config.parent) {\n        const t = V.find(ut, this._config.parent);\n        e = V.find(".collapse.show, .collapse.collapsing", this._config.parent).filter(e => !t.includes(e));\n      }\n\n      const i = V.findOne(this._selector);\n\n      if (e.length) {\n        const n = e.find(t => i !== t);\n        if (t = n ? pt.getInstance(n) : null, t && t._isTransitioning) return;\n      }\n\n      if (j.trigger(this._element, "show.bs.collapse").defaultPrevented) return;\n      e.forEach(e => {\n        i !== e && pt.getOrCreateInstance(e, {\n          toggle: !1\n        }).hide(), t || H.set(e, "bs.collapse", null);\n      });\n\n      const n = this._getDimension();\n\n      this._element.classList.remove(ct), this._element.classList.add(ht), this._element.style[n] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;\n      const s = `scroll${n[0].toUpperCase() + n.slice(1)}`;\n      this._queueCallback(() => {\n        this._isTransitioning = !1, this._element.classList.remove(ht), this._element.classList.add(ct, lt), this._element.style[n] = "", j.trigger(this._element, "shown.bs.collapse");\n      }, this._element, !0), this._element.style[n] = `${this._element[s]}px`;\n    }\n\n    hide() {\n      if (this._isTransitioning || !this._isShown()) return;\n      if (j.trigger(this._element, "hide.bs.collapse").defaultPrevented) return;\n\n      const t = this._getDimension();\n\n      this._element.style[t] = `${this._element.getBoundingClientRect()[t]}px`, u(this._element), this._element.classList.add(ht), this._element.classList.remove(ct, lt);\n      const e = this._triggerArray.length;\n\n      for (let t = 0; t < e; t++) {\n        const e = this._triggerArray[t],\n              i = n(e);\n        i && !this._isShown(i) && this._addAriaAndCollapsedClass([e], !1);\n      }\n\n      this._isTransitioning = !0, this._element.style[t] = "", this._queueCallback(() => {\n        this._isTransitioning = !1, this._element.classList.remove(ht), this._element.classList.add(ct), j.trigger(this._element, "hidden.bs.collapse");\n      }, this._element, !0);\n    }\n\n    _isShown(t = this._element) {\n      return t.classList.contains(lt);\n    }\n\n    _getConfig(t) {\n      return (t = { ...rt,\n        ...U.getDataAttributes(this._element),\n        ...t\n      }).toggle = Boolean(t.toggle), t.parent = r(t.parent), a(ot, t, at), t;\n    }\n\n    _getDimension() {\n      return this._element.classList.contains("collapse-horizontal") ? "width" : "height";\n    }\n\n    _initializeChildren() {\n      if (!this._config.parent) return;\n      const t = V.find(ut, this._config.parent);\n      V.find(ft, this._config.parent).filter(e => !t.includes(e)).forEach(t => {\n        const e = n(t);\n        e && this._addAriaAndCollapsedClass([t], this._isShown(e));\n      });\n    }\n\n    _addAriaAndCollapsedClass(t, e) {\n      t.length && t.forEach(t => {\n        e ? t.classList.remove(dt) : t.classList.add(dt), t.setAttribute("aria-expanded", e);\n      });\n    }\n\n    static jQueryInterface(t) {\n      return this.each(function () {\n        const e = {};\n        "string" == typeof t && /show|hide/.test(t) && (e.toggle = !1);\n        const i = pt.getOrCreateInstance(this, e);\n\n        if ("string" == typeof t) {\n          if (void 0 === i[t]) throw new TypeError(`No method named "${t}"`);\n          i[t]();\n        }\n      });\n    }\n\n  }\n\n  j.on(document, "click.bs.collapse.data-api", ft, function (t) {\n    ("A" === t.target.tagName || t.delegateTarget && "A" === t.delegateTarget.tagName) && t.preventDefault();\n    const e = i(this);\n    V.find(e).forEach(t => {\n      pt.getOrCreateInstance(t, {\n        toggle: !1\n      }).toggle();\n    });\n  }), g(pt);\n  var mt = "top",\n      gt = "bottom",\n      _t = "right",\n      bt = "left",\n      vt = "auto",\n      yt = [mt, gt, _t, bt],\n      wt = "start",\n      Et = "end",\n      At = "clippingParents",\n      Tt = "viewport",\n      Ot = "popper",\n      Ct = "reference",\n      kt = yt.reduce(function (t, e) {\n    return t.concat([e + "-" + wt, e + "-" + Et]);\n  }, []),\n      Lt = [].concat(yt, [vt]).reduce(function (t, e) {\n    return t.concat([e, e + "-" + wt, e + "-" + Et]);\n  }, []),\n      xt = "beforeRead",\n      Dt = "read",\n      St = "afterRead",\n      Nt = "beforeMain",\n      It = "main",\n      Pt = "afterMain",\n      jt = "beforeWrite",\n      Mt = "write",\n      Ht = "afterWrite",\n      Bt = [xt, Dt, St, Nt, It, Pt, jt, Mt, Ht];\n\n  function Rt(t) {\n    return t ? (t.nodeName || "").toLowerCase() : null;\n  }\n\n  function Wt(t) {\n    if (null == t) return window;\n\n    if ("[object Window]" !== t.toString()) {\n      var e = t.ownerDocument;\n      return e && e.defaultView || window;\n    }\n\n    return t;\n  }\n\n  function $t(t) {\n    return t instanceof Wt(t).Element || t instanceof Element;\n  }\n\n  function zt(t) {\n    return t instanceof Wt(t).HTMLElement || t instanceof HTMLElement;\n  }\n\n  function qt(t) {\n    return "undefined" != typeof ShadowRoot && (t instanceof Wt(t).ShadowRoot || t instanceof ShadowRoot);\n  }\n\n  const Ft = {\n    name: "applyStyles",\n    enabled: !0,\n    phase: "write",\n    fn: function (t) {\n      var e = t.state;\n      Object.keys(e.elements).forEach(function (t) {\n        var i = e.styles[t] || {},\n            n = e.attributes[t] || {},\n            s = e.elements[t];\n        zt(s) && Rt(s) && (Object.assign(s.style, i), Object.keys(n).forEach(function (t) {\n          var e = n[t];\n          !1 === e ? s.removeAttribute(t) : s.setAttribute(t, !0 === e ? "" : e);\n        }));\n      });\n    },\n    effect: function (t) {\n      var e = t.state,\n          i = {\n        popper: {\n          position: e.options.strategy,\n          left: "0",\n          top: "0",\n          margin: "0"\n        },\n        arrow: {\n          position: "absolute"\n        },\n        reference: {}\n      };\n      return Object.assign(e.elements.popper.style, i.popper), e.styles = i, e.elements.arrow && Object.assign(e.elements.arrow.style, i.arrow), function () {\n        Object.keys(e.elements).forEach(function (t) {\n          var n = e.elements[t],\n              s = e.attributes[t] || {},\n              o = Object.keys(e.styles.hasOwnProperty(t) ? e.styles[t] : i[t]).reduce(function (t, e) {\n            return t[e] = "", t;\n          }, {});\n          zt(n) && Rt(n) && (Object.assign(n.style, o), Object.keys(s).forEach(function (t) {\n            n.removeAttribute(t);\n          }));\n        });\n      };\n    },\n    requires: ["computeStyles"]\n  };\n\n  function Ut(t) {\n    return t.split("-")[0];\n  }\n\n  function Vt(t, e) {\n    var i = t.getBoundingClientRect();\n    return {\n      width: i.width / 1,\n      height: i.height / 1,\n      top: i.top / 1,\n      right: i.right / 1,\n      bottom: i.bottom / 1,\n      left: i.left / 1,\n      x: i.left / 1,\n      y: i.top / 1\n    };\n  }\n\n  function Kt(t) {\n    var e = Vt(t),\n        i = t.offsetWidth,\n        n = t.offsetHeight;\n    return Math.abs(e.width - i) <= 1 && (i = e.width), Math.abs(e.height - n) <= 1 && (n = e.height), {\n      x: t.offsetLeft,\n      y: t.offsetTop,\n      width: i,\n      height: n\n    };\n  }\n\n  function Xt(t, e) {\n    var i = e.getRootNode && e.getRootNode();\n    if (t.contains(e)) return !0;\n\n    if (i && qt(i)) {\n      var n = e;\n\n      do {\n        if (n && t.isSameNode(n)) return !0;\n        n = n.parentNode || n.host;\n      } while (n);\n    }\n\n    return !1;\n  }\n\n  function Yt(t) {\n    return Wt(t).getComputedStyle(t);\n  }\n\n  function Qt(t) {\n    return ["table", "td", "th"].indexOf(Rt(t)) >= 0;\n  }\n\n  function Gt(t) {\n    return (($t(t) ? t.ownerDocument : t.document) || window.document).documentElement;\n  }\n\n  function Zt(t) {\n    return "html" === Rt(t) ? t : t.assignedSlot || t.parentNode || (qt(t) ? t.host : null) || Gt(t);\n  }\n\n  function Jt(t) {\n    return zt(t) && "fixed" !== Yt(t).position ? t.offsetParent : null;\n  }\n\n  function te(t) {\n    for (var e = Wt(t), i = Jt(t); i && Qt(i) && "static" === Yt(i).position;) i = Jt(i);\n\n    return i && ("html" === Rt(i) || "body" === Rt(i) && "static" === Yt(i).position) ? e : i || function (t) {\n      var e = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox");\n      if (-1 !== navigator.userAgent.indexOf("Trident") && zt(t) && "fixed" === Yt(t).position) return null;\n\n      for (var i = Zt(t); zt(i) && ["html", "body"].indexOf(Rt(i)) < 0;) {\n        var n = Yt(i);\n        if ("none" !== n.transform || "none" !== n.perspective || "paint" === n.contain || -1 !== ["transform", "perspective"].indexOf(n.willChange) || e && "filter" === n.willChange || e && n.filter && "none" !== n.filter) return i;\n        i = i.parentNode;\n      }\n\n      return null;\n    }(t) || e;\n  }\n\n  function ee(t) {\n    return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";\n  }\n\n  var ie = Math.max,\n      ne = Math.min,\n      se = Math.round;\n\n  function oe(t, e, i) {\n    return ie(t, ne(e, i));\n  }\n\n  function re(t) {\n    return Object.assign({}, {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }, t);\n  }\n\n  function ae(t, e) {\n    return e.reduce(function (e, i) {\n      return e[i] = t, e;\n    }, {});\n  }\n\n  const le = {\n    name: "arrow",\n    enabled: !0,\n    phase: "main",\n    fn: function (t) {\n      var e,\n          i = t.state,\n          n = t.name,\n          s = t.options,\n          o = i.elements.arrow,\n          r = i.modifiersData.popperOffsets,\n          a = Ut(i.placement),\n          l = ee(a),\n          c = [bt, _t].indexOf(a) >= 0 ? "height" : "width";\n\n      if (o && r) {\n        var h = function (t, e) {\n          return re("number" != typeof (t = "function" == typeof t ? t(Object.assign({}, e.rects, {\n            placement: e.placement\n          })) : t) ? t : ae(t, yt));\n        }(s.padding, i),\n            d = Kt(o),\n            u = "y" === l ? mt : bt,\n            f = "y" === l ? gt : _t,\n            p = i.rects.reference[c] + i.rects.reference[l] - r[l] - i.rects.popper[c],\n            m = r[l] - i.rects.reference[l],\n            g = te(o),\n            _ = g ? "y" === l ? g.clientHeight || 0 : g.clientWidth || 0 : 0,\n            b = p / 2 - m / 2,\n            v = h[u],\n            y = _ - d[c] - h[f],\n            w = _ / 2 - d[c] / 2 + b,\n            E = oe(v, w, y),\n            A = l;\n\n        i.modifiersData[n] = ((e = {})[A] = E, e.centerOffset = E - w, e);\n      }\n    },\n    effect: function (t) {\n      var e = t.state,\n          i = t.options.element,\n          n = void 0 === i ? "[data-popper-arrow]" : i;\n      null != n && ("string" != typeof n || (n = e.elements.popper.querySelector(n))) && Xt(e.elements.popper, n) && (e.elements.arrow = n);\n    },\n    requires: ["popperOffsets"],\n    requiresIfExists: ["preventOverflow"]\n  };\n\n  function ce(t) {\n    return t.split("-")[1];\n  }\n\n  var he = {\n    top: "auto",\n    right: "auto",\n    bottom: "auto",\n    left: "auto"\n  };\n\n  function de(t) {\n    var e,\n        i = t.popper,\n        n = t.popperRect,\n        s = t.placement,\n        o = t.variation,\n        r = t.offsets,\n        a = t.position,\n        l = t.gpuAcceleration,\n        c = t.adaptive,\n        h = t.roundOffsets,\n        d = !0 === h ? function (t) {\n      var e = t.x,\n          i = t.y,\n          n = window.devicePixelRatio || 1;\n      return {\n        x: se(se(e * n) / n) || 0,\n        y: se(se(i * n) / n) || 0\n      };\n    }(r) : "function" == typeof h ? h(r) : r,\n        u = d.x,\n        f = void 0 === u ? 0 : u,\n        p = d.y,\n        m = void 0 === p ? 0 : p,\n        g = r.hasOwnProperty("x"),\n        _ = r.hasOwnProperty("y"),\n        b = bt,\n        v = mt,\n        y = window;\n\n    if (c) {\n      var w = te(i),\n          E = "clientHeight",\n          A = "clientWidth";\n      w === Wt(i) && "static" !== Yt(w = Gt(i)).position && "absolute" === a && (E = "scrollHeight", A = "scrollWidth"), w = w, s !== mt && (s !== bt && s !== _t || o !== Et) || (v = gt, m -= w[E] - n.height, m *= l ? 1 : -1), s !== bt && (s !== mt && s !== gt || o !== Et) || (b = _t, f -= w[A] - n.width, f *= l ? 1 : -1);\n    }\n\n    var T,\n        O = Object.assign({\n      position: a\n    }, c && he);\n    return l ? Object.assign({}, O, ((T = {})[v] = _ ? "0" : "", T[b] = g ? "0" : "", T.transform = (y.devicePixelRatio || 1) <= 1 ? "translate(" + f + "px, " + m + "px)" : "translate3d(" + f + "px, " + m + "px, 0)", T)) : Object.assign({}, O, ((e = {})[v] = _ ? m + "px" : "", e[b] = g ? f + "px" : "", e.transform = "", e));\n  }\n\n  const ue = {\n    name: "computeStyles",\n    enabled: !0,\n    phase: "beforeWrite",\n    fn: function (t) {\n      var e = t.state,\n          i = t.options,\n          n = i.gpuAcceleration,\n          s = void 0 === n || n,\n          o = i.adaptive,\n          r = void 0 === o || o,\n          a = i.roundOffsets,\n          l = void 0 === a || a,\n          c = {\n        placement: Ut(e.placement),\n        variation: ce(e.placement),\n        popper: e.elements.popper,\n        popperRect: e.rects.popper,\n        gpuAcceleration: s\n      };\n      null != e.modifiersData.popperOffsets && (e.styles.popper = Object.assign({}, e.styles.popper, de(Object.assign({}, c, {\n        offsets: e.modifiersData.popperOffsets,\n        position: e.options.strategy,\n        adaptive: r,\n        roundOffsets: l\n      })))), null != e.modifiersData.arrow && (e.styles.arrow = Object.assign({}, e.styles.arrow, de(Object.assign({}, c, {\n        offsets: e.modifiersData.arrow,\n        position: "absolute",\n        adaptive: !1,\n        roundOffsets: l\n      })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {\n        "data-popper-placement": e.placement\n      });\n    },\n    data: {}\n  };\n  var fe = {\n    passive: !0\n  };\n  const pe = {\n    name: "eventListeners",\n    enabled: !0,\n    phase: "write",\n    fn: function () {},\n    effect: function (t) {\n      var e = t.state,\n          i = t.instance,\n          n = t.options,\n          s = n.scroll,\n          o = void 0 === s || s,\n          r = n.resize,\n          a = void 0 === r || r,\n          l = Wt(e.elements.popper),\n          c = [].concat(e.scrollParents.reference, e.scrollParents.popper);\n      return o && c.forEach(function (t) {\n        t.addEventListener("scroll", i.update, fe);\n      }), a && l.addEventListener("resize", i.update, fe), function () {\n        o && c.forEach(function (t) {\n          t.removeEventListener("scroll", i.update, fe);\n        }), a && l.removeEventListener("resize", i.update, fe);\n      };\n    },\n    data: {}\n  };\n  var me = {\n    left: "right",\n    right: "left",\n    bottom: "top",\n    top: "bottom"\n  };\n\n  function ge(t) {\n    return t.replace(/left|right|bottom|top/g, function (t) {\n      return me[t];\n    });\n  }\n\n  var _e = {\n    start: "end",\n    end: "start"\n  };\n\n  function be(t) {\n    return t.replace(/start|end/g, function (t) {\n      return _e[t];\n    });\n  }\n\n  function ve(t) {\n    var e = Wt(t);\n    return {\n      scrollLeft: e.pageXOffset,\n      scrollTop: e.pageYOffset\n    };\n  }\n\n  function ye(t) {\n    return Vt(Gt(t)).left + ve(t).scrollLeft;\n  }\n\n  function we(t) {\n    var e = Yt(t),\n        i = e.overflow,\n        n = e.overflowX,\n        s = e.overflowY;\n    return /auto|scroll|overlay|hidden/.test(i + s + n);\n  }\n\n  function Ee(t) {\n    return ["html", "body", "#document"].indexOf(Rt(t)) >= 0 ? t.ownerDocument.body : zt(t) && we(t) ? t : Ee(Zt(t));\n  }\n\n  function Ae(t, e) {\n    var i;\n    void 0 === e && (e = []);\n    var n = Ee(t),\n        s = n === (null == (i = t.ownerDocument) ? void 0 : i.body),\n        o = Wt(n),\n        r = s ? [o].concat(o.visualViewport || [], we(n) ? n : []) : n,\n        a = e.concat(r);\n    return s ? a : a.concat(Ae(Zt(r)));\n  }\n\n  function Te(t) {\n    return Object.assign({}, t, {\n      left: t.x,\n      top: t.y,\n      right: t.x + t.width,\n      bottom: t.y + t.height\n    });\n  }\n\n  function Oe(t, e) {\n    return e === Tt ? Te(function (t) {\n      var e = Wt(t),\n          i = Gt(t),\n          n = e.visualViewport,\n          s = i.clientWidth,\n          o = i.clientHeight,\n          r = 0,\n          a = 0;\n      return n && (s = n.width, o = n.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (r = n.offsetLeft, a = n.offsetTop)), {\n        width: s,\n        height: o,\n        x: r + ye(t),\n        y: a\n      };\n    }(t)) : zt(e) ? function (t) {\n      var e = Vt(t);\n      return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e;\n    }(e) : Te(function (t) {\n      var e,\n          i = Gt(t),\n          n = ve(t),\n          s = null == (e = t.ownerDocument) ? void 0 : e.body,\n          o = ie(i.scrollWidth, i.clientWidth, s ? s.scrollWidth : 0, s ? s.clientWidth : 0),\n          r = ie(i.scrollHeight, i.clientHeight, s ? s.scrollHeight : 0, s ? s.clientHeight : 0),\n          a = -n.scrollLeft + ye(t),\n          l = -n.scrollTop;\n      return "rtl" === Yt(s || i).direction && (a += ie(i.clientWidth, s ? s.clientWidth : 0) - o), {\n        width: o,\n        height: r,\n        x: a,\n        y: l\n      };\n    }(Gt(t)));\n  }\n\n  function Ce(t) {\n    var e,\n        i = t.reference,\n        n = t.element,\n        s = t.placement,\n        o = s ? Ut(s) : null,\n        r = s ? ce(s) : null,\n        a = i.x + i.width / 2 - n.width / 2,\n        l = i.y + i.height / 2 - n.height / 2;\n\n    switch (o) {\n      case mt:\n        e = {\n          x: a,\n          y: i.y - n.height\n        };\n        break;\n\n      case gt:\n        e = {\n          x: a,\n          y: i.y + i.height\n        };\n        break;\n\n      case _t:\n        e = {\n          x: i.x + i.width,\n          y: l\n        };\n        break;\n\n      case bt:\n        e = {\n          x: i.x - n.width,\n          y: l\n        };\n        break;\n\n      default:\n        e = {\n          x: i.x,\n          y: i.y\n        };\n    }\n\n    var c = o ? ee(o) : null;\n\n    if (null != c) {\n      var h = "y" === c ? "height" : "width";\n\n      switch (r) {\n        case wt:\n          e[c] = e[c] - (i[h] / 2 - n[h] / 2);\n          break;\n\n        case Et:\n          e[c] = e[c] + (i[h] / 2 - n[h] / 2);\n      }\n    }\n\n    return e;\n  }\n\n  function ke(t, e) {\n    void 0 === e && (e = {});\n\n    var i = e,\n        n = i.placement,\n        s = void 0 === n ? t.placement : n,\n        o = i.boundary,\n        r = void 0 === o ? At : o,\n        a = i.rootBoundary,\n        l = void 0 === a ? Tt : a,\n        c = i.elementContext,\n        h = void 0 === c ? Ot : c,\n        d = i.altBoundary,\n        u = void 0 !== d && d,\n        f = i.padding,\n        p = void 0 === f ? 0 : f,\n        m = re("number" != typeof p ? p : ae(p, yt)),\n        g = h === Ot ? Ct : Ot,\n        _ = t.rects.popper,\n        b = t.elements[u ? g : h],\n        v = function (t, e, i) {\n      var n = "clippingParents" === e ? function (t) {\n        var e = Ae(Zt(t)),\n            i = ["absolute", "fixed"].indexOf(Yt(t).position) >= 0 && zt(t) ? te(t) : t;\n        return $t(i) ? e.filter(function (t) {\n          return $t(t) && Xt(t, i) && "body" !== Rt(t);\n        }) : [];\n      }(t) : [].concat(e),\n          s = [].concat(n, [i]),\n          o = s[0],\n          r = s.reduce(function (e, i) {\n        var n = Oe(t, i);\n        return e.top = ie(n.top, e.top), e.right = ne(n.right, e.right), e.bottom = ne(n.bottom, e.bottom), e.left = ie(n.left, e.left), e;\n      }, Oe(t, o));\n      return r.width = r.right - r.left, r.height = r.bottom - r.top, r.x = r.left, r.y = r.top, r;\n    }($t(b) ? b : b.contextElement || Gt(t.elements.popper), r, l),\n        y = Vt(t.elements.reference),\n        w = Ce({\n      reference: y,\n      element: _,\n      strategy: "absolute",\n      placement: s\n    }),\n        E = Te(Object.assign({}, _, w)),\n        A = h === Ot ? E : y,\n        T = {\n      top: v.top - A.top + m.top,\n      bottom: A.bottom - v.bottom + m.bottom,\n      left: v.left - A.left + m.left,\n      right: A.right - v.right + m.right\n    },\n        O = t.modifiersData.offset;\n\n    if (h === Ot && O) {\n      var C = O[s];\n      Object.keys(T).forEach(function (t) {\n        var e = [_t, gt].indexOf(t) >= 0 ? 1 : -1,\n            i = [mt, gt].indexOf(t) >= 0 ? "y" : "x";\n        T[t] += C[i] * e;\n      });\n    }\n\n    return T;\n  }\n\n  function Le(t, e) {\n    void 0 === e && (e = {});\n    var i = e,\n        n = i.placement,\n        s = i.boundary,\n        o = i.rootBoundary,\n        r = i.padding,\n        a = i.flipVariations,\n        l = i.allowedAutoPlacements,\n        c = void 0 === l ? Lt : l,\n        h = ce(n),\n        d = h ? a ? kt : kt.filter(function (t) {\n      return ce(t) === h;\n    }) : yt,\n        u = d.filter(function (t) {\n      return c.indexOf(t) >= 0;\n    });\n    0 === u.length && (u = d);\n    var f = u.reduce(function (e, i) {\n      return e[i] = ke(t, {\n        placement: i,\n        boundary: s,\n        rootBoundary: o,\n        padding: r\n      })[Ut(i)], e;\n    }, {});\n    return Object.keys(f).sort(function (t, e) {\n      return f[t] - f[e];\n    });\n  }\n\n  const xe = {\n    name: "flip",\n    enabled: !0,\n    phase: "main",\n    fn: function (t) {\n      var e = t.state,\n          i = t.options,\n          n = t.name;\n\n      if (!e.modifiersData[n]._skip) {\n        for (var s = i.mainAxis, o = void 0 === s || s, r = i.altAxis, a = void 0 === r || r, l = i.fallbackPlacements, c = i.padding, h = i.boundary, d = i.rootBoundary, u = i.altBoundary, f = i.flipVariations, p = void 0 === f || f, m = i.allowedAutoPlacements, g = e.options.placement, _ = Ut(g), b = l || (_ !== g && p ? function (t) {\n          if (Ut(t) === vt) return [];\n          var e = ge(t);\n          return [be(t), e, be(e)];\n        }(g) : [ge(g)]), v = [g].concat(b).reduce(function (t, i) {\n          return t.concat(Ut(i) === vt ? Le(e, {\n            placement: i,\n            boundary: h,\n            rootBoundary: d,\n            padding: c,\n            flipVariations: p,\n            allowedAutoPlacements: m\n          }) : i);\n        }, []), y = e.rects.reference, w = e.rects.popper, E = new Map(), A = !0, T = v[0], O = 0; O < v.length; O++) {\n          var C = v[O],\n              k = Ut(C),\n              L = ce(C) === wt,\n              x = [mt, gt].indexOf(k) >= 0,\n              D = x ? "width" : "height",\n              S = ke(e, {\n            placement: C,\n            boundary: h,\n            rootBoundary: d,\n            altBoundary: u,\n            padding: c\n          }),\n              N = x ? L ? _t : bt : L ? gt : mt;\n          y[D] > w[D] && (N = ge(N));\n          var I = ge(N),\n              P = [];\n\n          if (o && P.push(S[k] <= 0), a && P.push(S[N] <= 0, S[I] <= 0), P.every(function (t) {\n            return t;\n          })) {\n            T = C, A = !1;\n            break;\n          }\n\n          E.set(C, P);\n        }\n\n        if (A) for (var j = function (t) {\n          var e = v.find(function (e) {\n            var i = E.get(e);\n            if (i) return i.slice(0, t).every(function (t) {\n              return t;\n            });\n          });\n          if (e) return T = e, "break";\n        }, M = p ? 3 : 1; M > 0 && "break" !== j(M); M--);\n        e.placement !== T && (e.modifiersData[n]._skip = !0, e.placement = T, e.reset = !0);\n      }\n    },\n    requiresIfExists: ["offset"],\n    data: {\n      _skip: !1\n    }\n  };\n\n  function De(t, e, i) {\n    return void 0 === i && (i = {\n      x: 0,\n      y: 0\n    }), {\n      top: t.top - e.height - i.y,\n      right: t.right - e.width + i.x,\n      bottom: t.bottom - e.height + i.y,\n      left: t.left - e.width - i.x\n    };\n  }\n\n  function Se(t) {\n    return [mt, _t, gt, bt].some(function (e) {\n      return t[e] >= 0;\n    });\n  }\n\n  const Ne = {\n    name: "hide",\n    enabled: !0,\n    phase: "main",\n    requiresIfExists: ["preventOverflow"],\n    fn: function (t) {\n      var e = t.state,\n          i = t.name,\n          n = e.rects.reference,\n          s = e.rects.popper,\n          o = e.modifiersData.preventOverflow,\n          r = ke(e, {\n        elementContext: "reference"\n      }),\n          a = ke(e, {\n        altBoundary: !0\n      }),\n          l = De(r, n),\n          c = De(a, s, o),\n          h = Se(l),\n          d = Se(c);\n      e.modifiersData[i] = {\n        referenceClippingOffsets: l,\n        popperEscapeOffsets: c,\n        isReferenceHidden: h,\n        hasPopperEscaped: d\n      }, e.attributes.popper = Object.assign({}, e.attributes.popper, {\n        "data-popper-reference-hidden": h,\n        "data-popper-escaped": d\n      });\n    }\n  },\n        Ie = {\n    name: "offset",\n    enabled: !0,\n    phase: "main",\n    requires: ["popperOffsets"],\n    fn: function (t) {\n      var e = t.state,\n          i = t.options,\n          n = t.name,\n          s = i.offset,\n          o = void 0 === s ? [0, 0] : s,\n          r = Lt.reduce(function (t, i) {\n        return t[i] = function (t, e, i) {\n          var n = Ut(t),\n              s = [bt, mt].indexOf(n) >= 0 ? -1 : 1,\n              o = "function" == typeof i ? i(Object.assign({}, e, {\n            placement: t\n          })) : i,\n              r = o[0],\n              a = o[1];\n          return r = r || 0, a = (a || 0) * s, [bt, _t].indexOf(n) >= 0 ? {\n            x: a,\n            y: r\n          } : {\n            x: r,\n            y: a\n          };\n        }(i, e.rects, o), t;\n      }, {}),\n          a = r[e.placement],\n          l = a.x,\n          c = a.y;\n      null != e.modifiersData.popperOffsets && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[n] = r;\n    }\n  },\n        Pe = {\n    name: "popperOffsets",\n    enabled: !0,\n    phase: "read",\n    fn: function (t) {\n      var e = t.state,\n          i = t.name;\n      e.modifiersData[i] = Ce({\n        reference: e.rects.reference,\n        element: e.rects.popper,\n        strategy: "absolute",\n        placement: e.placement\n      });\n    },\n    data: {}\n  },\n        je = {\n    name: "preventOverflow",\n    enabled: !0,\n    phase: "main",\n    fn: function (t) {\n      var e = t.state,\n          i = t.options,\n          n = t.name,\n          s = i.mainAxis,\n          o = void 0 === s || s,\n          r = i.altAxis,\n          a = void 0 !== r && r,\n          l = i.boundary,\n          c = i.rootBoundary,\n          h = i.altBoundary,\n          d = i.padding,\n          u = i.tether,\n          f = void 0 === u || u,\n          p = i.tetherOffset,\n          m = void 0 === p ? 0 : p,\n          g = ke(e, {\n        boundary: l,\n        rootBoundary: c,\n        padding: d,\n        altBoundary: h\n      }),\n          _ = Ut(e.placement),\n          b = ce(e.placement),\n          v = !b,\n          y = ee(_),\n          w = "x" === y ? "y" : "x",\n          E = e.modifiersData.popperOffsets,\n          A = e.rects.reference,\n          T = e.rects.popper,\n          O = "function" == typeof m ? m(Object.assign({}, e.rects, {\n        placement: e.placement\n      })) : m,\n          C = {\n        x: 0,\n        y: 0\n      };\n\n      if (E) {\n        if (o || a) {\n          var k = "y" === y ? mt : bt,\n              L = "y" === y ? gt : _t,\n              x = "y" === y ? "height" : "width",\n              D = E[y],\n              S = E[y] + g[k],\n              N = E[y] - g[L],\n              I = f ? -T[x] / 2 : 0,\n              P = b === wt ? A[x] : T[x],\n              j = b === wt ? -T[x] : -A[x],\n              M = e.elements.arrow,\n              H = f && M ? Kt(M) : {\n            width: 0,\n            height: 0\n          },\n              B = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : {\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0\n          },\n              R = B[k],\n              W = B[L],\n              $ = oe(0, A[x], H[x]),\n              z = v ? A[x] / 2 - I - $ - R - O : P - $ - R - O,\n              q = v ? -A[x] / 2 + I + $ + W + O : j + $ + W + O,\n              F = e.elements.arrow && te(e.elements.arrow),\n              U = F ? "y" === y ? F.clientTop || 0 : F.clientLeft || 0 : 0,\n              V = e.modifiersData.offset ? e.modifiersData.offset[e.placement][y] : 0,\n              K = E[y] + z - V - U,\n              X = E[y] + q - V;\n\n          if (o) {\n            var Y = oe(f ? ne(S, K) : S, D, f ? ie(N, X) : N);\n            E[y] = Y, C[y] = Y - D;\n          }\n\n          if (a) {\n            var Q = "x" === y ? mt : bt,\n                G = "x" === y ? gt : _t,\n                Z = E[w],\n                J = Z + g[Q],\n                tt = Z - g[G],\n                et = oe(f ? ne(J, K) : J, Z, f ? ie(tt, X) : tt);\n            E[w] = et, C[w] = et - Z;\n          }\n        }\n\n        e.modifiersData[n] = C;\n      }\n    },\n    requiresIfExists: ["offset"]\n  };\n\n  function Me(t, e, i) {\n    void 0 === i && (i = !1);\n    var n = zt(e);\n    zt(e) && function (t) {\n      var e = t.getBoundingClientRect();\n      e.width, t.offsetWidth, e.height, t.offsetHeight;\n    }(e);\n    var s,\n        o,\n        r = Gt(e),\n        a = Vt(t),\n        l = {\n      scrollLeft: 0,\n      scrollTop: 0\n    },\n        c = {\n      x: 0,\n      y: 0\n    };\n    return (n || !n && !i) && (("body" !== Rt(e) || we(r)) && (l = (s = e) !== Wt(s) && zt(s) ? {\n      scrollLeft: (o = s).scrollLeft,\n      scrollTop: o.scrollTop\n    } : ve(s)), zt(e) ? ((c = Vt(e)).x += e.clientLeft, c.y += e.clientTop) : r && (c.x = ye(r))), {\n      x: a.left + l.scrollLeft - c.x,\n      y: a.top + l.scrollTop - c.y,\n      width: a.width,\n      height: a.height\n    };\n  }\n\n  function He(t) {\n    var e = new Map(),\n        i = new Set(),\n        n = [];\n\n    function s(t) {\n      i.add(t.name), [].concat(t.requires || [], t.requiresIfExists || []).forEach(function (t) {\n        if (!i.has(t)) {\n          var n = e.get(t);\n          n && s(n);\n        }\n      }), n.push(t);\n    }\n\n    return t.forEach(function (t) {\n      e.set(t.name, t);\n    }), t.forEach(function (t) {\n      i.has(t.name) || s(t);\n    }), n;\n  }\n\n  var Be = {\n    placement: "bottom",\n    modifiers: [],\n    strategy: "absolute"\n  };\n\n  function Re() {\n    for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];\n\n    return !e.some(function (t) {\n      return !(t && "function" == typeof t.getBoundingClientRect);\n    });\n  }\n\n  function We(t) {\n    void 0 === t && (t = {});\n    var e = t,\n        i = e.defaultModifiers,\n        n = void 0 === i ? [] : i,\n        s = e.defaultOptions,\n        o = void 0 === s ? Be : s;\n    return function (t, e, i) {\n      void 0 === i && (i = o);\n      var s,\n          r,\n          a = {\n        placement: "bottom",\n        orderedModifiers: [],\n        options: Object.assign({}, Be, o),\n        modifiersData: {},\n        elements: {\n          reference: t,\n          popper: e\n        },\n        attributes: {},\n        styles: {}\n      },\n          l = [],\n          c = !1,\n          h = {\n        state: a,\n        setOptions: function (i) {\n          var s = "function" == typeof i ? i(a.options) : i;\n          d(), a.options = Object.assign({}, o, a.options, s), a.scrollParents = {\n            reference: $t(t) ? Ae(t) : t.contextElement ? Ae(t.contextElement) : [],\n            popper: Ae(e)\n          };\n\n          var r,\n              c,\n              u = function (t) {\n            var e = He(t);\n            return Bt.reduce(function (t, i) {\n              return t.concat(e.filter(function (t) {\n                return t.phase === i;\n              }));\n            }, []);\n          }((r = [].concat(n, a.options.modifiers), c = r.reduce(function (t, e) {\n            var i = t[e.name];\n            return t[e.name] = i ? Object.assign({}, i, e, {\n              options: Object.assign({}, i.options, e.options),\n              data: Object.assign({}, i.data, e.data)\n            }) : e, t;\n          }, {}), Object.keys(c).map(function (t) {\n            return c[t];\n          })));\n\n          return a.orderedModifiers = u.filter(function (t) {\n            return t.enabled;\n          }), a.orderedModifiers.forEach(function (t) {\n            var e = t.name,\n                i = t.options,\n                n = void 0 === i ? {} : i,\n                s = t.effect;\n\n            if ("function" == typeof s) {\n              var o = s({\n                state: a,\n                name: e,\n                instance: h,\n                options: n\n              });\n              l.push(o || function () {});\n            }\n          }), h.update();\n        },\n        forceUpdate: function () {\n          if (!c) {\n            var t = a.elements,\n                e = t.reference,\n                i = t.popper;\n\n            if (Re(e, i)) {\n              a.rects = {\n                reference: Me(e, te(i), "fixed" === a.options.strategy),\n                popper: Kt(i)\n              }, a.reset = !1, a.placement = a.options.placement, a.orderedModifiers.forEach(function (t) {\n                return a.modifiersData[t.name] = Object.assign({}, t.data);\n              });\n\n              for (var n = 0; n < a.orderedModifiers.length; n++) if (!0 !== a.reset) {\n                var s = a.orderedModifiers[n],\n                    o = s.fn,\n                    r = s.options,\n                    l = void 0 === r ? {} : r,\n                    d = s.name;\n                "function" == typeof o && (a = o({\n                  state: a,\n                  options: l,\n                  name: d,\n                  instance: h\n                }) || a);\n              } else a.reset = !1, n = -1;\n            }\n          }\n        },\n        update: (s = function () {\n          return new Promise(function (t) {\n            h.forceUpdate(), t(a);\n          });\n        }, function () {\n          return r || (r = new Promise(function (t) {\n            Promise.resolve().then(function () {\n              r = void 0, t(s());\n            });\n          })), r;\n        }),\n        destroy: function () {\n          d(), c = !0;\n        }\n      };\n      if (!Re(t, e)) return h;\n\n      function d() {\n        l.forEach(function (t) {\n          return t();\n        }), l = [];\n      }\n\n      return h.setOptions(i).then(function (t) {\n        !c && i.onFirstUpdate && i.onFirstUpdate(t);\n      }), h;\n    };\n  }\n\n  var $e = We(),\n      ze = We({\n    defaultModifiers: [pe, Pe, ue, Ft]\n  }),\n      qe = We({\n    defaultModifiers: [pe, Pe, ue, Ft, Ie, xe, je, le, Ne]\n  });\n  const Fe = Object.freeze({\n    __proto__: null,\n    popperGenerator: We,\n    detectOverflow: ke,\n    createPopperBase: $e,\n    createPopper: qe,\n    createPopperLite: ze,\n    top: mt,\n    bottom: gt,\n    right: _t,\n    left: bt,\n    auto: vt,\n    basePlacements: yt,\n    start: wt,\n    end: Et,\n    clippingParents: At,\n    viewport: Tt,\n    popper: Ot,\n    reference: Ct,\n    variationPlacements: kt,\n    placements: Lt,\n    beforeRead: xt,\n    read: Dt,\n    afterRead: St,\n    beforeMain: Nt,\n    main: It,\n    afterMain: Pt,\n    beforeWrite: jt,\n    write: Mt,\n    afterWrite: Ht,\n    modifierPhases: Bt,\n    applyStyles: Ft,\n    arrow: le,\n    computeStyles: ue,\n    eventListeners: pe,\n    flip: xe,\n    hide: Ne,\n    offset: Ie,\n    popperOffsets: Pe,\n    preventOverflow: je\n  }),\n        Ue = "dropdown",\n        Ve = "Escape",\n        Ke = "Space",\n        Xe = "ArrowUp",\n        Ye = "ArrowDown",\n        Qe = new RegExp("ArrowUp|ArrowDown|Escape"),\n        Ge = "click.bs.dropdown.data-api",\n        Ze = "keydown.bs.dropdown.data-api",\n        Je = "show",\n        ti = \'[data-bs-toggle="dropdown"]\',\n        ei = ".dropdown-menu",\n        ii = m() ? "top-end" : "top-start",\n        ni = m() ? "top-start" : "top-end",\n        si = m() ? "bottom-end" : "bottom-start",\n        oi = m() ? "bottom-start" : "bottom-end",\n        ri = m() ? "left-start" : "right-start",\n        ai = m() ? "right-start" : "left-start",\n        li = {\n    offset: [0, 2],\n    boundary: "clippingParents",\n    reference: "toggle",\n    display: "dynamic",\n    popperConfig: null,\n    autoClose: !0\n  },\n        ci = {\n    offset: "(array|string|function)",\n    boundary: "(string|element)",\n    reference: "(string|element|object)",\n    display: "string",\n    popperConfig: "(null|object|function)",\n    autoClose: "(boolean|string)"\n  };\n\n  class hi extends B {\n    constructor(t, e) {\n      super(t), this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar();\n    }\n\n    static get Default() {\n      return li;\n    }\n\n    static get DefaultType() {\n      return ci;\n    }\n\n    static get NAME() {\n      return Ue;\n    }\n\n    toggle() {\n      return this._isShown() ? this.hide() : this.show();\n    }\n\n    show() {\n      if (c(this._element) || this._isShown(this._menu)) return;\n      const t = {\n        relatedTarget: this._element\n      };\n      if (j.trigger(this._element, "show.bs.dropdown", t).defaultPrevented) return;\n      const e = hi.getParentFromElement(this._element);\n      this._inNavbar ? U.setDataAttribute(this._menu, "popper", "none") : this._createPopper(e), "ontouchstart" in document.documentElement && !e.closest(".navbar-nav") && [].concat(...document.body.children).forEach(t => j.on(t, "mouseover", d)), this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add(Je), this._element.classList.add(Je), j.trigger(this._element, "shown.bs.dropdown", t);\n    }\n\n    hide() {\n      if (c(this._element) || !this._isShown(this._menu)) return;\n      const t = {\n        relatedTarget: this._element\n      };\n\n      this._completeHide(t);\n    }\n\n    dispose() {\n      this._popper && this._popper.destroy(), super.dispose();\n    }\n\n    update() {\n      this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();\n    }\n\n    _completeHide(t) {\n      j.trigger(this._element, "hide.bs.dropdown", t).defaultPrevented || ("ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach(t => j.off(t, "mouseover", d)), this._popper && this._popper.destroy(), this._menu.classList.remove(Je), this._element.classList.remove(Je), this._element.setAttribute("aria-expanded", "false"), U.removeDataAttribute(this._menu, "popper"), j.trigger(this._element, "hidden.bs.dropdown", t));\n    }\n\n    _getConfig(t) {\n      if (t = { ...this.constructor.Default,\n        ...U.getDataAttributes(this._element),\n        ...t\n      }, a(Ue, t, this.constructor.DefaultType), "object" == typeof t.reference && !o(t.reference) && "function" != typeof t.reference.getBoundingClientRect) throw new TypeError(`${Ue.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);\n      return t;\n    }\n\n    _createPopper(t) {\n      if (void 0 === Fe) throw new TypeError("Bootstrap\'s dropdowns require Popper (https://popper.js.org)");\n      let e = this._element;\n      "parent" === this._config.reference ? e = t : o(this._config.reference) ? e = r(this._config.reference) : "object" == typeof this._config.reference && (e = this._config.reference);\n\n      const i = this._getPopperConfig(),\n            n = i.modifiers.find(t => "applyStyles" === t.name && !1 === t.enabled);\n\n      this._popper = qe(e, this._menu, i), n && U.setDataAttribute(this._menu, "popper", "static");\n    }\n\n    _isShown(t = this._element) {\n      return t.classList.contains(Je);\n    }\n\n    _getMenuElement() {\n      return V.next(this._element, ei)[0];\n    }\n\n    _getPlacement() {\n      const t = this._element.parentNode;\n      if (t.classList.contains("dropend")) return ri;\n      if (t.classList.contains("dropstart")) return ai;\n      const e = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();\n      return t.classList.contains("dropup") ? e ? ni : ii : e ? oi : si;\n    }\n\n    _detectNavbar() {\n      return null !== this._element.closest(".navbar");\n    }\n\n    _getOffset() {\n      const {\n        offset: t\n      } = this._config;\n      return "string" == typeof t ? t.split(",").map(t => Number.parseInt(t, 10)) : "function" == typeof t ? e => t(e, this._element) : t;\n    }\n\n    _getPopperConfig() {\n      const t = {\n        placement: this._getPlacement(),\n        modifiers: [{\n          name: "preventOverflow",\n          options: {\n            boundary: this._config.boundary\n          }\n        }, {\n          name: "offset",\n          options: {\n            offset: this._getOffset()\n          }\n        }]\n      };\n      return "static" === this._config.display && (t.modifiers = [{\n        name: "applyStyles",\n        enabled: !1\n      }]), { ...t,\n        ...("function" == typeof this._config.popperConfig ? this._config.popperConfig(t) : this._config.popperConfig)\n      };\n    }\n\n    _selectMenuItem({\n      key: t,\n      target: e\n    }) {\n      const i = V.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter(l);\n      i.length && v(i, e, t === Ye, !i.includes(e)).focus();\n    }\n\n    static jQueryInterface(t) {\n      return this.each(function () {\n        const e = hi.getOrCreateInstance(this, t);\n\n        if ("string" == typeof t) {\n          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);\n          e[t]();\n        }\n      });\n    }\n\n    static clearMenus(t) {\n      if (t && (2 === t.button || "keyup" === t.type && "Tab" !== t.key)) return;\n      const e = V.find(ti);\n\n      for (let i = 0, n = e.length; i < n; i++) {\n        const n = hi.getInstance(e[i]);\n        if (!n || !1 === n._config.autoClose) continue;\n        if (!n._isShown()) continue;\n        const s = {\n          relatedTarget: n._element\n        };\n\n        if (t) {\n          const e = t.composedPath(),\n                i = e.includes(n._menu);\n          if (e.includes(n._element) || "inside" === n._config.autoClose && !i || "outside" === n._config.autoClose && i) continue;\n          if (n._menu.contains(t.target) && ("keyup" === t.type && "Tab" === t.key || /input|select|option|textarea|form/i.test(t.target.tagName))) continue;\n          "click" === t.type && (s.clickEvent = t);\n        }\n\n        n._completeHide(s);\n      }\n    }\n\n    static getParentFromElement(t) {\n      return n(t) || t.parentNode;\n    }\n\n    static dataApiKeydownHandler(t) {\n      if (/input|textarea/i.test(t.target.tagName) ? t.key === Ke || t.key !== Ve && (t.key !== Ye && t.key !== Xe || t.target.closest(ei)) : !Qe.test(t.key)) return;\n      const e = this.classList.contains(Je);\n      if (!e && t.key === Ve) return;\n      if (t.preventDefault(), t.stopPropagation(), c(this)) return;\n      const i = this.matches(ti) ? this : V.prev(this, ti)[0],\n            n = hi.getOrCreateInstance(i);\n      if (t.key !== Ve) return t.key === Xe || t.key === Ye ? (e || n.show(), void n._selectMenuItem(t)) : void (e && t.key !== Ke || hi.clearMenus());\n      n.hide();\n    }\n\n  }\n\n  j.on(document, Ze, ti, hi.dataApiKeydownHandler), j.on(document, Ze, ei, hi.dataApiKeydownHandler), j.on(document, Ge, hi.clearMenus), j.on(document, "keyup.bs.dropdown.data-api", hi.clearMenus), j.on(document, Ge, ti, function (t) {\n    t.preventDefault(), hi.getOrCreateInstance(this).toggle();\n  }), g(hi);\n  const di = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",\n        ui = ".sticky-top";\n\n  class fi {\n    constructor() {\n      this._element = document.body;\n    }\n\n    getWidth() {\n      const t = document.documentElement.clientWidth;\n      return Math.abs(window.innerWidth - t);\n    }\n\n    hide() {\n      const t = this.getWidth();\n      this._disableOverFlow(), this._setElementAttributes(this._element, "paddingRight", e => e + t), this._setElementAttributes(di, "paddingRight", e => e + t), this._setElementAttributes(ui, "marginRight", e => e - t);\n    }\n\n    _disableOverFlow() {\n      this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden";\n    }\n\n    _setElementAttributes(t, e, i) {\n      const n = this.getWidth();\n\n      this._applyManipulationCallback(t, t => {\n        if (t !== this._element && window.innerWidth > t.clientWidth + n) return;\n\n        this._saveInitialAttribute(t, e);\n\n        const s = window.getComputedStyle(t)[e];\n        t.style[e] = `${i(Number.parseFloat(s))}px`;\n      });\n    }\n\n    reset() {\n      this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, "paddingRight"), this._resetElementAttributes(di, "paddingRight"), this._resetElementAttributes(ui, "marginRight");\n    }\n\n    _saveInitialAttribute(t, e) {\n      const i = t.style[e];\n      i && U.setDataAttribute(t, e, i);\n    }\n\n    _resetElementAttributes(t, e) {\n      this._applyManipulationCallback(t, t => {\n        const i = U.getDataAttribute(t, e);\n        void 0 === i ? t.style.removeProperty(e) : (U.removeDataAttribute(t, e), t.style[e] = i);\n      });\n    }\n\n    _applyManipulationCallback(t, e) {\n      o(t) ? e(t) : V.find(t, this._element).forEach(e);\n    }\n\n    isOverflowing() {\n      return this.getWidth() > 0;\n    }\n\n  }\n\n  const pi = {\n    className: "modal-backdrop",\n    isVisible: !0,\n    isAnimated: !1,\n    rootElement: "body",\n    clickCallback: null\n  },\n        mi = {\n    className: "string",\n    isVisible: "boolean",\n    isAnimated: "boolean",\n    rootElement: "(element|string)",\n    clickCallback: "(function|null)"\n  },\n        gi = "show",\n        _i = "mousedown.bs.backdrop";\n\n  class bi {\n    constructor(t) {\n      this._config = this._getConfig(t), this._isAppended = !1, this._element = null;\n    }\n\n    show(t) {\n      this._config.isVisible ? (this._append(), this._config.isAnimated && u(this._getElement()), this._getElement().classList.add(gi), this._emulateAnimation(() => {\n        _(t);\n      })) : _(t);\n    }\n\n    hide(t) {\n      this._config.isVisible ? (this._getElement().classList.remove(gi), this._emulateAnimation(() => {\n        this.dispose(), _(t);\n      })) : _(t);\n    }\n\n    _getElement() {\n      if (!this._element) {\n        const t = document.createElement("div");\n        t.className = this._config.className, this._config.isAnimated && t.classList.add("fade"), this._element = t;\n      }\n\n      return this._element;\n    }\n\n    _getConfig(t) {\n      return (t = { ...pi,\n        ...("object" == typeof t ? t : {})\n      }).rootElement = r(t.rootElement), a("backdrop", t, mi), t;\n    }\n\n    _append() {\n      this._isAppended || (this._config.rootElement.append(this._getElement()), j.on(this._getElement(), _i, () => {\n        _(this._config.clickCallback);\n      }), this._isAppended = !0);\n    }\n\n    dispose() {\n      this._isAppended && (j.off(this._element, _i), this._element.remove(), this._isAppended = !1);\n    }\n\n    _emulateAnimation(t) {\n      b(t, this._getElement(), this._config.isAnimated);\n    }\n\n  }\n\n  const vi = {\n    trapElement: null,\n    autofocus: !0\n  },\n        yi = {\n    trapElement: "element",\n    autofocus: "boolean"\n  },\n        wi = ".bs.focustrap",\n        Ei = "backward";\n\n  class Ai {\n    constructor(t) {\n      this._config = this._getConfig(t), this._isActive = !1, this._lastTabNavDirection = null;\n    }\n\n    activate() {\n      const {\n        trapElement: t,\n        autofocus: e\n      } = this._config;\n      this._isActive || (e && t.focus(), j.off(document, wi), j.on(document, "focusin.bs.focustrap", t => this._handleFocusin(t)), j.on(document, "keydown.tab.bs.focustrap", t => this._handleKeydown(t)), this._isActive = !0);\n    }\n\n    deactivate() {\n      this._isActive && (this._isActive = !1, j.off(document, wi));\n    }\n\n    _handleFocusin(t) {\n      const {\n        target: e\n      } = t,\n            {\n        trapElement: i\n      } = this._config;\n      if (e === document || e === i || i.contains(e)) return;\n      const n = V.focusableChildren(i);\n      0 === n.length ? i.focus() : this._lastTabNavDirection === Ei ? n[n.length - 1].focus() : n[0].focus();\n    }\n\n    _handleKeydown(t) {\n      "Tab" === t.key && (this._lastTabNavDirection = t.shiftKey ? Ei : "forward");\n    }\n\n    _getConfig(t) {\n      return t = { ...vi,\n        ...("object" == typeof t ? t : {})\n      }, a("focustrap", t, yi), t;\n    }\n\n  }\n\n  const Ti = "modal",\n        Oi = "Escape",\n        Ci = {\n    backdrop: !0,\n    keyboard: !0,\n    focus: !0\n  },\n        ki = {\n    backdrop: "(boolean|string)",\n    keyboard: "boolean",\n    focus: "boolean"\n  },\n        Li = "hidden.bs.modal",\n        xi = "show.bs.modal",\n        Di = "resize.bs.modal",\n        Si = "click.dismiss.bs.modal",\n        Ni = "keydown.dismiss.bs.modal",\n        Ii = "mousedown.dismiss.bs.modal",\n        Pi = "modal-open",\n        ji = "show",\n        Mi = "modal-static";\n\n  class Hi extends B {\n    constructor(t, e) {\n      super(t), this._config = this._getConfig(e), this._dialog = V.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollBar = new fi();\n    }\n\n    static get Default() {\n      return Ci;\n    }\n\n    static get NAME() {\n      return Ti;\n    }\n\n    toggle(t) {\n      return this._isShown ? this.hide() : this.show(t);\n    }\n\n    show(t) {\n      this._isShown || this._isTransitioning || j.trigger(this._element, xi, {\n        relatedTarget: t\n      }).defaultPrevented || (this._isShown = !0, this._isAnimated() && (this._isTransitioning = !0), this._scrollBar.hide(), document.body.classList.add(Pi), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), j.on(this._dialog, Ii, () => {\n        j.one(this._element, "mouseup.dismiss.bs.modal", t => {\n          t.target === this._element && (this._ignoreBackdropClick = !0);\n        });\n      }), this._showBackdrop(() => this._showElement(t)));\n    }\n\n    hide() {\n      if (!this._isShown || this._isTransitioning) return;\n      if (j.trigger(this._element, "hide.bs.modal").defaultPrevented) return;\n      this._isShown = !1;\n\n      const t = this._isAnimated();\n\n      t && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), this._focustrap.deactivate(), this._element.classList.remove(ji), j.off(this._element, Si), j.off(this._dialog, Ii), this._queueCallback(() => this._hideModal(), this._element, t);\n    }\n\n    dispose() {\n      [window, this._dialog].forEach(t => j.off(t, ".bs.modal")), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();\n    }\n\n    handleUpdate() {\n      this._adjustDialog();\n    }\n\n    _initializeBackDrop() {\n      return new bi({\n        isVisible: Boolean(this._config.backdrop),\n        isAnimated: this._isAnimated()\n      });\n    }\n\n    _initializeFocusTrap() {\n      return new Ai({\n        trapElement: this._element\n      });\n    }\n\n    _getConfig(t) {\n      return t = { ...Ci,\n        ...U.getDataAttributes(this._element),\n        ...("object" == typeof t ? t : {})\n      }, a(Ti, t, ki), t;\n    }\n\n    _showElement(t) {\n      const e = this._isAnimated(),\n            i = V.findOne(".modal-body", this._dialog);\n\n      this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0, i && (i.scrollTop = 0), e && u(this._element), this._element.classList.add(ji), this._queueCallback(() => {\n        this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, j.trigger(this._element, "shown.bs.modal", {\n          relatedTarget: t\n        });\n      }, this._dialog, e);\n    }\n\n    _setEscapeEvent() {\n      this._isShown ? j.on(this._element, Ni, t => {\n        this._config.keyboard && t.key === Oi ? (t.preventDefault(), this.hide()) : this._config.keyboard || t.key !== Oi || this._triggerBackdropTransition();\n      }) : j.off(this._element, Ni);\n    }\n\n    _setResizeEvent() {\n      this._isShown ? j.on(window, Di, () => this._adjustDialog()) : j.off(window, Di);\n    }\n\n    _hideModal() {\n      this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide(() => {\n        document.body.classList.remove(Pi), this._resetAdjustments(), this._scrollBar.reset(), j.trigger(this._element, Li);\n      });\n    }\n\n    _showBackdrop(t) {\n      j.on(this._element, Si, t => {\n        this._ignoreBackdropClick ? this._ignoreBackdropClick = !1 : t.target === t.currentTarget && (!0 === this._config.backdrop ? this.hide() : "static" === this._config.backdrop && this._triggerBackdropTransition());\n      }), this._backdrop.show(t);\n    }\n\n    _isAnimated() {\n      return this._element.classList.contains("fade");\n    }\n\n    _triggerBackdropTransition() {\n      if (j.trigger(this._element, "hidePrevented.bs.modal").defaultPrevented) return;\n      const {\n        classList: t,\n        scrollHeight: e,\n        style: i\n      } = this._element,\n            n = e > document.documentElement.clientHeight;\n      !n && "hidden" === i.overflowY || t.contains(Mi) || (n || (i.overflowY = "hidden"), t.add(Mi), this._queueCallback(() => {\n        t.remove(Mi), n || this._queueCallback(() => {\n          i.overflowY = "";\n        }, this._dialog);\n      }, this._dialog), this._element.focus());\n    }\n\n    _adjustDialog() {\n      const t = this._element.scrollHeight > document.documentElement.clientHeight,\n            e = this._scrollBar.getWidth(),\n            i = e > 0;\n\n      (!i && t && !m() || i && !t && m()) && (this._element.style.paddingLeft = `${e}px`), (i && !t && !m() || !i && t && m()) && (this._element.style.paddingRight = `${e}px`);\n    }\n\n    _resetAdjustments() {\n      this._element.style.paddingLeft = "", this._element.style.paddingRight = "";\n    }\n\n    static jQueryInterface(t, e) {\n      return this.each(function () {\n        const i = Hi.getOrCreateInstance(this, t);\n\n        if ("string" == typeof t) {\n          if (void 0 === i[t]) throw new TypeError(`No method named "${t}"`);\n          i[t](e);\n        }\n      });\n    }\n\n  }\n\n  j.on(document, "click.bs.modal.data-api", \'[data-bs-toggle="modal"]\', function (t) {\n    const e = n(this);\n    ["A", "AREA"].includes(this.tagName) && t.preventDefault(), j.one(e, xi, t => {\n      t.defaultPrevented || j.one(e, Li, () => {\n        l(this) && this.focus();\n      });\n    });\n    const i = V.findOne(".modal.show");\n    i && Hi.getInstance(i).hide(), Hi.getOrCreateInstance(e).toggle(this);\n  }), R(Hi), g(Hi);\n  const Bi = "offcanvas",\n        Ri = {\n    backdrop: !0,\n    keyboard: !0,\n    scroll: !1\n  },\n        Wi = {\n    backdrop: "boolean",\n    keyboard: "boolean",\n    scroll: "boolean"\n  },\n        $i = "show",\n        zi = ".offcanvas.show",\n        qi = "hidden.bs.offcanvas";\n\n  class Fi extends B {\n    constructor(t, e) {\n      super(t), this._config = this._getConfig(e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners();\n    }\n\n    static get NAME() {\n      return Bi;\n    }\n\n    static get Default() {\n      return Ri;\n    }\n\n    toggle(t) {\n      return this._isShown ? this.hide() : this.show(t);\n    }\n\n    show(t) {\n      this._isShown || j.trigger(this._element, "show.bs.offcanvas", {\n        relatedTarget: t\n      }).defaultPrevented || (this._isShown = !0, this._element.style.visibility = "visible", this._backdrop.show(), this._config.scroll || new fi().hide(), this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add($i), this._queueCallback(() => {\n        this._config.scroll || this._focustrap.activate(), j.trigger(this._element, "shown.bs.offcanvas", {\n          relatedTarget: t\n        });\n      }, this._element, !0));\n    }\n\n    hide() {\n      this._isShown && (j.trigger(this._element, "hide.bs.offcanvas").defaultPrevented || (this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.remove($i), this._backdrop.hide(), this._queueCallback(() => {\n        this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._element.style.visibility = "hidden", this._config.scroll || new fi().reset(), j.trigger(this._element, qi);\n      }, this._element, !0)));\n    }\n\n    dispose() {\n      this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();\n    }\n\n    _getConfig(t) {\n      return t = { ...Ri,\n        ...U.getDataAttributes(this._element),\n        ...("object" == typeof t ? t : {})\n      }, a(Bi, t, Wi), t;\n    }\n\n    _initializeBackDrop() {\n      return new bi({\n        className: "offcanvas-backdrop",\n        isVisible: this._config.backdrop,\n        isAnimated: !0,\n        rootElement: this._element.parentNode,\n        clickCallback: () => this.hide()\n      });\n    }\n\n    _initializeFocusTrap() {\n      return new Ai({\n        trapElement: this._element\n      });\n    }\n\n    _addEventListeners() {\n      j.on(this._element, "keydown.dismiss.bs.offcanvas", t => {\n        this._config.keyboard && "Escape" === t.key && this.hide();\n      });\n    }\n\n    static jQueryInterface(t) {\n      return this.each(function () {\n        const e = Fi.getOrCreateInstance(this, t);\n\n        if ("string" == typeof t) {\n          if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);\n          e[t](this);\n        }\n      });\n    }\n\n  }\n\n  j.on(document, "click.bs.offcanvas.data-api", \'[data-bs-toggle="offcanvas"]\', function (t) {\n    const e = n(this);\n    if (["A", "AREA"].includes(this.tagName) && t.preventDefault(), c(this)) return;\n    j.one(e, qi, () => {\n      l(this) && this.focus();\n    });\n    const i = V.findOne(zi);\n    i && i !== e && Fi.getInstance(i).hide(), Fi.getOrCreateInstance(e).toggle(this);\n  }), j.on(window, "load.bs.offcanvas.data-api", () => V.find(zi).forEach(t => Fi.getOrCreateInstance(t).show())), R(Fi), g(Fi);\n\n  const Ui = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]),\n        Vi = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i,\n        Ki = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i,\n        Xi = (t, e) => {\n    const i = t.nodeName.toLowerCase();\n    if (e.includes(i)) return !Ui.has(i) || Boolean(Vi.test(t.nodeValue) || Ki.test(t.nodeValue));\n    const n = e.filter(t => t instanceof RegExp);\n\n    for (let t = 0, e = n.length; t < e; t++) if (n[t].test(i)) return !0;\n\n    return !1;\n  };\n\n  function Yi(t, e, i) {\n    if (!t.length) return t;\n    if (i && "function" == typeof i) return i(t);\n    const n = new window.DOMParser().parseFromString(t, "text/html"),\n          s = [].concat(...n.body.querySelectorAll("*"));\n\n    for (let t = 0, i = s.length; t < i; t++) {\n      const i = s[t],\n            n = i.nodeName.toLowerCase();\n\n      if (!Object.keys(e).includes(n)) {\n        i.remove();\n        continue;\n      }\n\n      const o = [].concat(...i.attributes),\n            r = [].concat(e["*"] || [], e[n] || []);\n      o.forEach(t => {\n        Xi(t, r) || i.removeAttribute(t.nodeName);\n      });\n    }\n\n    return n.body.innerHTML;\n  }\n\n  const Qi = "tooltip",\n        Gi = new Set(["sanitize", "allowList", "sanitizeFn"]),\n        Zi = {\n    animation: "boolean",\n    template: "string",\n    title: "(string|element|function)",\n    trigger: "string",\n    delay: "(number|object)",\n    html: "boolean",\n    selector: "(string|boolean)",\n    placement: "(string|function)",\n    offset: "(array|string|function)",\n    container: "(string|element|boolean)",\n    fallbackPlacements: "array",\n    boundary: "(string|element)",\n    customClass: "(string|function)",\n    sanitize: "boolean",\n    sanitizeFn: "(null|function)",\n    allowList: "object",\n    popperConfig: "(null|object|function)"\n  },\n        Ji = {\n    AUTO: "auto",\n    TOP: "top",\n    RIGHT: m() ? "left" : "right",\n    BOTTOM: "bottom",\n    LEFT: m() ? "right" : "left"\n  },\n        tn = {\n    animation: !0,\n    template: \'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>\',\n    trigger: "hover focus",\n    title: "",\n    delay: 0,\n    html: !1,\n    selector: !1,\n    placement: "top",\n    offset: [0, 0],\n    container: !1,\n    fallbackPlacements: ["top", "right", "bottom", "left"],\n    boundary: "clippingParents",\n    customClass: "",\n    sanitize: !0,\n    sanitizeFn: null,\n    allowList: {\n      "*": ["class", "dir", "id", "lang", "role", /^aria-[\\w-]*$/i],\n      a: ["target", "href", "title", "rel"],\n      area: [],\n      b: [],\n      br: [],\n      col: [],\n      code: [],\n      div: [],\n      em: [],\n      hr: [],\n      h1: [],\n      h2: [],\n      h3: [],\n      h4: [],\n      h5: [],\n      h6: [],\n      i: [],\n      img: ["src", "srcset", "alt", "title", "width", "height"],\n      li: [],\n      ol: [],\n      p: [],\n      pre: [],\n      s: [],\n      small: [],\n      span: [],\n      sub: [],\n      sup: [],\n      strong: [],\n      u: [],\n      ul: []\n    },\n    popperConfig: null\n  },\n        en = {\n    HIDE: "hide.bs.tooltip",\n    HIDDEN: "hidden.bs.tooltip",\n    SHOW: "show.bs.tooltip",\n    SHOWN: "shown.bs.tooltip",\n    INSERTED: "inserted.bs.tooltip",\n    CLICK: "click.bs.tooltip",\n    FOCUSIN: "focusin.bs.tooltip",\n    FOCUSOUT: "focusout.bs.tooltip",\n    MOUSEENTER: "mouseenter.bs.tooltip",\n    MOUSELEAVE: "mouseleave.bs.tooltip"\n  },\n        nn = "fade",\n        sn = "show",\n        on = "show",\n        rn = "out",\n        an = ".tooltip-inner",\n        ln = ".modal",\n        cn = "hide.bs.modal",\n        hn = "hover",\n        dn = "focus";\n\n  class un extends B {\n    constructor(t, e) {\n      if (void 0 === Fe) throw new TypeError("Bootstrap\'s tooltips require Popper (https://popper.js.org)");\n      super(t), this._isEnabled = !0, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this._config = this._getConfig(e), this.tip = null, this._setListeners();\n    }\n\n    static get Default() {\n      return tn;\n    }\n\n    static get NAME() {\n      return Qi;\n    }\n\n    static get Event() {\n      return en;\n    }\n\n    static get DefaultType() {\n      return Zi;\n    }\n\n    enable() {\n      this._isEnabled = !0;\n    }\n\n    disable() {\n      this._isEnabled = !1;\n    }\n\n    toggleEnabled() {\n      this._isEnabled = !this._isEnabled;\n    }\n\n    toggle(t) {\n      if (this._isEnabled) if (t) {\n        const e = this._initializeOnDelegatedTarget(t);\n\n        e._activeTrigger.click = !e._activeTrigger.click, e._isWithActiveTrigger() ? e._enter(null, e) : e._leave(null, e);\n      } else {\n        if (this.getTipElement().classList.contains(sn)) return void this._leave(null, this);\n\n        this._enter(null, this);\n      }\n    }\n\n    dispose() {\n      clearTimeout(this._timeout), j.off(this._element.closest(ln), cn, this._hideModalHandler), this.tip && this.tip.remove(), this._disposePopper(), super.dispose();\n    }\n\n    show() {\n      if ("none" === this._element.style.display) throw new Error("Please use show on visible elements");\n      if (!this.isWithContent() || !this._isEnabled) return;\n      const t = j.trigger(this._element, this.constructor.Event.SHOW),\n            e = h(this._element),\n            i = null === e ? this._element.ownerDocument.documentElement.contains(this._element) : e.contains(this._element);\n      if (t.defaultPrevented || !i) return;\n      "tooltip" === this.constructor.NAME && this.tip && this.getTitle() !== this.tip.querySelector(an).innerHTML && (this._disposePopper(), this.tip.remove(), this.tip = null);\n\n      const n = this.getTipElement(),\n            s = (t => {\n        do {\n          t += Math.floor(1e6 * Math.random());\n        } while (document.getElementById(t));\n\n        return t;\n      })(this.constructor.NAME);\n\n      n.setAttribute("id", s), this._element.setAttribute("aria-describedby", s), this._config.animation && n.classList.add(nn);\n\n      const o = "function" == typeof this._config.placement ? this._config.placement.call(this, n, this._element) : this._config.placement,\n            r = this._getAttachment(o);\n\n      this._addAttachmentClass(r);\n\n      const {\n        container: a\n      } = this._config;\n      H.set(n, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || (a.append(n), j.trigger(this._element, this.constructor.Event.INSERTED)), this._popper ? this._popper.update() : this._popper = qe(this._element, n, this._getPopperConfig(r)), n.classList.add(sn);\n\n      const l = this._resolvePossibleFunction(this._config.customClass);\n\n      l && n.classList.add(...l.split(" ")), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach(t => {\n        j.on(t, "mouseover", d);\n      });\n      const c = this.tip.classList.contains(nn);\n\n      this._queueCallback(() => {\n        const t = this._hoverState;\n        this._hoverState = null, j.trigger(this._element, this.constructor.Event.SHOWN), t === rn && this._leave(null, this);\n      }, this.tip, c);\n    }\n\n    hide() {\n      if (!this._popper) return;\n      const t = this.getTipElement();\n      if (j.trigger(this._element, this.constructor.Event.HIDE).defaultPrevented) return;\n      t.classList.remove(sn), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach(t => j.off(t, "mouseover", d)), this._activeTrigger.click = !1, this._activeTrigger.focus = !1, this._activeTrigger.hover = !1;\n      const e = this.tip.classList.contains(nn);\n      this._queueCallback(() => {\n        this._isWithActiveTrigger() || (this._hoverState !== on && t.remove(), this._cleanTipClass(), this._element.removeAttribute("aria-describedby"), j.trigger(this._element, this.constructor.Event.HIDDEN), this._disposePopper());\n      }, this.tip, e), this._hoverState = "";\n    }\n\n    update() {\n      null !== this._popper && this._popper.update();\n    }\n\n    isWithContent() {\n      return Boolean(this.getTitle());\n    }\n\n    getTipElement() {\n      if (this.tip) return this.tip;\n      const t = document.createElement("div");\n      t.innerHTML = this._config.template;\n      const e = t.children[0];\n      return this.setContent(e), e.classList.remove(nn, sn), this.tip = e, this.tip;\n    }\n\n    setContent(t) {\n      this._sanitizeAndSetContent(t, this.getTitle(), an);\n    }\n\n    _sanitizeAndSetContent(t, e, i) {\n      const n = V.findOne(i, t);\n      e || !n ? this.setElementContent(n, e) : n.remove();\n    }\n\n    setElementContent(t, e) {\n      if (null !== t) return o(e) ? (e = r(e), void (this._config.html ? e.parentNode !== t && (t.innerHTML = "", t.append(e)) : t.textContent = e.textContent)) : void (this._config.html ? (this._config.sanitize && (e = Yi(e, this._config.allowList, this._config.sanitizeFn)), t.innerHTML = e) : t.textContent = e);\n    }\n\n    getTitle() {\n      const t = this._element.getAttribute("data-bs-original-title") || this._config.title;\n\n      return this._resolvePossibleFunction(t);\n    }\n\n    updateAttachment(t) {\n      return "right" === t ? "end" : "left" === t ? "start" : t;\n    }\n\n    _initializeOnDelegatedTarget(t, e) {\n      return e || this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig());\n    }\n\n    _getOffset() {\n      const {\n        offset: t\n      } = this._config;\n      return "string" == typeof t ? t.split(",").map(t => Number.parseInt(t, 10)) : "function" == typeof t ? e => t(e, this._element) : t;\n    }\n\n    _resolvePossibleFunction(t) {\n      return "function" == typeof t ? t.call(this._element) : t;\n    }\n\n    _getPopperConfig(t) {\n      const e = {\n        placement: t,\n        modifiers: [{\n          name: "flip",\n          options: {\n            fallbackPlacements: this._config.fallbackPlacements\n          }\n        }, {\n          name: "offset",\n          options: {\n            offset: this._getOffset()\n          }\n        }, {\n          name: "preventOverflow",\n          options: {\n            boundary: this._config.boundary\n          }\n        }, {\n          name: "arrow",\n          options: {\n            element: `.${this.constructor.NAME}-arrow`\n          }\n        }, {\n          name: "onChange",\n          enabled: !0,\n          phase: "afterWrite",\n          fn: t => this._handlePopperPlacementChange(t)\n        }],\n        onFirstUpdate: t => {\n          t.options.placement !== t.placement && this._handlePopperPlacementChange(t);\n        }\n      };\n      return { ...e,\n        ...("function" == typeof this._config.popperConfig ? this._config.popperConfig(e) : this._config.popperConfig)\n      };\n    }\n\n    _addAttachmentClass(t) {\n      this.getTipElement().classList.add(`${this._getBasicClassPrefix()}-${this.updateAttachment(t)}`);\n    }\n\n    _getAttachment(t) {\n      return Ji[t.toUpperCase()];\n    }\n\n    _setListeners() {\n      this._config.trigger.split(" ").forEach(t => {\n        if ("click" === t) j.on(this._element, this.constructor.Event.CLICK, this._config.selector, t => this.toggle(t));else if ("manual" !== t) {\n          const e = t === hn ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN,\n                i = t === hn ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;\n          j.on(this._element, e, this._config.selector, t => this._enter(t)), j.on(this._element, i, this._config.selector, t => this._leave(t));\n        }\n      }), this._hideModalHandler = () => {\n        this._element && this.hide();\n      }, j.on(this._element.closest(ln), cn, this._hideModalHandler), this._config.selector ? this._config = { ...this._config,\n        trigger: "manual",\n        selector: ""\n      } : this._fixTitle();\n    }\n\n    _fixTitle() {\n      const t = this._element.getAttribute("title"),\n            e = typeof this._element.getAttribute("data-bs-original-title");\n\n      (t || "string" !== e) && (this._element.setAttribute("data-bs-original-title", t || ""), !t || this._element.getAttribute("aria-label") || this._element.textContent || this._element.setAttribute("aria-label", t), this._element.setAttribute("title", ""));\n    }\n\n    _enter(t, e) {\n      e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger["focusin" === t.type ? dn : hn] = !0), e.getTipElement().classList.contains(sn) || e._hoverState === on ? e._hoverState = on : (clearTimeout(e._timeout), e._hoverState = on, e._config.delay && e._config.delay.show ? e._timeout = setTimeout(() => {\n        e._hoverState === on && e.show();\n      }, e._config.delay.show) : e.show());\n    }\n\n    _leave(t, e) {\n      e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger["focusout" === t.type ? dn : hn] = e._element.contains(t.relatedTarget)), e._isWithActiveTrigger() || (clearTimeout(e._timeout), e._hoverState = rn, e._config.delay && e._config.delay.hide ? e._timeout = setTimeout(() => {\n        e._hoverState === rn && e.hide();\n      }, e._config.delay.hide) : e.hide());\n    }\n\n    _isWithActiveTrigger() {\n      for (const t in this._activeTrigger) if (this._activeTrigger[t]) return !0;\n\n      return !1;\n    }\n\n    _getConfig(t) {\n      const e = U.getDataAttributes(this._element);\n      return Object.keys(e).forEach(t => {\n        Gi.has(t) && delete e[t];\n      }), (t = { ...this.constructor.Default,\n        ...e,\n        ...("object" == typeof t && t ? t : {})\n      }).container = !1 === t.container ? document.body : r(t.container), "number" == typeof t.delay && (t.delay = {\n        show: t.delay,\n        hide: t.delay\n      }), "number" == typeof t.title && (t.title = t.title.toString()), "number" == typeof t.content && (t.content = t.content.toString()), a(Qi, t, this.constructor.DefaultType), t.sanitize && (t.template = Yi(t.template, t.allowList, t.sanitizeFn)), t;\n    }\n\n    _getDelegateConfig() {\n      const t = {};\n\n      for (const e in this._config) this.constructor.Default[e] !== this._config[e] && (t[e] = this._config[e]);\n\n      return t;\n    }\n\n    _cleanTipClass() {\n      const t = this.getTipElement(),\n            e = new RegExp(`(^|\\\\s)${this._getBasicClassPrefix()}\\\\S+`, "g"),\n            i = t.getAttribute("class").match(e);\n      null !== i && i.length > 0 && i.map(t => t.trim()).forEach(e => t.classList.remove(e));\n    }\n\n    _getBasicClassPrefix() {\n      return "bs-tooltip";\n    }\n\n    _handlePopperPlacementChange(t) {\n      const {\n        state: e\n      } = t;\n      e && (this.tip = e.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(e.placement)));\n    }\n\n    _disposePopper() {\n      this._popper && (this._popper.destroy(), this._popper = null);\n    }\n\n    static jQueryInterface(t) {\n      return this.each(function () {\n        const e = un.getOrCreateInstance(this, t);\n\n        if ("string" == typeof t) {\n          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);\n          e[t]();\n        }\n      });\n    }\n\n  }\n\n  g(un);\n  const fn = { ...un.Default,\n    placement: "right",\n    offset: [0, 8],\n    trigger: "click",\n    content: "",\n    template: \'<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>\'\n  },\n        pn = { ...un.DefaultType,\n    content: "(string|element|function)"\n  },\n        mn = {\n    HIDE: "hide.bs.popover",\n    HIDDEN: "hidden.bs.popover",\n    SHOW: "show.bs.popover",\n    SHOWN: "shown.bs.popover",\n    INSERTED: "inserted.bs.popover",\n    CLICK: "click.bs.popover",\n    FOCUSIN: "focusin.bs.popover",\n    FOCUSOUT: "focusout.bs.popover",\n    MOUSEENTER: "mouseenter.bs.popover",\n    MOUSELEAVE: "mouseleave.bs.popover"\n  };\n\n  class gn extends un {\n    static get Default() {\n      return fn;\n    }\n\n    static get NAME() {\n      return "popover";\n    }\n\n    static get Event() {\n      return mn;\n    }\n\n    static get DefaultType() {\n      return pn;\n    }\n\n    isWithContent() {\n      return this.getTitle() || this._getContent();\n    }\n\n    setContent(t) {\n      this._sanitizeAndSetContent(t, this.getTitle(), ".popover-header"), this._sanitizeAndSetContent(t, this._getContent(), ".popover-body");\n    }\n\n    _getContent() {\n      return this._resolvePossibleFunction(this._config.content);\n    }\n\n    _getBasicClassPrefix() {\n      return "bs-popover";\n    }\n\n    static jQueryInterface(t) {\n      return this.each(function () {\n        const e = gn.getOrCreateInstance(this, t);\n\n        if ("string" == typeof t) {\n          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);\n          e[t]();\n        }\n      });\n    }\n\n  }\n\n  g(gn);\n  const _n = "scrollspy",\n        bn = {\n    offset: 10,\n    method: "auto",\n    target: ""\n  },\n        vn = {\n    offset: "number",\n    method: "string",\n    target: "(string|element)"\n  },\n        yn = "active",\n        wn = ".nav-link, .list-group-item, .dropdown-item",\n        En = "position";\n\n  class An extends B {\n    constructor(t, e) {\n      super(t), this._scrollElement = "BODY" === this._element.tagName ? window : this._element, this._config = this._getConfig(e), this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, j.on(this._scrollElement, "scroll.bs.scrollspy", () => this._process()), this.refresh(), this._process();\n    }\n\n    static get Default() {\n      return bn;\n    }\n\n    static get NAME() {\n      return _n;\n    }\n\n    refresh() {\n      const t = this._scrollElement === this._scrollElement.window ? "offset" : En,\n            e = "auto" === this._config.method ? t : this._config.method,\n            n = e === En ? this._getScrollTop() : 0;\n      this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), V.find(wn, this._config.target).map(t => {\n        const s = i(t),\n              o = s ? V.findOne(s) : null;\n\n        if (o) {\n          const t = o.getBoundingClientRect();\n          if (t.width || t.height) return [U[e](o).top + n, s];\n        }\n\n        return null;\n      }).filter(t => t).sort((t, e) => t[0] - e[0]).forEach(t => {\n        this._offsets.push(t[0]), this._targets.push(t[1]);\n      });\n    }\n\n    dispose() {\n      j.off(this._scrollElement, ".bs.scrollspy"), super.dispose();\n    }\n\n    _getConfig(t) {\n      return (t = { ...bn,\n        ...U.getDataAttributes(this._element),\n        ...("object" == typeof t && t ? t : {})\n      }).target = r(t.target) || document.documentElement, a(_n, t, vn), t;\n    }\n\n    _getScrollTop() {\n      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;\n    }\n\n    _getScrollHeight() {\n      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n    }\n\n    _getOffsetHeight() {\n      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;\n    }\n\n    _process() {\n      const t = this._getScrollTop() + this._config.offset,\n            e = this._getScrollHeight(),\n            i = this._config.offset + e - this._getOffsetHeight();\n\n      if (this._scrollHeight !== e && this.refresh(), t >= i) {\n        const t = this._targets[this._targets.length - 1];\n        this._activeTarget !== t && this._activate(t);\n      } else {\n        if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) return this._activeTarget = null, void this._clear();\n\n        for (let e = this._offsets.length; e--;) this._activeTarget !== this._targets[e] && t >= this._offsets[e] && (void 0 === this._offsets[e + 1] || t < this._offsets[e + 1]) && this._activate(this._targets[e]);\n      }\n    }\n\n    _activate(t) {\n      this._activeTarget = t, this._clear();\n      const e = wn.split(",").map(e => `${e}[data-bs-target="${t}"],${e}[href="${t}"]`),\n            i = V.findOne(e.join(","), this._config.target);\n      i.classList.add(yn), i.classList.contains("dropdown-item") ? V.findOne(".dropdown-toggle", i.closest(".dropdown")).classList.add(yn) : V.parents(i, ".nav, .list-group").forEach(t => {\n        V.prev(t, ".nav-link, .list-group-item").forEach(t => t.classList.add(yn)), V.prev(t, ".nav-item").forEach(t => {\n          V.children(t, ".nav-link").forEach(t => t.classList.add(yn));\n        });\n      }), j.trigger(this._scrollElement, "activate.bs.scrollspy", {\n        relatedTarget: t\n      });\n    }\n\n    _clear() {\n      V.find(wn, this._config.target).filter(t => t.classList.contains(yn)).forEach(t => t.classList.remove(yn));\n    }\n\n    static jQueryInterface(t) {\n      return this.each(function () {\n        const e = An.getOrCreateInstance(this, t);\n\n        if ("string" == typeof t) {\n          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);\n          e[t]();\n        }\n      });\n    }\n\n  }\n\n  j.on(window, "load.bs.scrollspy.data-api", () => {\n    V.find(\'[data-bs-spy="scroll"]\').forEach(t => new An(t));\n  }), g(An);\n  const Tn = "active",\n        On = "fade",\n        Cn = "show",\n        kn = ".active",\n        Ln = ":scope > li > .active";\n\n  class xn extends B {\n    static get NAME() {\n      return "tab";\n    }\n\n    show() {\n      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains(Tn)) return;\n      let t;\n\n      const e = n(this._element),\n            i = this._element.closest(".nav, .list-group");\n\n      if (i) {\n        const e = "UL" === i.nodeName || "OL" === i.nodeName ? Ln : kn;\n        t = V.find(e, i), t = t[t.length - 1];\n      }\n\n      const s = t ? j.trigger(t, "hide.bs.tab", {\n        relatedTarget: this._element\n      }) : null;\n      if (j.trigger(this._element, "show.bs.tab", {\n        relatedTarget: t\n      }).defaultPrevented || null !== s && s.defaultPrevented) return;\n\n      this._activate(this._element, i);\n\n      const o = () => {\n        j.trigger(t, "hidden.bs.tab", {\n          relatedTarget: this._element\n        }), j.trigger(this._element, "shown.bs.tab", {\n          relatedTarget: t\n        });\n      };\n\n      e ? this._activate(e, e.parentNode, o) : o();\n    }\n\n    _activate(t, e, i) {\n      const n = (!e || "UL" !== e.nodeName && "OL" !== e.nodeName ? V.children(e, kn) : V.find(Ln, e))[0],\n            s = i && n && n.classList.contains(On),\n            o = () => this._transitionComplete(t, n, i);\n\n      n && s ? (n.classList.remove(Cn), this._queueCallback(o, t, !0)) : o();\n    }\n\n    _transitionComplete(t, e, i) {\n      if (e) {\n        e.classList.remove(Tn);\n        const t = V.findOne(":scope > .dropdown-menu .active", e.parentNode);\n        t && t.classList.remove(Tn), "tab" === e.getAttribute("role") && e.setAttribute("aria-selected", !1);\n      }\n\n      t.classList.add(Tn), "tab" === t.getAttribute("role") && t.setAttribute("aria-selected", !0), u(t), t.classList.contains(On) && t.classList.add(Cn);\n      let n = t.parentNode;\n\n      if (n && "LI" === n.nodeName && (n = n.parentNode), n && n.classList.contains("dropdown-menu")) {\n        const e = t.closest(".dropdown");\n        e && V.find(".dropdown-toggle", e).forEach(t => t.classList.add(Tn)), t.setAttribute("aria-expanded", !0);\n      }\n\n      i && i();\n    }\n\n    static jQueryInterface(t) {\n      return this.each(function () {\n        const e = xn.getOrCreateInstance(this);\n\n        if ("string" == typeof t) {\n          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);\n          e[t]();\n        }\n      });\n    }\n\n  }\n\n  j.on(document, "click.bs.tab.data-api", \'[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]\', function (t) {\n    ["A", "AREA"].includes(this.tagName) && t.preventDefault(), c(this) || xn.getOrCreateInstance(this).show();\n  }), g(xn);\n  const Dn = "toast",\n        Sn = "hide",\n        Nn = "show",\n        In = "showing",\n        Pn = {\n    animation: "boolean",\n    autohide: "boolean",\n    delay: "number"\n  },\n        jn = {\n    animation: !0,\n    autohide: !0,\n    delay: 5e3\n  };\n\n  class Mn extends B {\n    constructor(t, e) {\n      super(t), this._config = this._getConfig(e), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners();\n    }\n\n    static get DefaultType() {\n      return Pn;\n    }\n\n    static get Default() {\n      return jn;\n    }\n\n    static get NAME() {\n      return Dn;\n    }\n\n    show() {\n      j.trigger(this._element, "show.bs.toast").defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add("fade"), this._element.classList.remove(Sn), u(this._element), this._element.classList.add(Nn), this._element.classList.add(In), this._queueCallback(() => {\n        this._element.classList.remove(In), j.trigger(this._element, "shown.bs.toast"), this._maybeScheduleHide();\n      }, this._element, this._config.animation));\n    }\n\n    hide() {\n      this._element.classList.contains(Nn) && (j.trigger(this._element, "hide.bs.toast").defaultPrevented || (this._element.classList.add(In), this._queueCallback(() => {\n        this._element.classList.add(Sn), this._element.classList.remove(In), this._element.classList.remove(Nn), j.trigger(this._element, "hidden.bs.toast");\n      }, this._element, this._config.animation)));\n    }\n\n    dispose() {\n      this._clearTimeout(), this._element.classList.contains(Nn) && this._element.classList.remove(Nn), super.dispose();\n    }\n\n    _getConfig(t) {\n      return t = { ...jn,\n        ...U.getDataAttributes(this._element),\n        ...("object" == typeof t && t ? t : {})\n      }, a(Dn, t, this.constructor.DefaultType), t;\n    }\n\n    _maybeScheduleHide() {\n      this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {\n        this.hide();\n      }, this._config.delay)));\n    }\n\n    _onInteraction(t, e) {\n      switch (t.type) {\n        case "mouseover":\n        case "mouseout":\n          this._hasMouseInteraction = e;\n          break;\n\n        case "focusin":\n        case "focusout":\n          this._hasKeyboardInteraction = e;\n      }\n\n      if (e) return void this._clearTimeout();\n      const i = t.relatedTarget;\n      this._element === i || this._element.contains(i) || this._maybeScheduleHide();\n    }\n\n    _setListeners() {\n      j.on(this._element, "mouseover.bs.toast", t => this._onInteraction(t, !0)), j.on(this._element, "mouseout.bs.toast", t => this._onInteraction(t, !1)), j.on(this._element, "focusin.bs.toast", t => this._onInteraction(t, !0)), j.on(this._element, "focusout.bs.toast", t => this._onInteraction(t, !1));\n    }\n\n    _clearTimeout() {\n      clearTimeout(this._timeout), this._timeout = null;\n    }\n\n    static jQueryInterface(t) {\n      return this.each(function () {\n        const e = Mn.getOrCreateInstance(this, t);\n\n        if ("string" == typeof t) {\n          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);\n          e[t](this);\n        }\n      });\n    }\n\n  }\n\n  return R(Mn), g(Mn), {\n    Alert: W,\n    Button: z,\n    Carousel: st,\n    Collapse: pt,\n    Dropdown: hi,\n    Modal: Hi,\n    Offcanvas: Fi,\n    Popover: gn,\n    ScrollSpy: An,\n    Tab: xn,\n    Toast: Mn,\n    Tooltip: un\n  };\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanVzZG9jcy1ib2lsZXJwbGF0ZS8uL25vZGVfbW9kdWxlcy9ib290c3RyYXAvZGlzdC9qcy9ib290c3RyYXAuYnVuZGxlLm1pbi5qcz9kYjk1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICAqIEJvb3RzdHJhcCB2NS4xLjMgKGh0dHBzOi8vZ2V0Ym9vdHN0cmFwLmNvbS8pXG4gICogQ29weXJpZ2h0IDIwMTEtMjAyMSBUaGUgQm9vdHN0cmFwIEF1dGhvcnMgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ncmFwaHMvY29udHJpYnV0b3JzKVxuICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAqL1xuIWZ1bmN0aW9uICh0LCBlKSB7XG4gIFwib2JqZWN0XCIgPT0gdHlwZW9mIGV4cG9ydHMgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgbW9kdWxlID8gbW9kdWxlLmV4cG9ydHMgPSBlKCkgOiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGUpIDogKHQgPSBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcyA6IHQgfHwgc2VsZikuYm9vdHN0cmFwID0gZSgpO1xufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGNvbnN0IHQgPSBcInRyYW5zaXRpb25lbmRcIixcbiAgICAgICAgZSA9IHQgPT4ge1xuICAgIGxldCBlID0gdC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWJzLXRhcmdldFwiKTtcblxuICAgIGlmICghZSB8fCBcIiNcIiA9PT0gZSkge1xuICAgICAgbGV0IGkgPSB0LmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG4gICAgICBpZiAoIWkgfHwgIWkuaW5jbHVkZXMoXCIjXCIpICYmICFpLnN0YXJ0c1dpdGgoXCIuXCIpKSByZXR1cm4gbnVsbDtcbiAgICAgIGkuaW5jbHVkZXMoXCIjXCIpICYmICFpLnN0YXJ0c1dpdGgoXCIjXCIpICYmIChpID0gYCMke2kuc3BsaXQoXCIjXCIpWzFdfWApLCBlID0gaSAmJiBcIiNcIiAhPT0gaSA/IGkudHJpbSgpIDogbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZTtcbiAgfSxcbiAgICAgICAgaSA9IHQgPT4ge1xuICAgIGNvbnN0IGkgPSBlKHQpO1xuICAgIHJldHVybiBpICYmIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoaSkgPyBpIDogbnVsbDtcbiAgfSxcbiAgICAgICAgbiA9IHQgPT4ge1xuICAgIGNvbnN0IGkgPSBlKHQpO1xuICAgIHJldHVybiBpID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihpKSA6IG51bGw7XG4gIH0sXG4gICAgICAgIHMgPSBlID0+IHtcbiAgICBlLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KHQpKTtcbiAgfSxcbiAgICAgICAgbyA9IHQgPT4gISghdCB8fCBcIm9iamVjdFwiICE9IHR5cGVvZiB0KSAmJiAodm9pZCAwICE9PSB0LmpxdWVyeSAmJiAodCA9IHRbMF0pLCB2b2lkIDAgIT09IHQubm9kZVR5cGUpLFxuICAgICAgICByID0gdCA9PiBvKHQpID8gdC5qcXVlcnkgPyB0WzBdIDogdCA6IFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgJiYgdC5sZW5ndGggPiAwID8gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0KSA6IG51bGwsXG4gICAgICAgIGEgPSAodCwgZSwgaSkgPT4ge1xuICAgIE9iamVjdC5rZXlzKGkpLmZvckVhY2gobiA9PiB7XG4gICAgICBjb25zdCBzID0gaVtuXSxcbiAgICAgICAgICAgIHIgPSBlW25dLFxuICAgICAgICAgICAgYSA9IHIgJiYgbyhyKSA/IFwiZWxlbWVudFwiIDogbnVsbCA9PSAobCA9IHIpID8gYCR7bH1gIDoge30udG9TdHJpbmcuY2FsbChsKS5tYXRjaCgvXFxzKFthLXpdKykvaSlbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBsO1xuICAgICAgaWYgKCFuZXcgUmVnRXhwKHMpLnRlc3QoYSkpIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7dC50b1VwcGVyQ2FzZSgpfTogT3B0aW9uIFwiJHtufVwiIHByb3ZpZGVkIHR5cGUgXCIke2F9XCIgYnV0IGV4cGVjdGVkIHR5cGUgXCIke3N9XCIuYCk7XG4gICAgfSk7XG4gIH0sXG4gICAgICAgIGwgPSB0ID0+ICEoIW8odCkgfHwgMCA9PT0gdC5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCkgJiYgXCJ2aXNpYmxlXCIgPT09IGdldENvbXB1dGVkU3R5bGUodCkuZ2V0UHJvcGVydHlWYWx1ZShcInZpc2liaWxpdHlcIiksXG4gICAgICAgIGMgPSB0ID0+ICF0IHx8IHQubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFIHx8ICEhdC5jbGFzc0xpc3QuY29udGFpbnMoXCJkaXNhYmxlZFwiKSB8fCAodm9pZCAwICE9PSB0LmRpc2FibGVkID8gdC5kaXNhYmxlZCA6IHQuaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIikgJiYgXCJmYWxzZVwiICE9PSB0LmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpKSxcbiAgICAgICAgaCA9IHQgPT4ge1xuICAgIGlmICghZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmF0dGFjaFNoYWRvdykgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiB0LmdldFJvb3ROb2RlKSB7XG4gICAgICBjb25zdCBlID0gdC5nZXRSb290Tm9kZSgpO1xuICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBTaGFkb3dSb290ID8gZSA6IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQgaW5zdGFuY2VvZiBTaGFkb3dSb290ID8gdCA6IHQucGFyZW50Tm9kZSA/IGgodC5wYXJlbnROb2RlKSA6IG51bGw7XG4gIH0sXG4gICAgICAgIGQgPSAoKSA9PiB7fSxcbiAgICAgICAgdSA9IHQgPT4ge1xuICAgIHQub2Zmc2V0SGVpZ2h0O1xuICB9LFxuICAgICAgICBmID0gKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGpRdWVyeTogdFxuICAgIH0gPSB3aW5kb3c7XG4gICAgcmV0dXJuIHQgJiYgIWRvY3VtZW50LmJvZHkuaGFzQXR0cmlidXRlKFwiZGF0YS1icy1uby1qcXVlcnlcIikgPyB0IDogbnVsbDtcbiAgfSxcbiAgICAgICAgcCA9IFtdLFxuICAgICAgICBtID0gKCkgPT4gXCJydGxcIiA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRpcixcbiAgICAgICAgZyA9IHQgPT4ge1xuICAgIHZhciBlO1xuICAgIGUgPSAoKSA9PiB7XG4gICAgICBjb25zdCBlID0gZigpO1xuXG4gICAgICBpZiAoZSkge1xuICAgICAgICBjb25zdCBpID0gdC5OQU1FLFxuICAgICAgICAgICAgICBuID0gZS5mbltpXTtcbiAgICAgICAgZS5mbltpXSA9IHQualF1ZXJ5SW50ZXJmYWNlLCBlLmZuW2ldLkNvbnN0cnVjdG9yID0gdCwgZS5mbltpXS5ub0NvbmZsaWN0ID0gKCkgPT4gKGUuZm5baV0gPSBuLCB0LmpRdWVyeUludGVyZmFjZSk7XG4gICAgICB9XG4gICAgfSwgXCJsb2FkaW5nXCIgPT09IGRvY3VtZW50LnJlYWR5U3RhdGUgPyAocC5sZW5ndGggfHwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4ge1xuICAgICAgcC5mb3JFYWNoKHQgPT4gdCgpKTtcbiAgICB9KSwgcC5wdXNoKGUpKSA6IGUoKTtcbiAgfSxcbiAgICAgICAgXyA9IHQgPT4ge1xuICAgIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdCAmJiB0KCk7XG4gIH0sXG4gICAgICAgIGIgPSAoZSwgaSwgbiA9ICEwKSA9PiB7XG4gICAgaWYgKCFuKSByZXR1cm4gdm9pZCBfKGUpO1xuXG4gICAgY29uc3QgbyA9ICh0ID0+IHtcbiAgICAgIGlmICghdCkgcmV0dXJuIDA7XG4gICAgICBsZXQge1xuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGUsXG4gICAgICAgIHRyYW5zaXRpb25EZWxheTogaVxuICAgICAgfSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHQpO1xuICAgICAgY29uc3QgbiA9IE51bWJlci5wYXJzZUZsb2F0KGUpLFxuICAgICAgICAgICAgcyA9IE51bWJlci5wYXJzZUZsb2F0KGkpO1xuICAgICAgcmV0dXJuIG4gfHwgcyA/IChlID0gZS5zcGxpdChcIixcIilbMF0sIGkgPSBpLnNwbGl0KFwiLFwiKVswXSwgMWUzICogKE51bWJlci5wYXJzZUZsb2F0KGUpICsgTnVtYmVyLnBhcnNlRmxvYXQoaSkpKSA6IDA7XG4gICAgfSkoaSkgKyA1O1xuXG4gICAgbGV0IHIgPSAhMTtcblxuICAgIGNvbnN0IGEgPSAoe1xuICAgICAgdGFyZ2V0OiBuXG4gICAgfSkgPT4ge1xuICAgICAgbiA9PT0gaSAmJiAociA9ICEwLCBpLnJlbW92ZUV2ZW50TGlzdGVuZXIodCwgYSksIF8oZSkpO1xuICAgIH07XG5cbiAgICBpLmFkZEV2ZW50TGlzdGVuZXIodCwgYSksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgciB8fCBzKGkpO1xuICAgIH0sIG8pO1xuICB9LFxuICAgICAgICB2ID0gKHQsIGUsIGksIG4pID0+IHtcbiAgICBsZXQgcyA9IHQuaW5kZXhPZihlKTtcbiAgICBpZiAoLTEgPT09IHMpIHJldHVybiB0WyFpICYmIG4gPyB0Lmxlbmd0aCAtIDEgOiAwXTtcbiAgICBjb25zdCBvID0gdC5sZW5ndGg7XG4gICAgcmV0dXJuIHMgKz0gaSA/IDEgOiAtMSwgbiAmJiAocyA9IChzICsgbykgJSBvKSwgdFtNYXRoLm1heCgwLCBNYXRoLm1pbihzLCBvIC0gMSkpXTtcbiAgfSxcbiAgICAgICAgeSA9IC9bXi5dKig/PVxcLi4qKVxcLnwuKi8sXG4gICAgICAgIHcgPSAvXFwuLiovLFxuICAgICAgICBFID0gLzo6XFxkKyQvLFxuICAgICAgICBBID0ge307XG5cbiAgbGV0IFQgPSAxO1xuICBjb25zdCBPID0ge1xuICAgIG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG4gICAgbW91c2VsZWF2ZTogXCJtb3VzZW91dFwiXG4gIH0sXG4gICAgICAgIEMgPSAvXihtb3VzZWVudGVyfG1vdXNlbGVhdmUpL2ksXG4gICAgICAgIGsgPSBuZXcgU2V0KFtcImNsaWNrXCIsIFwiZGJsY2xpY2tcIiwgXCJtb3VzZXVwXCIsIFwibW91c2Vkb3duXCIsIFwiY29udGV4dG1lbnVcIiwgXCJtb3VzZXdoZWVsXCIsIFwiRE9NTW91c2VTY3JvbGxcIiwgXCJtb3VzZW92ZXJcIiwgXCJtb3VzZW91dFwiLCBcIm1vdXNlbW92ZVwiLCBcInNlbGVjdHN0YXJ0XCIsIFwic2VsZWN0ZW5kXCIsIFwia2V5ZG93blwiLCBcImtleXByZXNzXCIsIFwia2V5dXBcIiwgXCJvcmllbnRhdGlvbmNoYW5nZVwiLCBcInRvdWNoc3RhcnRcIiwgXCJ0b3VjaG1vdmVcIiwgXCJ0b3VjaGVuZFwiLCBcInRvdWNoY2FuY2VsXCIsIFwicG9pbnRlcmRvd25cIiwgXCJwb2ludGVybW92ZVwiLCBcInBvaW50ZXJ1cFwiLCBcInBvaW50ZXJsZWF2ZVwiLCBcInBvaW50ZXJjYW5jZWxcIiwgXCJnZXN0dXJlc3RhcnRcIiwgXCJnZXN0dXJlY2hhbmdlXCIsIFwiZ2VzdHVyZWVuZFwiLCBcImZvY3VzXCIsIFwiYmx1clwiLCBcImNoYW5nZVwiLCBcInJlc2V0XCIsIFwic2VsZWN0XCIsIFwic3VibWl0XCIsIFwiZm9jdXNpblwiLCBcImZvY3Vzb3V0XCIsIFwibG9hZFwiLCBcInVubG9hZFwiLCBcImJlZm9yZXVubG9hZFwiLCBcInJlc2l6ZVwiLCBcIm1vdmVcIiwgXCJET01Db250ZW50TG9hZGVkXCIsIFwicmVhZHlzdGF0ZWNoYW5nZVwiLCBcImVycm9yXCIsIFwiYWJvcnRcIiwgXCJzY3JvbGxcIl0pO1xuXG4gIGZ1bmN0aW9uIEwodCwgZSkge1xuICAgIHJldHVybiBlICYmIGAke2V9Ojoke1QrK31gIHx8IHQudWlkRXZlbnQgfHwgVCsrO1xuICB9XG5cbiAgZnVuY3Rpb24geCh0KSB7XG4gICAgY29uc3QgZSA9IEwodCk7XG4gICAgcmV0dXJuIHQudWlkRXZlbnQgPSBlLCBBW2VdID0gQVtlXSB8fCB7fSwgQVtlXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEQodCwgZSwgaSA9IG51bGwpIHtcbiAgICBjb25zdCBuID0gT2JqZWN0LmtleXModCk7XG5cbiAgICBmb3IgKGxldCBzID0gMCwgbyA9IG4ubGVuZ3RoOyBzIDwgbzsgcysrKSB7XG4gICAgICBjb25zdCBvID0gdFtuW3NdXTtcbiAgICAgIGlmIChvLm9yaWdpbmFsSGFuZGxlciA9PT0gZSAmJiBvLmRlbGVnYXRpb25TZWxlY3RvciA9PT0gaSkgcmV0dXJuIG87XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBTKHQsIGUsIGkpIHtcbiAgICBjb25zdCBuID0gXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSxcbiAgICAgICAgICBzID0gbiA/IGkgOiBlO1xuICAgIGxldCBvID0gUCh0KTtcbiAgICByZXR1cm4gay5oYXMobykgfHwgKG8gPSB0KSwgW24sIHMsIG9dO1xuICB9XG5cbiAgZnVuY3Rpb24gTih0LCBlLCBpLCBuLCBzKSB7XG4gICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIGUgfHwgIXQpIHJldHVybjtcblxuICAgIGlmIChpIHx8IChpID0gbiwgbiA9IG51bGwpLCBDLnRlc3QoZSkpIHtcbiAgICAgIGNvbnN0IHQgPSB0ID0+IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghZS5yZWxhdGVkVGFyZ2V0IHx8IGUucmVsYXRlZFRhcmdldCAhPT0gZS5kZWxlZ2F0ZVRhcmdldCAmJiAhZS5kZWxlZ2F0ZVRhcmdldC5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpKSByZXR1cm4gdC5jYWxsKHRoaXMsIGUpO1xuICAgICAgfTtcblxuICAgICAgbiA/IG4gPSB0KG4pIDogaSA9IHQoaSk7XG4gICAgfVxuXG4gICAgY29uc3QgW28sIHIsIGFdID0gUyhlLCBpLCBuKSxcbiAgICAgICAgICBsID0geCh0KSxcbiAgICAgICAgICBjID0gbFthXSB8fCAobFthXSA9IHt9KSxcbiAgICAgICAgICBoID0gRChjLCByLCBvID8gaSA6IG51bGwpO1xuICAgIGlmIChoKSByZXR1cm4gdm9pZCAoaC5vbmVPZmYgPSBoLm9uZU9mZiAmJiBzKTtcbiAgICBjb25zdCBkID0gTChyLCBlLnJlcGxhY2UoeSwgXCJcIikpLFxuICAgICAgICAgIHUgPSBvID8gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBuKHMpIHtcbiAgICAgICAgY29uc3QgbyA9IHQucXVlcnlTZWxlY3RvckFsbChlKTtcblxuICAgICAgICBmb3IgKGxldCB7XG4gICAgICAgICAgdGFyZ2V0OiByXG4gICAgICAgIH0gPSBzOyByICYmIHIgIT09IHRoaXM7IHIgPSByLnBhcmVudE5vZGUpIGZvciAobGV0IGEgPSBvLmxlbmd0aDsgYS0tOykgaWYgKG9bYV0gPT09IHIpIHJldHVybiBzLmRlbGVnYXRlVGFyZ2V0ID0gciwgbi5vbmVPZmYgJiYgai5vZmYodCwgcy50eXBlLCBlLCBpKSwgaS5hcHBseShyLCBbc10pO1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICB9KHQsIGksIG4pIDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBpKG4pIHtcbiAgICAgICAgcmV0dXJuIG4uZGVsZWdhdGVUYXJnZXQgPSB0LCBpLm9uZU9mZiAmJiBqLm9mZih0LCBuLnR5cGUsIGUpLCBlLmFwcGx5KHQsIFtuXSk7XG4gICAgICB9O1xuICAgIH0odCwgaSk7XG4gICAgdS5kZWxlZ2F0aW9uU2VsZWN0b3IgPSBvID8gaSA6IG51bGwsIHUub3JpZ2luYWxIYW5kbGVyID0gciwgdS5vbmVPZmYgPSBzLCB1LnVpZEV2ZW50ID0gZCwgY1tkXSA9IHUsIHQuYWRkRXZlbnRMaXN0ZW5lcihhLCB1LCBvKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEkodCwgZSwgaSwgbiwgcykge1xuICAgIGNvbnN0IG8gPSBEKGVbaV0sIG4sIHMpO1xuICAgIG8gJiYgKHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihpLCBvLCBCb29sZWFuKHMpKSwgZGVsZXRlIGVbaV1bby51aWRFdmVudF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gUCh0KSB7XG4gICAgcmV0dXJuIHQgPSB0LnJlcGxhY2UodywgXCJcIiksIE9bdF0gfHwgdDtcbiAgfVxuXG4gIGNvbnN0IGogPSB7XG4gICAgb24odCwgZSwgaSwgbikge1xuICAgICAgTih0LCBlLCBpLCBuLCAhMSk7XG4gICAgfSxcblxuICAgIG9uZSh0LCBlLCBpLCBuKSB7XG4gICAgICBOKHQsIGUsIGksIG4sICEwKTtcbiAgICB9LFxuXG4gICAgb2ZmKHQsIGUsIGksIG4pIHtcbiAgICAgIGlmIChcInN0cmluZ1wiICE9IHR5cGVvZiBlIHx8ICF0KSByZXR1cm47XG4gICAgICBjb25zdCBbcywgbywgcl0gPSBTKGUsIGksIG4pLFxuICAgICAgICAgICAgYSA9IHIgIT09IGUsXG4gICAgICAgICAgICBsID0geCh0KSxcbiAgICAgICAgICAgIGMgPSBlLnN0YXJ0c1dpdGgoXCIuXCIpO1xuXG4gICAgICBpZiAodm9pZCAwICE9PSBvKSB7XG4gICAgICAgIGlmICghbCB8fCAhbFtyXSkgcmV0dXJuO1xuICAgICAgICByZXR1cm4gdm9pZCBJKHQsIGwsIHIsIG8sIHMgPyBpIDogbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIGMgJiYgT2JqZWN0LmtleXMobCkuZm9yRWFjaChpID0+IHtcbiAgICAgICAgIWZ1bmN0aW9uICh0LCBlLCBpLCBuKSB7XG4gICAgICAgICAgY29uc3QgcyA9IGVbaV0gfHwge307XG4gICAgICAgICAgT2JqZWN0LmtleXMocykuZm9yRWFjaChvID0+IHtcbiAgICAgICAgICAgIGlmIChvLmluY2x1ZGVzKG4pKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG4gPSBzW29dO1xuICAgICAgICAgICAgICBJKHQsIGUsIGksIG4ub3JpZ2luYWxIYW5kbGVyLCBuLmRlbGVnYXRpb25TZWxlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0odCwgbCwgaSwgZS5zbGljZSgxKSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGggPSBsW3JdIHx8IHt9O1xuICAgICAgT2JqZWN0LmtleXMoaCkuZm9yRWFjaChpID0+IHtcbiAgICAgICAgY29uc3QgbiA9IGkucmVwbGFjZShFLCBcIlwiKTtcblxuICAgICAgICBpZiAoIWEgfHwgZS5pbmNsdWRlcyhuKSkge1xuICAgICAgICAgIGNvbnN0IGUgPSBoW2ldO1xuICAgICAgICAgIEkodCwgbCwgciwgZS5vcmlnaW5hbEhhbmRsZXIsIGUuZGVsZWdhdGlvblNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHRyaWdnZXIodCwgZSwgaSkge1xuICAgICAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIGUgfHwgIXQpIHJldHVybiBudWxsO1xuICAgICAgY29uc3QgbiA9IGYoKSxcbiAgICAgICAgICAgIHMgPSBQKGUpLFxuICAgICAgICAgICAgbyA9IGUgIT09IHMsXG4gICAgICAgICAgICByID0gay5oYXMocyk7XG4gICAgICBsZXQgYSxcbiAgICAgICAgICBsID0gITAsXG4gICAgICAgICAgYyA9ICEwLFxuICAgICAgICAgIGggPSAhMSxcbiAgICAgICAgICBkID0gbnVsbDtcbiAgICAgIHJldHVybiBvICYmIG4gJiYgKGEgPSBuLkV2ZW50KGUsIGkpLCBuKHQpLnRyaWdnZXIoYSksIGwgPSAhYS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpLCBjID0gIWEuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSwgaCA9IGEuaXNEZWZhdWx0UHJldmVudGVkKCkpLCByID8gKGQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkhUTUxFdmVudHNcIiksIGQuaW5pdEV2ZW50KHMsIGwsICEwKSkgOiBkID0gbmV3IEN1c3RvbUV2ZW50KGUsIHtcbiAgICAgICAgYnViYmxlczogbCxcbiAgICAgICAgY2FuY2VsYWJsZTogITBcbiAgICAgIH0pLCB2b2lkIDAgIT09IGkgJiYgT2JqZWN0LmtleXMoaSkuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGQsIHQsIHtcbiAgICAgICAgICBnZXQ6ICgpID0+IGlbdF1cbiAgICAgICAgfSk7XG4gICAgICB9KSwgaCAmJiBkLnByZXZlbnREZWZhdWx0KCksIGMgJiYgdC5kaXNwYXRjaEV2ZW50KGQpLCBkLmRlZmF1bHRQcmV2ZW50ZWQgJiYgdm9pZCAwICE9PSBhICYmIGEucHJldmVudERlZmF1bHQoKSwgZDtcbiAgICB9XG5cbiAgfSxcbiAgICAgICAgTSA9IG5ldyBNYXAoKSxcbiAgICAgICAgSCA9IHtcbiAgICBzZXQodCwgZSwgaSkge1xuICAgICAgTS5oYXModCkgfHwgTS5zZXQodCwgbmV3IE1hcCgpKTtcbiAgICAgIGNvbnN0IG4gPSBNLmdldCh0KTtcbiAgICAgIG4uaGFzKGUpIHx8IDAgPT09IG4uc2l6ZSA/IG4uc2V0KGUsIGkpIDogY29uc29sZS5lcnJvcihgQm9vdHN0cmFwIGRvZXNuJ3QgYWxsb3cgbW9yZSB0aGFuIG9uZSBpbnN0YW5jZSBwZXIgZWxlbWVudC4gQm91bmQgaW5zdGFuY2U6ICR7QXJyYXkuZnJvbShuLmtleXMoKSlbMF19LmApO1xuICAgIH0sXG5cbiAgICBnZXQ6ICh0LCBlKSA9PiBNLmhhcyh0KSAmJiBNLmdldCh0KS5nZXQoZSkgfHwgbnVsbCxcblxuICAgIHJlbW92ZSh0LCBlKSB7XG4gICAgICBpZiAoIU0uaGFzKHQpKSByZXR1cm47XG4gICAgICBjb25zdCBpID0gTS5nZXQodCk7XG4gICAgICBpLmRlbGV0ZShlKSwgMCA9PT0gaS5zaXplICYmIE0uZGVsZXRlKHQpO1xuICAgIH1cblxuICB9O1xuXG4gIGNsYXNzIEIge1xuICAgIGNvbnN0cnVjdG9yKHQpIHtcbiAgICAgICh0ID0gcih0KSkgJiYgKHRoaXMuX2VsZW1lbnQgPSB0LCBILnNldCh0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZLCB0aGlzKSk7XG4gICAgfVxuXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgIEgucmVtb3ZlKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVkpLCBqLm9mZih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkVWRU5UX0tFWSksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpLmZvckVhY2godCA9PiB7XG4gICAgICAgIHRoaXNbdF0gPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX3F1ZXVlQ2FsbGJhY2sodCwgZSwgaSA9ICEwKSB7XG4gICAgICBiKHQsIGUsIGkpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgICByZXR1cm4gSC5nZXQocih0KSwgdGhpcy5EQVRBX0tFWSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCBcIm9iamVjdFwiID09IHR5cGVvZiBlID8gZSA6IG51bGwpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICAgIHJldHVybiBcIjUuMS4zXCI7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgaGF2ZSB0byBpbXBsZW1lbnQgdGhlIHN0YXRpYyBtZXRob2QgXCJOQU1FXCIsIGZvciBlYWNoIGNvbXBvbmVudCEnKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IERBVEFfS0VZKCkge1xuICAgICAgcmV0dXJuIGBicy4ke3RoaXMuTkFNRX1gO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgRVZFTlRfS0VZKCkge1xuICAgICAgcmV0dXJuIGAuJHt0aGlzLkRBVEFfS0VZfWA7XG4gICAgfVxuXG4gIH1cblxuICBjb25zdCBSID0gKHQsIGUgPSBcImhpZGVcIikgPT4ge1xuICAgIGNvbnN0IGkgPSBgY2xpY2suZGlzbWlzcyR7dC5FVkVOVF9LRVl9YCxcbiAgICAgICAgICBzID0gdC5OQU1FO1xuICAgIGoub24oZG9jdW1lbnQsIGksIGBbZGF0YS1icy1kaXNtaXNzPVwiJHtzfVwiXWAsIGZ1bmN0aW9uIChpKSB7XG4gICAgICBpZiAoW1wiQVwiLCBcIkFSRUFcIl0uaW5jbHVkZXModGhpcy50YWdOYW1lKSAmJiBpLnByZXZlbnREZWZhdWx0KCksIGModGhpcykpIHJldHVybjtcbiAgICAgIGNvbnN0IG8gPSBuKHRoaXMpIHx8IHRoaXMuY2xvc2VzdChgLiR7c31gKTtcbiAgICAgIHQuZ2V0T3JDcmVhdGVJbnN0YW5jZShvKVtlXSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIGNsYXNzIFcgZXh0ZW5kcyBCIHtcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgICByZXR1cm4gXCJhbGVydFwiO1xuICAgIH1cblxuICAgIGNsb3NlKCkge1xuICAgICAgaWYgKGoudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBcImNsb3NlLmJzLmFsZXJ0XCIpLmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwic2hvd1wiKTtcblxuICAgICAgY29uc3QgdCA9IHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZmFkZVwiKTtcblxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB0aGlzLl9kZXN0cm95RWxlbWVudCgpLCB0aGlzLl9lbGVtZW50LCB0KTtcbiAgICB9XG5cbiAgICBfZGVzdHJveUVsZW1lbnQoKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZSgpLCBqLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgXCJjbG9zZWQuYnMuYWxlcnRcIiksIHRoaXMuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGUgPSBXLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcyk7XG5cbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHQpIHtcbiAgICAgICAgICBpZiAodm9pZCAwID09PSBlW3RdIHx8IHQuc3RhcnRzV2l0aChcIl9cIikgfHwgXCJjb25zdHJ1Y3RvclwiID09PSB0KSB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgICBlW3RdKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfVxuXG4gIFIoVywgXCJjbG9zZVwiKSwgZyhXKTtcbiAgY29uc3QgJCA9ICdbZGF0YS1icy10b2dnbGU9XCJidXR0b25cIl0nO1xuXG4gIGNsYXNzIHogZXh0ZW5kcyBCIHtcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgICByZXR1cm4gXCJidXR0b25cIjtcbiAgICB9XG5cbiAgICB0b2dnbGUoKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtcHJlc3NlZFwiLCB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoXCJhY3RpdmVcIikpO1xuICAgIH1cblxuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGUgPSB6LmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcyk7XG4gICAgICAgIFwidG9nZ2xlXCIgPT09IHQgJiYgZVt0XSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiBxKHQpIHtcbiAgICByZXR1cm4gXCJ0cnVlXCIgPT09IHQgfHwgXCJmYWxzZVwiICE9PSB0ICYmICh0ID09PSBOdW1iZXIodCkudG9TdHJpbmcoKSA/IE51bWJlcih0KSA6IFwiXCIgPT09IHQgfHwgXCJudWxsXCIgPT09IHQgPyBudWxsIDogdCk7XG4gIH1cblxuICBmdW5jdGlvbiBGKHQpIHtcbiAgICByZXR1cm4gdC5yZXBsYWNlKC9bQS1aXS9nLCB0ID0+IGAtJHt0LnRvTG93ZXJDYXNlKCl9YCk7XG4gIH1cblxuICBqLm9uKGRvY3VtZW50LCBcImNsaWNrLmJzLmJ1dHRvbi5kYXRhLWFwaVwiLCAkLCB0ID0+IHtcbiAgICB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgZSA9IHQudGFyZ2V0LmNsb3Nlc3QoJCk7XG4gICAgei5nZXRPckNyZWF0ZUluc3RhbmNlKGUpLnRvZ2dsZSgpO1xuICB9KSwgZyh6KTtcbiAgY29uc3QgVSA9IHtcbiAgICBzZXREYXRhQXR0cmlidXRlKHQsIGUsIGkpIHtcbiAgICAgIHQuc2V0QXR0cmlidXRlKGBkYXRhLWJzLSR7RihlKX1gLCBpKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlRGF0YUF0dHJpYnV0ZSh0LCBlKSB7XG4gICAgICB0LnJlbW92ZUF0dHJpYnV0ZShgZGF0YS1icy0ke0YoZSl9YCk7XG4gICAgfSxcblxuICAgIGdldERhdGFBdHRyaWJ1dGVzKHQpIHtcbiAgICAgIGlmICghdCkgcmV0dXJuIHt9O1xuICAgICAgY29uc3QgZSA9IHt9O1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHQuZGF0YXNldCkuZmlsdGVyKHQgPT4gdC5zdGFydHNXaXRoKFwiYnNcIikpLmZvckVhY2goaSA9PiB7XG4gICAgICAgIGxldCBuID0gaS5yZXBsYWNlKC9eYnMvLCBcIlwiKTtcbiAgICAgICAgbiA9IG4uY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBuLnNsaWNlKDEsIG4ubGVuZ3RoKSwgZVtuXSA9IHEodC5kYXRhc2V0W2ldKTtcbiAgICAgIH0pLCBlO1xuICAgIH0sXG5cbiAgICBnZXREYXRhQXR0cmlidXRlOiAodCwgZSkgPT4gcSh0LmdldEF0dHJpYnV0ZShgZGF0YS1icy0ke0YoZSl9YCkpLFxuXG4gICAgb2Zmc2V0KHQpIHtcbiAgICAgIGNvbnN0IGUgPSB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBlLnRvcCArIHdpbmRvdy5wYWdlWU9mZnNldCxcbiAgICAgICAgbGVmdDogZS5sZWZ0ICsgd2luZG93LnBhZ2VYT2Zmc2V0XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBwb3NpdGlvbjogdCA9PiAoe1xuICAgICAgdG9wOiB0Lm9mZnNldFRvcCxcbiAgICAgIGxlZnQ6IHQub2Zmc2V0TGVmdFxuICAgIH0pXG4gIH0sXG4gICAgICAgIFYgPSB7XG4gICAgZmluZDogKHQsIGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpID0+IFtdLmNvbmNhdCguLi5FbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsLmNhbGwoZSwgdCkpLFxuICAgIGZpbmRPbmU6ICh0LCBlID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSA9PiBFbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yLmNhbGwoZSwgdCksXG4gICAgY2hpbGRyZW46ICh0LCBlKSA9PiBbXS5jb25jYXQoLi4udC5jaGlsZHJlbikuZmlsdGVyKHQgPT4gdC5tYXRjaGVzKGUpKSxcblxuICAgIHBhcmVudHModCwgZSkge1xuICAgICAgY29uc3QgaSA9IFtdO1xuICAgICAgbGV0IG4gPSB0LnBhcmVudE5vZGU7XG5cbiAgICAgIGZvciAoOyBuICYmIG4ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIDMgIT09IG4ubm9kZVR5cGU7KSBuLm1hdGNoZXMoZSkgJiYgaS5wdXNoKG4pLCBuID0gbi5wYXJlbnROb2RlO1xuXG4gICAgICByZXR1cm4gaTtcbiAgICB9LFxuXG4gICAgcHJldih0LCBlKSB7XG4gICAgICBsZXQgaSA9IHQucHJldmlvdXNFbGVtZW50U2libGluZztcblxuICAgICAgZm9yICg7IGk7KSB7XG4gICAgICAgIGlmIChpLm1hdGNoZXMoZSkpIHJldHVybiBbaV07XG4gICAgICAgIGkgPSBpLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuXG4gICAgbmV4dCh0LCBlKSB7XG4gICAgICBsZXQgaSA9IHQubmV4dEVsZW1lbnRTaWJsaW5nO1xuXG4gICAgICBmb3IgKDsgaTspIHtcbiAgICAgICAgaWYgKGkubWF0Y2hlcyhlKSkgcmV0dXJuIFtpXTtcbiAgICAgICAgaSA9IGkubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW107XG4gICAgfSxcblxuICAgIGZvY3VzYWJsZUNoaWxkcmVuKHQpIHtcbiAgICAgIGNvbnN0IGUgPSBbXCJhXCIsIFwiYnV0dG9uXCIsIFwiaW5wdXRcIiwgXCJ0ZXh0YXJlYVwiLCBcInNlbGVjdFwiLCBcImRldGFpbHNcIiwgXCJbdGFiaW5kZXhdXCIsICdbY29udGVudGVkaXRhYmxlPVwidHJ1ZVwiXSddLm1hcCh0ID0+IGAke3R9Om5vdChbdGFiaW5kZXhePVwiLVwiXSlgKS5qb2luKFwiLCBcIik7XG4gICAgICByZXR1cm4gdGhpcy5maW5kKGUsIHQpLmZpbHRlcih0ID0+ICFjKHQpICYmIGwodCkpO1xuICAgIH1cblxuICB9LFxuICAgICAgICBLID0gXCJjYXJvdXNlbFwiLFxuICAgICAgICBYID0ge1xuICAgIGludGVydmFsOiA1ZTMsXG4gICAga2V5Ym9hcmQ6ICEwLFxuICAgIHNsaWRlOiAhMSxcbiAgICBwYXVzZTogXCJob3ZlclwiLFxuICAgIHdyYXA6ICEwLFxuICAgIHRvdWNoOiAhMFxuICB9LFxuICAgICAgICBZID0ge1xuICAgIGludGVydmFsOiBcIihudW1iZXJ8Ym9vbGVhbilcIixcbiAgICBrZXlib2FyZDogXCJib29sZWFuXCIsXG4gICAgc2xpZGU6IFwiKGJvb2xlYW58c3RyaW5nKVwiLFxuICAgIHBhdXNlOiBcIihzdHJpbmd8Ym9vbGVhbilcIixcbiAgICB3cmFwOiBcImJvb2xlYW5cIixcbiAgICB0b3VjaDogXCJib29sZWFuXCJcbiAgfSxcbiAgICAgICAgUSA9IFwibmV4dFwiLFxuICAgICAgICBHID0gXCJwcmV2XCIsXG4gICAgICAgIFogPSBcImxlZnRcIixcbiAgICAgICAgSiA9IFwicmlnaHRcIixcbiAgICAgICAgdHQgPSB7XG4gICAgQXJyb3dMZWZ0OiBKLFxuICAgIEFycm93UmlnaHQ6IFpcbiAgfSxcbiAgICAgICAgZXQgPSBcInNsaWQuYnMuY2Fyb3VzZWxcIixcbiAgICAgICAgaXQgPSBcImFjdGl2ZVwiLFxuICAgICAgICBudCA9IFwiLmFjdGl2ZS5jYXJvdXNlbC1pdGVtXCI7XG5cbiAgY2xhc3Mgc3QgZXh0ZW5kcyBCIHtcbiAgICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgICBzdXBlcih0KSwgdGhpcy5faXRlbXMgPSBudWxsLCB0aGlzLl9pbnRlcnZhbCA9IG51bGwsIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBudWxsLCB0aGlzLl9pc1BhdXNlZCA9ICExLCB0aGlzLl9pc1NsaWRpbmcgPSAhMSwgdGhpcy50b3VjaFRpbWVvdXQgPSBudWxsLCB0aGlzLnRvdWNoU3RhcnRYID0gMCwgdGhpcy50b3VjaERlbHRhWCA9IDAsIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQgPSBWLmZpbmRPbmUoXCIuY2Fyb3VzZWwtaW5kaWNhdG9yc1wiLCB0aGlzLl9lbGVtZW50KSwgdGhpcy5fdG91Y2hTdXBwb3J0ZWQgPSBcIm9udG91Y2hzdGFydFwiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwLCB0aGlzLl9wb2ludGVyRXZlbnQgPSBCb29sZWFuKHdpbmRvdy5Qb2ludGVyRXZlbnQpLCB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBYO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHJldHVybiBLO1xuICAgIH1cblxuICAgIG5leHQoKSB7XG4gICAgICB0aGlzLl9zbGlkZShRKTtcbiAgICB9XG5cbiAgICBuZXh0V2hlblZpc2libGUoKSB7XG4gICAgICAhZG9jdW1lbnQuaGlkZGVuICYmIGwodGhpcy5fZWxlbWVudCkgJiYgdGhpcy5uZXh0KCk7XG4gICAgfVxuXG4gICAgcHJldigpIHtcbiAgICAgIHRoaXMuX3NsaWRlKEcpO1xuICAgIH1cblxuICAgIHBhdXNlKHQpIHtcbiAgICAgIHQgfHwgKHRoaXMuX2lzUGF1c2VkID0gITApLCBWLmZpbmRPbmUoXCIuY2Fyb3VzZWwtaXRlbS1uZXh0LCAuY2Fyb3VzZWwtaXRlbS1wcmV2XCIsIHRoaXMuX2VsZW1lbnQpICYmIChzKHRoaXMuX2VsZW1lbnQpLCB0aGlzLmN5Y2xlKCEwKSksIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpLCB0aGlzLl9pbnRlcnZhbCA9IG51bGw7XG4gICAgfVxuXG4gICAgY3ljbGUodCkge1xuICAgICAgdCB8fCAodGhpcy5faXNQYXVzZWQgPSAhMSksIHRoaXMuX2ludGVydmFsICYmIChjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKSwgdGhpcy5faW50ZXJ2YWwgPSBudWxsKSwgdGhpcy5fY29uZmlnICYmIHRoaXMuX2NvbmZpZy5pbnRlcnZhbCAmJiAhdGhpcy5faXNQYXVzZWQgJiYgKHRoaXMuX3VwZGF0ZUludGVydmFsKCksIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA/IHRoaXMubmV4dFdoZW5WaXNpYmxlIDogdGhpcy5uZXh0KS5iaW5kKHRoaXMpLCB0aGlzLl9jb25maWcuaW50ZXJ2YWwpKTtcbiAgICB9XG5cbiAgICB0byh0KSB7XG4gICAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gVi5maW5kT25lKG50LCB0aGlzLl9lbGVtZW50KTtcblxuICAgICAgY29uc3QgZSA9IHRoaXMuX2dldEl0ZW1JbmRleCh0aGlzLl9hY3RpdmVFbGVtZW50KTtcblxuICAgICAgaWYgKHQgPiB0aGlzLl9pdGVtcy5sZW5ndGggLSAxIHx8IHQgPCAwKSByZXR1cm47XG4gICAgICBpZiAodGhpcy5faXNTbGlkaW5nKSByZXR1cm4gdm9pZCBqLm9uZSh0aGlzLl9lbGVtZW50LCBldCwgKCkgPT4gdGhpcy50byh0KSk7XG4gICAgICBpZiAoZSA9PT0gdCkgcmV0dXJuIHRoaXMucGF1c2UoKSwgdm9pZCB0aGlzLmN5Y2xlKCk7XG4gICAgICBjb25zdCBpID0gdCA+IGUgPyBRIDogRztcblxuICAgICAgdGhpcy5fc2xpZGUoaSwgdGhpcy5faXRlbXNbdF0pO1xuICAgIH1cblxuICAgIF9nZXRDb25maWcodCkge1xuICAgICAgcmV0dXJuIHQgPSB7IC4uLlgsXG4gICAgICAgIC4uLlUuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAgIC4uLihcIm9iamVjdFwiID09IHR5cGVvZiB0ID8gdCA6IHt9KVxuICAgICAgfSwgYShLLCB0LCBZKSwgdDtcbiAgICB9XG5cbiAgICBfaGFuZGxlU3dpcGUoKSB7XG4gICAgICBjb25zdCB0ID0gTWF0aC5hYnModGhpcy50b3VjaERlbHRhWCk7XG4gICAgICBpZiAodCA8PSA0MCkgcmV0dXJuO1xuICAgICAgY29uc3QgZSA9IHQgLyB0aGlzLnRvdWNoRGVsdGFYO1xuICAgICAgdGhpcy50b3VjaERlbHRhWCA9IDAsIGUgJiYgdGhpcy5fc2xpZGUoZSA+IDAgPyBKIDogWik7XG4gICAgfVxuXG4gICAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdGhpcy5fY29uZmlnLmtleWJvYXJkICYmIGoub24odGhpcy5fZWxlbWVudCwgXCJrZXlkb3duLmJzLmNhcm91c2VsXCIsIHQgPT4gdGhpcy5fa2V5ZG93bih0KSksIFwiaG92ZXJcIiA9PT0gdGhpcy5fY29uZmlnLnBhdXNlICYmIChqLm9uKHRoaXMuX2VsZW1lbnQsIFwibW91c2VlbnRlci5icy5jYXJvdXNlbFwiLCB0ID0+IHRoaXMucGF1c2UodCkpLCBqLm9uKHRoaXMuX2VsZW1lbnQsIFwibW91c2VsZWF2ZS5icy5jYXJvdXNlbFwiLCB0ID0+IHRoaXMuY3ljbGUodCkpKSwgdGhpcy5fY29uZmlnLnRvdWNoICYmIHRoaXMuX3RvdWNoU3VwcG9ydGVkICYmIHRoaXMuX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICBfYWRkVG91Y2hFdmVudExpc3RlbmVycygpIHtcbiAgICAgIGNvbnN0IHQgPSB0ID0+IHRoaXMuX3BvaW50ZXJFdmVudCAmJiAoXCJwZW5cIiA9PT0gdC5wb2ludGVyVHlwZSB8fCBcInRvdWNoXCIgPT09IHQucG9pbnRlclR5cGUpLFxuICAgICAgICAgICAgZSA9IGUgPT4ge1xuICAgICAgICB0KGUpID8gdGhpcy50b3VjaFN0YXJ0WCA9IGUuY2xpZW50WCA6IHRoaXMuX3BvaW50ZXJFdmVudCB8fCAodGhpcy50b3VjaFN0YXJ0WCA9IGUudG91Y2hlc1swXS5jbGllbnRYKTtcbiAgICAgIH0sXG4gICAgICAgICAgICBpID0gdCA9PiB7XG4gICAgICAgIHRoaXMudG91Y2hEZWx0YVggPSB0LnRvdWNoZXMgJiYgdC50b3VjaGVzLmxlbmd0aCA+IDEgPyAwIDogdC50b3VjaGVzWzBdLmNsaWVudFggLSB0aGlzLnRvdWNoU3RhcnRYO1xuICAgICAgfSxcbiAgICAgICAgICAgIG4gPSBlID0+IHtcbiAgICAgICAgdChlKSAmJiAodGhpcy50b3VjaERlbHRhWCA9IGUuY2xpZW50WCAtIHRoaXMudG91Y2hTdGFydFgpLCB0aGlzLl9oYW5kbGVTd2lwZSgpLCBcImhvdmVyXCIgPT09IHRoaXMuX2NvbmZpZy5wYXVzZSAmJiAodGhpcy5wYXVzZSgpLCB0aGlzLnRvdWNoVGltZW91dCAmJiBjbGVhclRpbWVvdXQodGhpcy50b3VjaFRpbWVvdXQpLCB0aGlzLnRvdWNoVGltZW91dCA9IHNldFRpbWVvdXQodCA9PiB0aGlzLmN5Y2xlKHQpLCA1MDAgKyB0aGlzLl9jb25maWcuaW50ZXJ2YWwpKTtcbiAgICAgIH07XG5cbiAgICAgIFYuZmluZChcIi5jYXJvdXNlbC1pdGVtIGltZ1wiLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKHQgPT4ge1xuICAgICAgICBqLm9uKHQsIFwiZHJhZ3N0YXJ0LmJzLmNhcm91c2VsXCIsIHQgPT4gdC5wcmV2ZW50RGVmYXVsdCgpKTtcbiAgICAgIH0pLCB0aGlzLl9wb2ludGVyRXZlbnQgPyAoai5vbih0aGlzLl9lbGVtZW50LCBcInBvaW50ZXJkb3duLmJzLmNhcm91c2VsXCIsIHQgPT4gZSh0KSksIGoub24odGhpcy5fZWxlbWVudCwgXCJwb2ludGVydXAuYnMuY2Fyb3VzZWxcIiwgdCA9PiBuKHQpKSwgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwicG9pbnRlci1ldmVudFwiKSkgOiAoai5vbih0aGlzLl9lbGVtZW50LCBcInRvdWNoc3RhcnQuYnMuY2Fyb3VzZWxcIiwgdCA9PiBlKHQpKSwgai5vbih0aGlzLl9lbGVtZW50LCBcInRvdWNobW92ZS5icy5jYXJvdXNlbFwiLCB0ID0+IGkodCkpLCBqLm9uKHRoaXMuX2VsZW1lbnQsIFwidG91Y2hlbmQuYnMuY2Fyb3VzZWxcIiwgdCA9PiBuKHQpKSk7XG4gICAgfVxuXG4gICAgX2tleWRvd24odCkge1xuICAgICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QodC50YXJnZXQudGFnTmFtZSkpIHJldHVybjtcbiAgICAgIGNvbnN0IGUgPSB0dFt0LmtleV07XG4gICAgICBlICYmICh0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuX3NsaWRlKGUpKTtcbiAgICB9XG5cbiAgICBfZ2V0SXRlbUluZGV4KHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVtcyA9IHQgJiYgdC5wYXJlbnROb2RlID8gVi5maW5kKFwiLmNhcm91c2VsLWl0ZW1cIiwgdC5wYXJlbnROb2RlKSA6IFtdLCB0aGlzLl9pdGVtcy5pbmRleE9mKHQpO1xuICAgIH1cblxuICAgIF9nZXRJdGVtQnlPcmRlcih0LCBlKSB7XG4gICAgICBjb25zdCBpID0gdCA9PT0gUTtcbiAgICAgIHJldHVybiB2KHRoaXMuX2l0ZW1zLCBlLCBpLCB0aGlzLl9jb25maWcud3JhcCk7XG4gICAgfVxuXG4gICAgX3RyaWdnZXJTbGlkZUV2ZW50KHQsIGUpIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLl9nZXRJdGVtSW5kZXgodCksXG4gICAgICAgICAgICBuID0gdGhpcy5fZ2V0SXRlbUluZGV4KFYuZmluZE9uZShudCwgdGhpcy5fZWxlbWVudCkpO1xuXG4gICAgICByZXR1cm4gai50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFwic2xpZGUuYnMuY2Fyb3VzZWxcIiwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0LFxuICAgICAgICBkaXJlY3Rpb246IGUsXG4gICAgICAgIGZyb206IG4sXG4gICAgICAgIHRvOiBpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudCh0KSB7XG4gICAgICBpZiAodGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgZSA9IFYuZmluZE9uZShcIi5hY3RpdmVcIiwgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpO1xuICAgICAgICBlLmNsYXNzTGlzdC5yZW1vdmUoaXQpLCBlLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtY3VycmVudFwiKTtcbiAgICAgICAgY29uc3QgaSA9IFYuZmluZChcIltkYXRhLWJzLXRhcmdldF1cIiwgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpO1xuXG4gICAgICAgIGZvciAobGV0IGUgPSAwOyBlIDwgaS5sZW5ndGg7IGUrKykgaWYgKE51bWJlci5wYXJzZUludChpW2VdLmdldEF0dHJpYnV0ZShcImRhdGEtYnMtc2xpZGUtdG9cIiksIDEwKSA9PT0gdGhpcy5fZ2V0SXRlbUluZGV4KHQpKSB7XG4gICAgICAgICAgaVtlXS5jbGFzc0xpc3QuYWRkKGl0KSwgaVtlXS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWN1cnJlbnRcIiwgXCJ0cnVlXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3VwZGF0ZUludGVydmFsKCkge1xuICAgICAgY29uc3QgdCA9IHRoaXMuX2FjdGl2ZUVsZW1lbnQgfHwgVi5maW5kT25lKG50LCB0aGlzLl9lbGVtZW50KTtcbiAgICAgIGlmICghdCkgcmV0dXJuO1xuICAgICAgY29uc3QgZSA9IE51bWJlci5wYXJzZUludCh0LmdldEF0dHJpYnV0ZShcImRhdGEtYnMtaW50ZXJ2YWxcIiksIDEwKTtcbiAgICAgIGUgPyAodGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbCA9IHRoaXMuX2NvbmZpZy5kZWZhdWx0SW50ZXJ2YWwgfHwgdGhpcy5fY29uZmlnLmludGVydmFsLCB0aGlzLl9jb25maWcuaW50ZXJ2YWwgPSBlKSA6IHRoaXMuX2NvbmZpZy5pbnRlcnZhbCA9IHRoaXMuX2NvbmZpZy5kZWZhdWx0SW50ZXJ2YWwgfHwgdGhpcy5fY29uZmlnLmludGVydmFsO1xuICAgIH1cblxuICAgIF9zbGlkZSh0LCBlKSB7XG4gICAgICBjb25zdCBpID0gdGhpcy5fZGlyZWN0aW9uVG9PcmRlcih0KSxcbiAgICAgICAgICAgIG4gPSBWLmZpbmRPbmUobnQsIHRoaXMuX2VsZW1lbnQpLFxuICAgICAgICAgICAgcyA9IHRoaXMuX2dldEl0ZW1JbmRleChuKSxcbiAgICAgICAgICAgIG8gPSBlIHx8IHRoaXMuX2dldEl0ZW1CeU9yZGVyKGksIG4pLFxuICAgICAgICAgICAgciA9IHRoaXMuX2dldEl0ZW1JbmRleChvKSxcbiAgICAgICAgICAgIGEgPSBCb29sZWFuKHRoaXMuX2ludGVydmFsKSxcbiAgICAgICAgICAgIGwgPSBpID09PSBRLFxuICAgICAgICAgICAgYyA9IGwgPyBcImNhcm91c2VsLWl0ZW0tc3RhcnRcIiA6IFwiY2Fyb3VzZWwtaXRlbS1lbmRcIixcbiAgICAgICAgICAgIGggPSBsID8gXCJjYXJvdXNlbC1pdGVtLW5leHRcIiA6IFwiY2Fyb3VzZWwtaXRlbS1wcmV2XCIsXG4gICAgICAgICAgICBkID0gdGhpcy5fb3JkZXJUb0RpcmVjdGlvbihpKTtcblxuICAgICAgaWYgKG8gJiYgby5jbGFzc0xpc3QuY29udGFpbnMoaXQpKSByZXR1cm4gdm9pZCAodGhpcy5faXNTbGlkaW5nID0gITEpO1xuICAgICAgaWYgKHRoaXMuX2lzU2xpZGluZykgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMuX3RyaWdnZXJTbGlkZUV2ZW50KG8sIGQpLmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcbiAgICAgIGlmICghbiB8fCAhbykgcmV0dXJuO1xuICAgICAgdGhpcy5faXNTbGlkaW5nID0gITAsIGEgJiYgdGhpcy5wYXVzZSgpLCB0aGlzLl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KG8pLCB0aGlzLl9hY3RpdmVFbGVtZW50ID0gbztcblxuICAgICAgY29uc3QgZiA9ICgpID0+IHtcbiAgICAgICAgai50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGV0LCB7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogbyxcbiAgICAgICAgICBkaXJlY3Rpb246IGQsXG4gICAgICAgICAgZnJvbTogcyxcbiAgICAgICAgICB0bzogclxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcInNsaWRlXCIpKSB7XG4gICAgICAgIG8uY2xhc3NMaXN0LmFkZChoKSwgdShvKSwgbi5jbGFzc0xpc3QuYWRkKGMpLCBvLmNsYXNzTGlzdC5hZGQoYyk7XG5cbiAgICAgICAgY29uc3QgdCA9ICgpID0+IHtcbiAgICAgICAgICBvLmNsYXNzTGlzdC5yZW1vdmUoYywgaCksIG8uY2xhc3NMaXN0LmFkZChpdCksIG4uY2xhc3NMaXN0LnJlbW92ZShpdCwgaCwgYyksIHRoaXMuX2lzU2xpZGluZyA9ICExLCBzZXRUaW1lb3V0KGYsIDApO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2sodCwgbiwgITApO1xuICAgICAgfSBlbHNlIG4uY2xhc3NMaXN0LnJlbW92ZShpdCksIG8uY2xhc3NMaXN0LmFkZChpdCksIHRoaXMuX2lzU2xpZGluZyA9ICExLCBmKCk7XG5cbiAgICAgIGEgJiYgdGhpcy5jeWNsZSgpO1xuICAgIH1cblxuICAgIF9kaXJlY3Rpb25Ub09yZGVyKHQpIHtcbiAgICAgIHJldHVybiBbSiwgWl0uaW5jbHVkZXModCkgPyBtKCkgPyB0ID09PSBaID8gRyA6IFEgOiB0ID09PSBaID8gUSA6IEcgOiB0O1xuICAgIH1cblxuICAgIF9vcmRlclRvRGlyZWN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBbUSwgR10uaW5jbHVkZXModCkgPyBtKCkgPyB0ID09PSBHID8gWiA6IEogOiB0ID09PSBHID8gSiA6IFogOiB0O1xuICAgIH1cblxuICAgIHN0YXRpYyBjYXJvdXNlbEludGVyZmFjZSh0LCBlKSB7XG4gICAgICBjb25zdCBpID0gc3QuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlKTtcbiAgICAgIGxldCB7XG4gICAgICAgIF9jb25maWc6IG5cbiAgICAgIH0gPSBpO1xuICAgICAgXCJvYmplY3RcIiA9PSB0eXBlb2YgZSAmJiAobiA9IHsgLi4ubixcbiAgICAgICAgLi4uZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBzID0gXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSA/IGUgOiBuLnNsaWRlO1xuICAgICAgaWYgKFwibnVtYmVyXCIgPT0gdHlwZW9mIGUpIGkudG8oZSk7ZWxzZSBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2Ygcykge1xuICAgICAgICBpZiAodm9pZCAwID09PSBpW3NdKSB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3N9XCJgKTtcbiAgICAgICAgaVtzXSgpO1xuICAgICAgfSBlbHNlIG4uaW50ZXJ2YWwgJiYgbi5yaWRlICYmIChpLnBhdXNlKCksIGkuY3ljbGUoKSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3QuY2Fyb3VzZWxJbnRlcmZhY2UodGhpcywgdCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZGF0YUFwaUNsaWNrSGFuZGxlcih0KSB7XG4gICAgICBjb25zdCBlID0gbih0aGlzKTtcbiAgICAgIGlmICghZSB8fCAhZS5jbGFzc0xpc3QuY29udGFpbnMoXCJjYXJvdXNlbFwiKSkgcmV0dXJuO1xuICAgICAgY29uc3QgaSA9IHsgLi4uVS5nZXREYXRhQXR0cmlidXRlcyhlKSxcbiAgICAgICAgLi4uVS5nZXREYXRhQXR0cmlidXRlcyh0aGlzKVxuICAgICAgfSxcbiAgICAgICAgICAgIHMgPSB0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtYnMtc2xpZGUtdG9cIik7XG4gICAgICBzICYmIChpLmludGVydmFsID0gITEpLCBzdC5jYXJvdXNlbEludGVyZmFjZShlLCBpKSwgcyAmJiBzdC5nZXRJbnN0YW5jZShlKS50byhzKSwgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICB9XG5cbiAgai5vbihkb2N1bWVudCwgXCJjbGljay5icy5jYXJvdXNlbC5kYXRhLWFwaVwiLCBcIltkYXRhLWJzLXNsaWRlXSwgW2RhdGEtYnMtc2xpZGUtdG9dXCIsIHN0LmRhdGFBcGlDbGlja0hhbmRsZXIpLCBqLm9uKHdpbmRvdywgXCJsb2FkLmJzLmNhcm91c2VsLmRhdGEtYXBpXCIsICgpID0+IHtcbiAgICBjb25zdCB0ID0gVi5maW5kKCdbZGF0YS1icy1yaWRlPVwiY2Fyb3VzZWxcIl0nKTtcblxuICAgIGZvciAobGV0IGUgPSAwLCBpID0gdC5sZW5ndGg7IGUgPCBpOyBlKyspIHN0LmNhcm91c2VsSW50ZXJmYWNlKHRbZV0sIHN0LmdldEluc3RhbmNlKHRbZV0pKTtcbiAgfSksIGcoc3QpO1xuICBjb25zdCBvdCA9IFwiY29sbGFwc2VcIixcbiAgICAgICAgcnQgPSB7XG4gICAgdG9nZ2xlOiAhMCxcbiAgICBwYXJlbnQ6IG51bGxcbiAgfSxcbiAgICAgICAgYXQgPSB7XG4gICAgdG9nZ2xlOiBcImJvb2xlYW5cIixcbiAgICBwYXJlbnQ6IFwiKG51bGx8ZWxlbWVudClcIlxuICB9LFxuICAgICAgICBsdCA9IFwic2hvd1wiLFxuICAgICAgICBjdCA9IFwiY29sbGFwc2VcIixcbiAgICAgICAgaHQgPSBcImNvbGxhcHNpbmdcIixcbiAgICAgICAgZHQgPSBcImNvbGxhcHNlZFwiLFxuICAgICAgICB1dCA9IFwiOnNjb3BlIC5jb2xsYXBzZSAuY29sbGFwc2VcIixcbiAgICAgICAgZnQgPSAnW2RhdGEtYnMtdG9nZ2xlPVwiY29sbGFwc2VcIl0nO1xuXG4gIGNsYXNzIHB0IGV4dGVuZHMgQiB7XG4gICAgY29uc3RydWN0b3IodCwgZSkge1xuICAgICAgc3VwZXIodCksIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICExLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX3RyaWdnZXJBcnJheSA9IFtdO1xuICAgICAgY29uc3QgbiA9IFYuZmluZChmdCk7XG5cbiAgICAgIGZvciAobGV0IHQgPSAwLCBlID0gbi5sZW5ndGg7IHQgPCBlOyB0KyspIHtcbiAgICAgICAgY29uc3QgZSA9IG5bdF0sXG4gICAgICAgICAgICAgIHMgPSBpKGUpLFxuICAgICAgICAgICAgICBvID0gVi5maW5kKHMpLmZpbHRlcih0ID0+IHQgPT09IHRoaXMuX2VsZW1lbnQpO1xuICAgICAgICBudWxsICE9PSBzICYmIG8ubGVuZ3RoICYmICh0aGlzLl9zZWxlY3RvciA9IHMsIHRoaXMuX3RyaWdnZXJBcnJheS5wdXNoKGUpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faW5pdGlhbGl6ZUNoaWxkcmVuKCksIHRoaXMuX2NvbmZpZy5wYXJlbnQgfHwgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuX3RyaWdnZXJBcnJheSwgdGhpcy5faXNTaG93bigpKSwgdGhpcy5fY29uZmlnLnRvZ2dsZSAmJiB0aGlzLnRvZ2dsZSgpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBydDtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgICByZXR1cm4gb3Q7XG4gICAgfVxuXG4gICAgdG9nZ2xlKCkge1xuICAgICAgdGhpcy5faXNTaG93bigpID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcbiAgICB9XG5cbiAgICBzaG93KCkge1xuICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCB0aGlzLl9pc1Nob3duKCkpIHJldHVybjtcbiAgICAgIGxldCB0LFxuICAgICAgICAgIGUgPSBbXTtcblxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcbiAgICAgICAgY29uc3QgdCA9IFYuZmluZCh1dCwgdGhpcy5fY29uZmlnLnBhcmVudCk7XG4gICAgICAgIGUgPSBWLmZpbmQoXCIuY29sbGFwc2Uuc2hvdywgLmNvbGxhcHNlLmNvbGxhcHNpbmdcIiwgdGhpcy5fY29uZmlnLnBhcmVudCkuZmlsdGVyKGUgPT4gIXQuaW5jbHVkZXMoZSkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpID0gVi5maW5kT25lKHRoaXMuX3NlbGVjdG9yKTtcblxuICAgICAgaWYgKGUubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IG4gPSBlLmZpbmQodCA9PiBpICE9PSB0KTtcbiAgICAgICAgaWYgKHQgPSBuID8gcHQuZ2V0SW5zdGFuY2UobikgOiBudWxsLCB0ICYmIHQuX2lzVHJhbnNpdGlvbmluZykgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoai50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFwic2hvdy5icy5jb2xsYXBzZVwiKS5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG4gICAgICBlLmZvckVhY2goZSA9PiB7XG4gICAgICAgIGkgIT09IGUgJiYgcHQuZ2V0T3JDcmVhdGVJbnN0YW5jZShlLCB7XG4gICAgICAgICAgdG9nZ2xlOiAhMVxuICAgICAgICB9KS5oaWRlKCksIHQgfHwgSC5zZXQoZSwgXCJicy5jb2xsYXBzZVwiLCBudWxsKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBuID0gdGhpcy5fZ2V0RGltZW5zaW9uKCk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjdCksIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChodCksIHRoaXMuX2VsZW1lbnQuc3R5bGVbbl0gPSAwLCB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModGhpcy5fdHJpZ2dlckFycmF5LCAhMCksIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICEwO1xuICAgICAgY29uc3QgcyA9IGBzY3JvbGwke25bMF0udG9VcHBlckNhc2UoKSArIG4uc2xpY2UoMSl9YDtcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMSwgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGh0KSwgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKGN0LCBsdCksIHRoaXMuX2VsZW1lbnQuc3R5bGVbbl0gPSBcIlwiLCBqLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgXCJzaG93bi5icy5jb2xsYXBzZVwiKTtcbiAgICAgIH0sIHRoaXMuX2VsZW1lbnQsICEwKSwgdGhpcy5fZWxlbWVudC5zdHlsZVtuXSA9IGAke3RoaXMuX2VsZW1lbnRbc119cHhgO1xuICAgIH1cblxuICAgIGhpZGUoKSB7XG4gICAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8ICF0aGlzLl9pc1Nob3duKCkpIHJldHVybjtcbiAgICAgIGlmIChqLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgXCJoaWRlLmJzLmNvbGxhcHNlXCIpLmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuICAgICAgY29uc3QgdCA9IHRoaXMuX2dldERpbWVuc2lvbigpO1xuXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW3RdID0gYCR7dGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVt0XX1weGAsIHUodGhpcy5fZWxlbWVudCksIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChodCksIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjdCwgbHQpO1xuICAgICAgY29uc3QgZSA9IHRoaXMuX3RyaWdnZXJBcnJheS5sZW5ndGg7XG5cbiAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgZTsgdCsrKSB7XG4gICAgICAgIGNvbnN0IGUgPSB0aGlzLl90cmlnZ2VyQXJyYXlbdF0sXG4gICAgICAgICAgICAgIGkgPSBuKGUpO1xuICAgICAgICBpICYmICF0aGlzLl9pc1Nob3duKGkpICYmIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyhbZV0sICExKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITAsIHRoaXMuX2VsZW1lbnQuc3R5bGVbdF0gPSBcIlwiLCB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITEsIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShodCksIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChjdCksIGoudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBcImhpZGRlbi5icy5jb2xsYXBzZVwiKTtcbiAgICAgIH0sIHRoaXMuX2VsZW1lbnQsICEwKTtcbiAgICB9XG5cbiAgICBfaXNTaG93bih0ID0gdGhpcy5fZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHQuY2xhc3NMaXN0LmNvbnRhaW5zKGx0KTtcbiAgICB9XG5cbiAgICBfZ2V0Q29uZmlnKHQpIHtcbiAgICAgIHJldHVybiAodCA9IHsgLi4ucnQsXG4gICAgICAgIC4uLlUuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAgIC4uLnRcbiAgICAgIH0pLnRvZ2dsZSA9IEJvb2xlYW4odC50b2dnbGUpLCB0LnBhcmVudCA9IHIodC5wYXJlbnQpLCBhKG90LCB0LCBhdCksIHQ7XG4gICAgfVxuXG4gICAgX2dldERpbWVuc2lvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcImNvbGxhcHNlLWhvcml6b250YWxcIikgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiO1xuICAgIH1cblxuICAgIF9pbml0aWFsaXplQ2hpbGRyZW4oKSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5wYXJlbnQpIHJldHVybjtcbiAgICAgIGNvbnN0IHQgPSBWLmZpbmQodXQsIHRoaXMuX2NvbmZpZy5wYXJlbnQpO1xuICAgICAgVi5maW5kKGZ0LCB0aGlzLl9jb25maWcucGFyZW50KS5maWx0ZXIoZSA9PiAhdC5pbmNsdWRlcyhlKSkuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgY29uc3QgZSA9IG4odCk7XG4gICAgICAgIGUgJiYgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFt0XSwgdGhpcy5faXNTaG93bihlKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHQsIGUpIHtcbiAgICAgIHQubGVuZ3RoICYmIHQuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgZSA/IHQuY2xhc3NMaXN0LnJlbW92ZShkdCkgOiB0LmNsYXNzTGlzdC5hZGQoZHQpLCB0LnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBlID0ge307XG4gICAgICAgIFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgJiYgL3Nob3d8aGlkZS8udGVzdCh0KSAmJiAoZS50b2dnbGUgPSAhMSk7XG4gICAgICAgIGNvbnN0IGkgPSBwdC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGUpO1xuXG4gICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiB0KSB7XG4gICAgICAgICAgaWYgKHZvaWQgMCA9PT0gaVt0XSkgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgICAgaVt0XSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfVxuXG4gIGoub24oZG9jdW1lbnQsIFwiY2xpY2suYnMuY29sbGFwc2UuZGF0YS1hcGlcIiwgZnQsIGZ1bmN0aW9uICh0KSB7XG4gICAgKFwiQVwiID09PSB0LnRhcmdldC50YWdOYW1lIHx8IHQuZGVsZWdhdGVUYXJnZXQgJiYgXCJBXCIgPT09IHQuZGVsZWdhdGVUYXJnZXQudGFnTmFtZSkgJiYgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IGUgPSBpKHRoaXMpO1xuICAgIFYuZmluZChlKS5mb3JFYWNoKHQgPT4ge1xuICAgICAgcHQuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCB7XG4gICAgICAgIHRvZ2dsZTogITFcbiAgICAgIH0pLnRvZ2dsZSgpO1xuICAgIH0pO1xuICB9KSwgZyhwdCk7XG4gIHZhciBtdCA9IFwidG9wXCIsXG4gICAgICBndCA9IFwiYm90dG9tXCIsXG4gICAgICBfdCA9IFwicmlnaHRcIixcbiAgICAgIGJ0ID0gXCJsZWZ0XCIsXG4gICAgICB2dCA9IFwiYXV0b1wiLFxuICAgICAgeXQgPSBbbXQsIGd0LCBfdCwgYnRdLFxuICAgICAgd3QgPSBcInN0YXJ0XCIsXG4gICAgICBFdCA9IFwiZW5kXCIsXG4gICAgICBBdCA9IFwiY2xpcHBpbmdQYXJlbnRzXCIsXG4gICAgICBUdCA9IFwidmlld3BvcnRcIixcbiAgICAgIE90ID0gXCJwb3BwZXJcIixcbiAgICAgIEN0ID0gXCJyZWZlcmVuY2VcIixcbiAgICAgIGt0ID0geXQucmVkdWNlKGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgcmV0dXJuIHQuY29uY2F0KFtlICsgXCItXCIgKyB3dCwgZSArIFwiLVwiICsgRXRdKTtcbiAgfSwgW10pLFxuICAgICAgTHQgPSBbXS5jb25jYXQoeXQsIFt2dF0pLnJlZHVjZShmdW5jdGlvbiAodCwgZSkge1xuICAgIHJldHVybiB0LmNvbmNhdChbZSwgZSArIFwiLVwiICsgd3QsIGUgKyBcIi1cIiArIEV0XSk7XG4gIH0sIFtdKSxcbiAgICAgIHh0ID0gXCJiZWZvcmVSZWFkXCIsXG4gICAgICBEdCA9IFwicmVhZFwiLFxuICAgICAgU3QgPSBcImFmdGVyUmVhZFwiLFxuICAgICAgTnQgPSBcImJlZm9yZU1haW5cIixcbiAgICAgIEl0ID0gXCJtYWluXCIsXG4gICAgICBQdCA9IFwiYWZ0ZXJNYWluXCIsXG4gICAgICBqdCA9IFwiYmVmb3JlV3JpdGVcIixcbiAgICAgIE10ID0gXCJ3cml0ZVwiLFxuICAgICAgSHQgPSBcImFmdGVyV3JpdGVcIixcbiAgICAgIEJ0ID0gW3h0LCBEdCwgU3QsIE50LCBJdCwgUHQsIGp0LCBNdCwgSHRdO1xuXG4gIGZ1bmN0aW9uIFJ0KHQpIHtcbiAgICByZXR1cm4gdCA/ICh0Lm5vZGVOYW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gV3QodCkge1xuICAgIGlmIChudWxsID09IHQpIHJldHVybiB3aW5kb3c7XG5cbiAgICBpZiAoXCJbb2JqZWN0IFdpbmRvd11cIiAhPT0gdC50b1N0cmluZygpKSB7XG4gICAgICB2YXIgZSA9IHQub3duZXJEb2N1bWVudDtcbiAgICAgIHJldHVybiBlICYmIGUuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9XG5cbiAgZnVuY3Rpb24gJHQodCkge1xuICAgIHJldHVybiB0IGluc3RhbmNlb2YgV3QodCkuRWxlbWVudCB8fCB0IGluc3RhbmNlb2YgRWxlbWVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHp0KHQpIHtcbiAgICByZXR1cm4gdCBpbnN0YW5jZW9mIFd0KHQpLkhUTUxFbGVtZW50IHx8IHQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHF0KHQpIHtcbiAgICByZXR1cm4gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU2hhZG93Um9vdCAmJiAodCBpbnN0YW5jZW9mIFd0KHQpLlNoYWRvd1Jvb3QgfHwgdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpO1xuICB9XG5cbiAgY29uc3QgRnQgPSB7XG4gICAgbmFtZTogXCJhcHBseVN0eWxlc1wiLFxuICAgIGVuYWJsZWQ6ICEwLFxuICAgIHBoYXNlOiBcIndyaXRlXCIsXG4gICAgZm46IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHQuc3RhdGU7XG4gICAgICBPYmplY3Qua2V5cyhlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHZhciBpID0gZS5zdHlsZXNbdF0gfHwge30sXG4gICAgICAgICAgICBuID0gZS5hdHRyaWJ1dGVzW3RdIHx8IHt9LFxuICAgICAgICAgICAgcyA9IGUuZWxlbWVudHNbdF07XG4gICAgICAgIHp0KHMpICYmIFJ0KHMpICYmIChPYmplY3QuYXNzaWduKHMuc3R5bGUsIGkpLCBPYmplY3Qua2V5cyhuKS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIGUgPSBuW3RdO1xuICAgICAgICAgICExID09PSBlID8gcy5yZW1vdmVBdHRyaWJ1dGUodCkgOiBzLnNldEF0dHJpYnV0ZSh0LCAhMCA9PT0gZSA/IFwiXCIgOiBlKTtcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBlZmZlY3Q6IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHQuc3RhdGUsXG4gICAgICAgICAgaSA9IHtcbiAgICAgICAgcG9wcGVyOiB7XG4gICAgICAgICAgcG9zaXRpb246IGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgICAgICBsZWZ0OiBcIjBcIixcbiAgICAgICAgICB0b3A6IFwiMFwiLFxuICAgICAgICAgIG1hcmdpbjogXCIwXCJcbiAgICAgICAgfSxcbiAgICAgICAgYXJyb3c6IHtcbiAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiXG4gICAgICAgIH0sXG4gICAgICAgIHJlZmVyZW5jZToge31cbiAgICAgIH07XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihlLmVsZW1lbnRzLnBvcHBlci5zdHlsZSwgaS5wb3BwZXIpLCBlLnN0eWxlcyA9IGksIGUuZWxlbWVudHMuYXJyb3cgJiYgT2JqZWN0LmFzc2lnbihlLmVsZW1lbnRzLmFycm93LnN0eWxlLCBpLmFycm93KSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBPYmplY3Qua2V5cyhlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdmFyIG4gPSBlLmVsZW1lbnRzW3RdLFxuICAgICAgICAgICAgICBzID0gZS5hdHRyaWJ1dGVzW3RdIHx8IHt9LFxuICAgICAgICAgICAgICBvID0gT2JqZWN0LmtleXMoZS5zdHlsZXMuaGFzT3duUHJvcGVydHkodCkgPyBlLnN0eWxlc1t0XSA6IGlbdF0pLnJlZHVjZShmdW5jdGlvbiAodCwgZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRbZV0gPSBcIlwiLCB0O1xuICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICB6dChuKSAmJiBSdChuKSAmJiAoT2JqZWN0LmFzc2lnbihuLnN0eWxlLCBvKSwgT2JqZWN0LmtleXMocykuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgbi5yZW1vdmVBdHRyaWJ1dGUodCk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSxcbiAgICByZXF1aXJlczogW1wiY29tcHV0ZVN0eWxlc1wiXVxuICB9O1xuXG4gIGZ1bmN0aW9uIFV0KHQpIHtcbiAgICByZXR1cm4gdC5zcGxpdChcIi1cIilbMF07XG4gIH1cblxuICBmdW5jdGlvbiBWdCh0LCBlKSB7XG4gICAgdmFyIGkgPSB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogaS53aWR0aCAvIDEsXG4gICAgICBoZWlnaHQ6IGkuaGVpZ2h0IC8gMSxcbiAgICAgIHRvcDogaS50b3AgLyAxLFxuICAgICAgcmlnaHQ6IGkucmlnaHQgLyAxLFxuICAgICAgYm90dG9tOiBpLmJvdHRvbSAvIDEsXG4gICAgICBsZWZ0OiBpLmxlZnQgLyAxLFxuICAgICAgeDogaS5sZWZ0IC8gMSxcbiAgICAgIHk6IGkudG9wIC8gMVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBLdCh0KSB7XG4gICAgdmFyIGUgPSBWdCh0KSxcbiAgICAgICAgaSA9IHQub2Zmc2V0V2lkdGgsXG4gICAgICAgIG4gPSB0Lm9mZnNldEhlaWdodDtcbiAgICByZXR1cm4gTWF0aC5hYnMoZS53aWR0aCAtIGkpIDw9IDEgJiYgKGkgPSBlLndpZHRoKSwgTWF0aC5hYnMoZS5oZWlnaHQgLSBuKSA8PSAxICYmIChuID0gZS5oZWlnaHQpLCB7XG4gICAgICB4OiB0Lm9mZnNldExlZnQsXG4gICAgICB5OiB0Lm9mZnNldFRvcCxcbiAgICAgIHdpZHRoOiBpLFxuICAgICAgaGVpZ2h0OiBuXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFh0KHQsIGUpIHtcbiAgICB2YXIgaSA9IGUuZ2V0Um9vdE5vZGUgJiYgZS5nZXRSb290Tm9kZSgpO1xuICAgIGlmICh0LmNvbnRhaW5zKGUpKSByZXR1cm4gITA7XG5cbiAgICBpZiAoaSAmJiBxdChpKSkge1xuICAgICAgdmFyIG4gPSBlO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuICYmIHQuaXNTYW1lTm9kZShuKSkgcmV0dXJuICEwO1xuICAgICAgICBuID0gbi5wYXJlbnROb2RlIHx8IG4uaG9zdDtcbiAgICAgIH0gd2hpbGUgKG4pO1xuICAgIH1cblxuICAgIHJldHVybiAhMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFl0KHQpIHtcbiAgICByZXR1cm4gV3QodCkuZ2V0Q29tcHV0ZWRTdHlsZSh0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFF0KHQpIHtcbiAgICByZXR1cm4gW1widGFibGVcIiwgXCJ0ZFwiLCBcInRoXCJdLmluZGV4T2YoUnQodCkpID49IDA7XG4gIH1cblxuICBmdW5jdGlvbiBHdCh0KSB7XG4gICAgcmV0dXJuICgoJHQodCkgPyB0Lm93bmVyRG9jdW1lbnQgOiB0LmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIFp0KHQpIHtcbiAgICByZXR1cm4gXCJodG1sXCIgPT09IFJ0KHQpID8gdCA6IHQuYXNzaWduZWRTbG90IHx8IHQucGFyZW50Tm9kZSB8fCAocXQodCkgPyB0Lmhvc3QgOiBudWxsKSB8fCBHdCh0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEp0KHQpIHtcbiAgICByZXR1cm4genQodCkgJiYgXCJmaXhlZFwiICE9PSBZdCh0KS5wb3NpdGlvbiA/IHQub2Zmc2V0UGFyZW50IDogbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRlKHQpIHtcbiAgICBmb3IgKHZhciBlID0gV3QodCksIGkgPSBKdCh0KTsgaSAmJiBRdChpKSAmJiBcInN0YXRpY1wiID09PSBZdChpKS5wb3NpdGlvbjspIGkgPSBKdChpKTtcblxuICAgIHJldHVybiBpICYmIChcImh0bWxcIiA9PT0gUnQoaSkgfHwgXCJib2R5XCIgPT09IFJ0KGkpICYmIFwic3RhdGljXCIgPT09IFl0KGkpLnBvc2l0aW9uKSA/IGUgOiBpIHx8IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IC0xICE9PSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImZpcmVmb3hcIik7XG4gICAgICBpZiAoLTEgIT09IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIlRyaWRlbnRcIikgJiYgenQodCkgJiYgXCJmaXhlZFwiID09PSBZdCh0KS5wb3NpdGlvbikgcmV0dXJuIG51bGw7XG5cbiAgICAgIGZvciAodmFyIGkgPSBadCh0KTsgenQoaSkgJiYgW1wiaHRtbFwiLCBcImJvZHlcIl0uaW5kZXhPZihSdChpKSkgPCAwOykge1xuICAgICAgICB2YXIgbiA9IFl0KGkpO1xuICAgICAgICBpZiAoXCJub25lXCIgIT09IG4udHJhbnNmb3JtIHx8IFwibm9uZVwiICE9PSBuLnBlcnNwZWN0aXZlIHx8IFwicGFpbnRcIiA9PT0gbi5jb250YWluIHx8IC0xICE9PSBbXCJ0cmFuc2Zvcm1cIiwgXCJwZXJzcGVjdGl2ZVwiXS5pbmRleE9mKG4ud2lsbENoYW5nZSkgfHwgZSAmJiBcImZpbHRlclwiID09PSBuLndpbGxDaGFuZ2UgfHwgZSAmJiBuLmZpbHRlciAmJiBcIm5vbmVcIiAhPT0gbi5maWx0ZXIpIHJldHVybiBpO1xuICAgICAgICBpID0gaS5wYXJlbnROb2RlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KHQpIHx8IGU7XG4gIH1cblxuICBmdW5jdGlvbiBlZSh0KSB7XG4gICAgcmV0dXJuIFtcInRvcFwiLCBcImJvdHRvbVwiXS5pbmRleE9mKHQpID49IDAgPyBcInhcIiA6IFwieVwiO1xuICB9XG5cbiAgdmFyIGllID0gTWF0aC5tYXgsXG4gICAgICBuZSA9IE1hdGgubWluLFxuICAgICAgc2UgPSBNYXRoLnJvdW5kO1xuXG4gIGZ1bmN0aW9uIG9lKHQsIGUsIGkpIHtcbiAgICByZXR1cm4gaWUodCwgbmUoZSwgaSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmUodCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICB0b3A6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIGJvdHRvbTogMCxcbiAgICAgIGxlZnQ6IDBcbiAgICB9LCB0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFlKHQsIGUpIHtcbiAgICByZXR1cm4gZS5yZWR1Y2UoZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgIHJldHVybiBlW2ldID0gdCwgZTtcbiAgICB9LCB7fSk7XG4gIH1cblxuICBjb25zdCBsZSA9IHtcbiAgICBuYW1lOiBcImFycm93XCIsXG4gICAgZW5hYmxlZDogITAsXG4gICAgcGhhc2U6IFwibWFpblwiLFxuICAgIGZuOiBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUsXG4gICAgICAgICAgaSA9IHQuc3RhdGUsXG4gICAgICAgICAgbiA9IHQubmFtZSxcbiAgICAgICAgICBzID0gdC5vcHRpb25zLFxuICAgICAgICAgIG8gPSBpLmVsZW1lbnRzLmFycm93LFxuICAgICAgICAgIHIgPSBpLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyxcbiAgICAgICAgICBhID0gVXQoaS5wbGFjZW1lbnQpLFxuICAgICAgICAgIGwgPSBlZShhKSxcbiAgICAgICAgICBjID0gW2J0LCBfdF0uaW5kZXhPZihhKSA+PSAwID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIjtcblxuICAgICAgaWYgKG8gJiYgcikge1xuICAgICAgICB2YXIgaCA9IGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlKFwibnVtYmVyXCIgIT0gdHlwZW9mICh0ID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiB0ID8gdChPYmplY3QuYXNzaWduKHt9LCBlLnJlY3RzLCB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IGUucGxhY2VtZW50XG4gICAgICAgICAgfSkpIDogdCkgPyB0IDogYWUodCwgeXQpKTtcbiAgICAgICAgfShzLnBhZGRpbmcsIGkpLFxuICAgICAgICAgICAgZCA9IEt0KG8pLFxuICAgICAgICAgICAgdSA9IFwieVwiID09PSBsID8gbXQgOiBidCxcbiAgICAgICAgICAgIGYgPSBcInlcIiA9PT0gbCA/IGd0IDogX3QsXG4gICAgICAgICAgICBwID0gaS5yZWN0cy5yZWZlcmVuY2VbY10gKyBpLnJlY3RzLnJlZmVyZW5jZVtsXSAtIHJbbF0gLSBpLnJlY3RzLnBvcHBlcltjXSxcbiAgICAgICAgICAgIG0gPSByW2xdIC0gaS5yZWN0cy5yZWZlcmVuY2VbbF0sXG4gICAgICAgICAgICBnID0gdGUobyksXG4gICAgICAgICAgICBfID0gZyA/IFwieVwiID09PSBsID8gZy5jbGllbnRIZWlnaHQgfHwgMCA6IGcuY2xpZW50V2lkdGggfHwgMCA6IDAsXG4gICAgICAgICAgICBiID0gcCAvIDIgLSBtIC8gMixcbiAgICAgICAgICAgIHYgPSBoW3VdLFxuICAgICAgICAgICAgeSA9IF8gLSBkW2NdIC0gaFtmXSxcbiAgICAgICAgICAgIHcgPSBfIC8gMiAtIGRbY10gLyAyICsgYixcbiAgICAgICAgICAgIEUgPSBvZSh2LCB3LCB5KSxcbiAgICAgICAgICAgIEEgPSBsO1xuXG4gICAgICAgIGkubW9kaWZpZXJzRGF0YVtuXSA9ICgoZSA9IHt9KVtBXSA9IEUsIGUuY2VudGVyT2Zmc2V0ID0gRSAtIHcsIGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZWZmZWN0OiBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0LnN0YXRlLFxuICAgICAgICAgIGkgPSB0Lm9wdGlvbnMuZWxlbWVudCxcbiAgICAgICAgICBuID0gdm9pZCAwID09PSBpID8gXCJbZGF0YS1wb3BwZXItYXJyb3ddXCIgOiBpO1xuICAgICAgbnVsbCAhPSBuICYmIChcInN0cmluZ1wiICE9IHR5cGVvZiBuIHx8IChuID0gZS5lbGVtZW50cy5wb3BwZXIucXVlcnlTZWxlY3RvcihuKSkpICYmIFh0KGUuZWxlbWVudHMucG9wcGVyLCBuKSAmJiAoZS5lbGVtZW50cy5hcnJvdyA9IG4pO1xuICAgIH0sXG4gICAgcmVxdWlyZXM6IFtcInBvcHBlck9mZnNldHNcIl0sXG4gICAgcmVxdWlyZXNJZkV4aXN0czogW1wicHJldmVudE92ZXJmbG93XCJdXG4gIH07XG5cbiAgZnVuY3Rpb24gY2UodCkge1xuICAgIHJldHVybiB0LnNwbGl0KFwiLVwiKVsxXTtcbiAgfVxuXG4gIHZhciBoZSA9IHtcbiAgICB0b3A6IFwiYXV0b1wiLFxuICAgIHJpZ2h0OiBcImF1dG9cIixcbiAgICBib3R0b206IFwiYXV0b1wiLFxuICAgIGxlZnQ6IFwiYXV0b1wiXG4gIH07XG5cbiAgZnVuY3Rpb24gZGUodCkge1xuICAgIHZhciBlLFxuICAgICAgICBpID0gdC5wb3BwZXIsXG4gICAgICAgIG4gPSB0LnBvcHBlclJlY3QsXG4gICAgICAgIHMgPSB0LnBsYWNlbWVudCxcbiAgICAgICAgbyA9IHQudmFyaWF0aW9uLFxuICAgICAgICByID0gdC5vZmZzZXRzLFxuICAgICAgICBhID0gdC5wb3NpdGlvbixcbiAgICAgICAgbCA9IHQuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgICBjID0gdC5hZGFwdGl2ZSxcbiAgICAgICAgaCA9IHQucm91bmRPZmZzZXRzLFxuICAgICAgICBkID0gITAgPT09IGggPyBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0LngsXG4gICAgICAgICAgaSA9IHQueSxcbiAgICAgICAgICBuID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHNlKHNlKGUgKiBuKSAvIG4pIHx8IDAsXG4gICAgICAgIHk6IHNlKHNlKGkgKiBuKSAvIG4pIHx8IDBcbiAgICAgIH07XG4gICAgfShyKSA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaCA/IGgocikgOiByLFxuICAgICAgICB1ID0gZC54LFxuICAgICAgICBmID0gdm9pZCAwID09PSB1ID8gMCA6IHUsXG4gICAgICAgIHAgPSBkLnksXG4gICAgICAgIG0gPSB2b2lkIDAgPT09IHAgPyAwIDogcCxcbiAgICAgICAgZyA9IHIuaGFzT3duUHJvcGVydHkoXCJ4XCIpLFxuICAgICAgICBfID0gci5oYXNPd25Qcm9wZXJ0eShcInlcIiksXG4gICAgICAgIGIgPSBidCxcbiAgICAgICAgdiA9IG10LFxuICAgICAgICB5ID0gd2luZG93O1xuXG4gICAgaWYgKGMpIHtcbiAgICAgIHZhciB3ID0gdGUoaSksXG4gICAgICAgICAgRSA9IFwiY2xpZW50SGVpZ2h0XCIsXG4gICAgICAgICAgQSA9IFwiY2xpZW50V2lkdGhcIjtcbiAgICAgIHcgPT09IFd0KGkpICYmIFwic3RhdGljXCIgIT09IFl0KHcgPSBHdChpKSkucG9zaXRpb24gJiYgXCJhYnNvbHV0ZVwiID09PSBhICYmIChFID0gXCJzY3JvbGxIZWlnaHRcIiwgQSA9IFwic2Nyb2xsV2lkdGhcIiksIHcgPSB3LCBzICE9PSBtdCAmJiAocyAhPT0gYnQgJiYgcyAhPT0gX3QgfHwgbyAhPT0gRXQpIHx8ICh2ID0gZ3QsIG0gLT0gd1tFXSAtIG4uaGVpZ2h0LCBtICo9IGwgPyAxIDogLTEpLCBzICE9PSBidCAmJiAocyAhPT0gbXQgJiYgcyAhPT0gZ3QgfHwgbyAhPT0gRXQpIHx8IChiID0gX3QsIGYgLT0gd1tBXSAtIG4ud2lkdGgsIGYgKj0gbCA/IDEgOiAtMSk7XG4gICAgfVxuXG4gICAgdmFyIFQsXG4gICAgICAgIE8gPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHBvc2l0aW9uOiBhXG4gICAgfSwgYyAmJiBoZSk7XG4gICAgcmV0dXJuIGwgPyBPYmplY3QuYXNzaWduKHt9LCBPLCAoKFQgPSB7fSlbdl0gPSBfID8gXCIwXCIgOiBcIlwiLCBUW2JdID0gZyA/IFwiMFwiIDogXCJcIiwgVC50cmFuc2Zvcm0gPSAoeS5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIDw9IDEgPyBcInRyYW5zbGF0ZShcIiArIGYgKyBcInB4LCBcIiArIG0gKyBcInB4KVwiIDogXCJ0cmFuc2xhdGUzZChcIiArIGYgKyBcInB4LCBcIiArIG0gKyBcInB4LCAwKVwiLCBUKSkgOiBPYmplY3QuYXNzaWduKHt9LCBPLCAoKGUgPSB7fSlbdl0gPSBfID8gbSArIFwicHhcIiA6IFwiXCIsIGVbYl0gPSBnID8gZiArIFwicHhcIiA6IFwiXCIsIGUudHJhbnNmb3JtID0gXCJcIiwgZSkpO1xuICB9XG5cbiAgY29uc3QgdWUgPSB7XG4gICAgbmFtZTogXCJjb21wdXRlU3R5bGVzXCIsXG4gICAgZW5hYmxlZDogITAsXG4gICAgcGhhc2U6IFwiYmVmb3JlV3JpdGVcIixcbiAgICBmbjogZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdC5zdGF0ZSxcbiAgICAgICAgICBpID0gdC5vcHRpb25zLFxuICAgICAgICAgIG4gPSBpLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgICAgICBzID0gdm9pZCAwID09PSBuIHx8IG4sXG4gICAgICAgICAgbyA9IGkuYWRhcHRpdmUsXG4gICAgICAgICAgciA9IHZvaWQgMCA9PT0gbyB8fCBvLFxuICAgICAgICAgIGEgPSBpLnJvdW5kT2Zmc2V0cyxcbiAgICAgICAgICBsID0gdm9pZCAwID09PSBhIHx8IGEsXG4gICAgICAgICAgYyA9IHtcbiAgICAgICAgcGxhY2VtZW50OiBVdChlLnBsYWNlbWVudCksXG4gICAgICAgIHZhcmlhdGlvbjogY2UoZS5wbGFjZW1lbnQpLFxuICAgICAgICBwb3BwZXI6IGUuZWxlbWVudHMucG9wcGVyLFxuICAgICAgICBwb3BwZXJSZWN0OiBlLnJlY3RzLnBvcHBlcixcbiAgICAgICAgZ3B1QWNjZWxlcmF0aW9uOiBzXG4gICAgICB9O1xuICAgICAgbnVsbCAhPSBlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAmJiAoZS5zdHlsZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgZS5zdHlsZXMucG9wcGVyLCBkZShPYmplY3QuYXNzaWduKHt9LCBjLCB7XG4gICAgICAgIG9mZnNldHM6IGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLFxuICAgICAgICBwb3NpdGlvbjogZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgICBhZGFwdGl2ZTogcixcbiAgICAgICAgcm91bmRPZmZzZXRzOiBsXG4gICAgICB9KSkpKSwgbnVsbCAhPSBlLm1vZGlmaWVyc0RhdGEuYXJyb3cgJiYgKGUuc3R5bGVzLmFycm93ID0gT2JqZWN0LmFzc2lnbih7fSwgZS5zdHlsZXMuYXJyb3csIGRlKE9iamVjdC5hc3NpZ24oe30sIGMsIHtcbiAgICAgICAgb2Zmc2V0czogZS5tb2RpZmllcnNEYXRhLmFycm93LFxuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICBhZGFwdGl2ZTogITEsXG4gICAgICAgIHJvdW5kT2Zmc2V0czogbFxuICAgICAgfSkpKSksIGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgICAgIFwiZGF0YS1wb3BwZXItcGxhY2VtZW50XCI6IGUucGxhY2VtZW50XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRhdGE6IHt9XG4gIH07XG4gIHZhciBmZSA9IHtcbiAgICBwYXNzaXZlOiAhMFxuICB9O1xuICBjb25zdCBwZSA9IHtcbiAgICBuYW1lOiBcImV2ZW50TGlzdGVuZXJzXCIsXG4gICAgZW5hYmxlZDogITAsXG4gICAgcGhhc2U6IFwid3JpdGVcIixcbiAgICBmbjogZnVuY3Rpb24gKCkge30sXG4gICAgZWZmZWN0OiBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0LnN0YXRlLFxuICAgICAgICAgIGkgPSB0Lmluc3RhbmNlLFxuICAgICAgICAgIG4gPSB0Lm9wdGlvbnMsXG4gICAgICAgICAgcyA9IG4uc2Nyb2xsLFxuICAgICAgICAgIG8gPSB2b2lkIDAgPT09IHMgfHwgcyxcbiAgICAgICAgICByID0gbi5yZXNpemUsXG4gICAgICAgICAgYSA9IHZvaWQgMCA9PT0gciB8fCByLFxuICAgICAgICAgIGwgPSBXdChlLmVsZW1lbnRzLnBvcHBlciksXG4gICAgICAgICAgYyA9IFtdLmNvbmNhdChlLnNjcm9sbFBhcmVudHMucmVmZXJlbmNlLCBlLnNjcm9sbFBhcmVudHMucG9wcGVyKTtcbiAgICAgIHJldHVybiBvICYmIGMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICB0LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaS51cGRhdGUsIGZlKTtcbiAgICAgIH0pLCBhICYmIGwuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBpLnVwZGF0ZSwgZmUpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG8gJiYgYy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgdC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGkudXBkYXRlLCBmZSk7XG4gICAgICAgIH0pLCBhICYmIGwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBpLnVwZGF0ZSwgZmUpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIGRhdGE6IHt9XG4gIH07XG4gIHZhciBtZSA9IHtcbiAgICBsZWZ0OiBcInJpZ2h0XCIsXG4gICAgcmlnaHQ6IFwibGVmdFwiLFxuICAgIGJvdHRvbTogXCJ0b3BcIixcbiAgICB0b3A6IFwiYm90dG9tXCJcbiAgfTtcblxuICBmdW5jdGlvbiBnZSh0KSB7XG4gICAgcmV0dXJuIHQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gbWVbdF07XG4gICAgfSk7XG4gIH1cblxuICB2YXIgX2UgPSB7XG4gICAgc3RhcnQ6IFwiZW5kXCIsXG4gICAgZW5kOiBcInN0YXJ0XCJcbiAgfTtcblxuICBmdW5jdGlvbiBiZSh0KSB7XG4gICAgcmV0dXJuIHQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gX2VbdF07XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB2ZSh0KSB7XG4gICAgdmFyIGUgPSBXdCh0KTtcbiAgICByZXR1cm4ge1xuICAgICAgc2Nyb2xsTGVmdDogZS5wYWdlWE9mZnNldCxcbiAgICAgIHNjcm9sbFRvcDogZS5wYWdlWU9mZnNldFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB5ZSh0KSB7XG4gICAgcmV0dXJuIFZ0KEd0KHQpKS5sZWZ0ICsgdmUodCkuc2Nyb2xsTGVmdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdlKHQpIHtcbiAgICB2YXIgZSA9IFl0KHQpLFxuICAgICAgICBpID0gZS5vdmVyZmxvdyxcbiAgICAgICAgbiA9IGUub3ZlcmZsb3dYLFxuICAgICAgICBzID0gZS5vdmVyZmxvd1k7XG4gICAgcmV0dXJuIC9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbi8udGVzdChpICsgcyArIG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gRWUodCkge1xuICAgIHJldHVybiBbXCJodG1sXCIsIFwiYm9keVwiLCBcIiNkb2N1bWVudFwiXS5pbmRleE9mKFJ0KHQpKSA+PSAwID8gdC5vd25lckRvY3VtZW50LmJvZHkgOiB6dCh0KSAmJiB3ZSh0KSA/IHQgOiBFZShadCh0KSk7XG4gIH1cblxuICBmdW5jdGlvbiBBZSh0LCBlKSB7XG4gICAgdmFyIGk7XG4gICAgdm9pZCAwID09PSBlICYmIChlID0gW10pO1xuICAgIHZhciBuID0gRWUodCksXG4gICAgICAgIHMgPSBuID09PSAobnVsbCA9PSAoaSA9IHQub3duZXJEb2N1bWVudCkgPyB2b2lkIDAgOiBpLmJvZHkpLFxuICAgICAgICBvID0gV3QobiksXG4gICAgICAgIHIgPSBzID8gW29dLmNvbmNhdChvLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCB3ZShuKSA/IG4gOiBbXSkgOiBuLFxuICAgICAgICBhID0gZS5jb25jYXQocik7XG4gICAgcmV0dXJuIHMgPyBhIDogYS5jb25jYXQoQWUoWnQocikpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFRlKHQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdCwge1xuICAgICAgbGVmdDogdC54LFxuICAgICAgdG9wOiB0LnksXG4gICAgICByaWdodDogdC54ICsgdC53aWR0aCxcbiAgICAgIGJvdHRvbTogdC55ICsgdC5oZWlnaHRcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIE9lKHQsIGUpIHtcbiAgICByZXR1cm4gZSA9PT0gVHQgPyBUZShmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSBXdCh0KSxcbiAgICAgICAgICBpID0gR3QodCksXG4gICAgICAgICAgbiA9IGUudmlzdWFsVmlld3BvcnQsXG4gICAgICAgICAgcyA9IGkuY2xpZW50V2lkdGgsXG4gICAgICAgICAgbyA9IGkuY2xpZW50SGVpZ2h0LFxuICAgICAgICAgIHIgPSAwLFxuICAgICAgICAgIGEgPSAwO1xuICAgICAgcmV0dXJuIG4gJiYgKHMgPSBuLndpZHRoLCBvID0gbi5oZWlnaHQsIC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgKHIgPSBuLm9mZnNldExlZnQsIGEgPSBuLm9mZnNldFRvcCkpLCB7XG4gICAgICAgIHdpZHRoOiBzLFxuICAgICAgICBoZWlnaHQ6IG8sXG4gICAgICAgIHg6IHIgKyB5ZSh0KSxcbiAgICAgICAgeTogYVxuICAgICAgfTtcbiAgICB9KHQpKSA6IHp0KGUpID8gZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gVnQodCk7XG4gICAgICByZXR1cm4gZS50b3AgPSBlLnRvcCArIHQuY2xpZW50VG9wLCBlLmxlZnQgPSBlLmxlZnQgKyB0LmNsaWVudExlZnQsIGUuYm90dG9tID0gZS50b3AgKyB0LmNsaWVudEhlaWdodCwgZS5yaWdodCA9IGUubGVmdCArIHQuY2xpZW50V2lkdGgsIGUud2lkdGggPSB0LmNsaWVudFdpZHRoLCBlLmhlaWdodCA9IHQuY2xpZW50SGVpZ2h0LCBlLnggPSBlLmxlZnQsIGUueSA9IGUudG9wLCBlO1xuICAgIH0oZSkgOiBUZShmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUsXG4gICAgICAgICAgaSA9IEd0KHQpLFxuICAgICAgICAgIG4gPSB2ZSh0KSxcbiAgICAgICAgICBzID0gbnVsbCA9PSAoZSA9IHQub3duZXJEb2N1bWVudCkgPyB2b2lkIDAgOiBlLmJvZHksXG4gICAgICAgICAgbyA9IGllKGkuc2Nyb2xsV2lkdGgsIGkuY2xpZW50V2lkdGgsIHMgPyBzLnNjcm9sbFdpZHRoIDogMCwgcyA/IHMuY2xpZW50V2lkdGggOiAwKSxcbiAgICAgICAgICByID0gaWUoaS5zY3JvbGxIZWlnaHQsIGkuY2xpZW50SGVpZ2h0LCBzID8gcy5zY3JvbGxIZWlnaHQgOiAwLCBzID8gcy5jbGllbnRIZWlnaHQgOiAwKSxcbiAgICAgICAgICBhID0gLW4uc2Nyb2xsTGVmdCArIHllKHQpLFxuICAgICAgICAgIGwgPSAtbi5zY3JvbGxUb3A7XG4gICAgICByZXR1cm4gXCJydGxcIiA9PT0gWXQocyB8fCBpKS5kaXJlY3Rpb24gJiYgKGEgKz0gaWUoaS5jbGllbnRXaWR0aCwgcyA/IHMuY2xpZW50V2lkdGggOiAwKSAtIG8pLCB7XG4gICAgICAgIHdpZHRoOiBvLFxuICAgICAgICBoZWlnaHQ6IHIsXG4gICAgICAgIHg6IGEsXG4gICAgICAgIHk6IGxcbiAgICAgIH07XG4gICAgfShHdCh0KSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gQ2UodCkge1xuICAgIHZhciBlLFxuICAgICAgICBpID0gdC5yZWZlcmVuY2UsXG4gICAgICAgIG4gPSB0LmVsZW1lbnQsXG4gICAgICAgIHMgPSB0LnBsYWNlbWVudCxcbiAgICAgICAgbyA9IHMgPyBVdChzKSA6IG51bGwsXG4gICAgICAgIHIgPSBzID8gY2UocykgOiBudWxsLFxuICAgICAgICBhID0gaS54ICsgaS53aWR0aCAvIDIgLSBuLndpZHRoIC8gMixcbiAgICAgICAgbCA9IGkueSArIGkuaGVpZ2h0IC8gMiAtIG4uaGVpZ2h0IC8gMjtcblxuICAgIHN3aXRjaCAobykge1xuICAgICAgY2FzZSBtdDpcbiAgICAgICAgZSA9IHtcbiAgICAgICAgICB4OiBhLFxuICAgICAgICAgIHk6IGkueSAtIG4uaGVpZ2h0XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIGd0OlxuICAgICAgICBlID0ge1xuICAgICAgICAgIHg6IGEsXG4gICAgICAgICAgeTogaS55ICsgaS5oZWlnaHRcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgX3Q6XG4gICAgICAgIGUgPSB7XG4gICAgICAgICAgeDogaS54ICsgaS53aWR0aCxcbiAgICAgICAgICB5OiBsXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIGJ0OlxuICAgICAgICBlID0ge1xuICAgICAgICAgIHg6IGkueCAtIG4ud2lkdGgsXG4gICAgICAgICAgeTogbFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZSA9IHtcbiAgICAgICAgICB4OiBpLngsXG4gICAgICAgICAgeTogaS55XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGMgPSBvID8gZWUobykgOiBudWxsO1xuXG4gICAgaWYgKG51bGwgIT0gYykge1xuICAgICAgdmFyIGggPSBcInlcIiA9PT0gYyA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCI7XG5cbiAgICAgIHN3aXRjaCAocikge1xuICAgICAgICBjYXNlIHd0OlxuICAgICAgICAgIGVbY10gPSBlW2NdIC0gKGlbaF0gLyAyIC0gbltoXSAvIDIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgRXQ6XG4gICAgICAgICAgZVtjXSA9IGVbY10gKyAoaVtoXSAvIDIgLSBuW2hdIC8gMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGU7XG4gIH1cblxuICBmdW5jdGlvbiBrZSh0LCBlKSB7XG4gICAgdm9pZCAwID09PSBlICYmIChlID0ge30pO1xuXG4gICAgdmFyIGkgPSBlLFxuICAgICAgICBuID0gaS5wbGFjZW1lbnQsXG4gICAgICAgIHMgPSB2b2lkIDAgPT09IG4gPyB0LnBsYWNlbWVudCA6IG4sXG4gICAgICAgIG8gPSBpLmJvdW5kYXJ5LFxuICAgICAgICByID0gdm9pZCAwID09PSBvID8gQXQgOiBvLFxuICAgICAgICBhID0gaS5yb290Qm91bmRhcnksXG4gICAgICAgIGwgPSB2b2lkIDAgPT09IGEgPyBUdCA6IGEsXG4gICAgICAgIGMgPSBpLmVsZW1lbnRDb250ZXh0LFxuICAgICAgICBoID0gdm9pZCAwID09PSBjID8gT3QgOiBjLFxuICAgICAgICBkID0gaS5hbHRCb3VuZGFyeSxcbiAgICAgICAgdSA9IHZvaWQgMCAhPT0gZCAmJiBkLFxuICAgICAgICBmID0gaS5wYWRkaW5nLFxuICAgICAgICBwID0gdm9pZCAwID09PSBmID8gMCA6IGYsXG4gICAgICAgIG0gPSByZShcIm51bWJlclwiICE9IHR5cGVvZiBwID8gcCA6IGFlKHAsIHl0KSksXG4gICAgICAgIGcgPSBoID09PSBPdCA/IEN0IDogT3QsXG4gICAgICAgIF8gPSB0LnJlY3RzLnBvcHBlcixcbiAgICAgICAgYiA9IHQuZWxlbWVudHNbdSA/IGcgOiBoXSxcbiAgICAgICAgdiA9IGZ1bmN0aW9uICh0LCBlLCBpKSB7XG4gICAgICB2YXIgbiA9IFwiY2xpcHBpbmdQYXJlbnRzXCIgPT09IGUgPyBmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IEFlKFp0KHQpKSxcbiAgICAgICAgICAgIGkgPSBbXCJhYnNvbHV0ZVwiLCBcImZpeGVkXCJdLmluZGV4T2YoWXQodCkucG9zaXRpb24pID49IDAgJiYgenQodCkgPyB0ZSh0KSA6IHQ7XG4gICAgICAgIHJldHVybiAkdChpKSA/IGUuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuICR0KHQpICYmIFh0KHQsIGkpICYmIFwiYm9keVwiICE9PSBSdCh0KTtcbiAgICAgICAgfSkgOiBbXTtcbiAgICAgIH0odCkgOiBbXS5jb25jYXQoZSksXG4gICAgICAgICAgcyA9IFtdLmNvbmNhdChuLCBbaV0pLFxuICAgICAgICAgIG8gPSBzWzBdLFxuICAgICAgICAgIHIgPSBzLnJlZHVjZShmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICB2YXIgbiA9IE9lKHQsIGkpO1xuICAgICAgICByZXR1cm4gZS50b3AgPSBpZShuLnRvcCwgZS50b3ApLCBlLnJpZ2h0ID0gbmUobi5yaWdodCwgZS5yaWdodCksIGUuYm90dG9tID0gbmUobi5ib3R0b20sIGUuYm90dG9tKSwgZS5sZWZ0ID0gaWUobi5sZWZ0LCBlLmxlZnQpLCBlO1xuICAgICAgfSwgT2UodCwgbykpO1xuICAgICAgcmV0dXJuIHIud2lkdGggPSByLnJpZ2h0IC0gci5sZWZ0LCByLmhlaWdodCA9IHIuYm90dG9tIC0gci50b3AsIHIueCA9IHIubGVmdCwgci55ID0gci50b3AsIHI7XG4gICAgfSgkdChiKSA/IGIgOiBiLmNvbnRleHRFbGVtZW50IHx8IEd0KHQuZWxlbWVudHMucG9wcGVyKSwgciwgbCksXG4gICAgICAgIHkgPSBWdCh0LmVsZW1lbnRzLnJlZmVyZW5jZSksXG4gICAgICAgIHcgPSBDZSh7XG4gICAgICByZWZlcmVuY2U6IHksXG4gICAgICBlbGVtZW50OiBfLFxuICAgICAgc3RyYXRlZ3k6IFwiYWJzb2x1dGVcIixcbiAgICAgIHBsYWNlbWVudDogc1xuICAgIH0pLFxuICAgICAgICBFID0gVGUoT2JqZWN0LmFzc2lnbih7fSwgXywgdykpLFxuICAgICAgICBBID0gaCA9PT0gT3QgPyBFIDogeSxcbiAgICAgICAgVCA9IHtcbiAgICAgIHRvcDogdi50b3AgLSBBLnRvcCArIG0udG9wLFxuICAgICAgYm90dG9tOiBBLmJvdHRvbSAtIHYuYm90dG9tICsgbS5ib3R0b20sXG4gICAgICBsZWZ0OiB2LmxlZnQgLSBBLmxlZnQgKyBtLmxlZnQsXG4gICAgICByaWdodDogQS5yaWdodCAtIHYucmlnaHQgKyBtLnJpZ2h0XG4gICAgfSxcbiAgICAgICAgTyA9IHQubW9kaWZpZXJzRGF0YS5vZmZzZXQ7XG5cbiAgICBpZiAoaCA9PT0gT3QgJiYgTykge1xuICAgICAgdmFyIEMgPSBPW3NdO1xuICAgICAgT2JqZWN0LmtleXMoVCkuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICB2YXIgZSA9IFtfdCwgZ3RdLmluZGV4T2YodCkgPj0gMCA/IDEgOiAtMSxcbiAgICAgICAgICAgIGkgPSBbbXQsIGd0XS5pbmRleE9mKHQpID49IDAgPyBcInlcIiA6IFwieFwiO1xuICAgICAgICBUW3RdICs9IENbaV0gKiBlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFQ7XG4gIH1cblxuICBmdW5jdGlvbiBMZSh0LCBlKSB7XG4gICAgdm9pZCAwID09PSBlICYmIChlID0ge30pO1xuICAgIHZhciBpID0gZSxcbiAgICAgICAgbiA9IGkucGxhY2VtZW50LFxuICAgICAgICBzID0gaS5ib3VuZGFyeSxcbiAgICAgICAgbyA9IGkucm9vdEJvdW5kYXJ5LFxuICAgICAgICByID0gaS5wYWRkaW5nLFxuICAgICAgICBhID0gaS5mbGlwVmFyaWF0aW9ucyxcbiAgICAgICAgbCA9IGkuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLFxuICAgICAgICBjID0gdm9pZCAwID09PSBsID8gTHQgOiBsLFxuICAgICAgICBoID0gY2UobiksXG4gICAgICAgIGQgPSBoID8gYSA/IGt0IDoga3QuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gY2UodCkgPT09IGg7XG4gICAgfSkgOiB5dCxcbiAgICAgICAgdSA9IGQuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gYy5pbmRleE9mKHQpID49IDA7XG4gICAgfSk7XG4gICAgMCA9PT0gdS5sZW5ndGggJiYgKHUgPSBkKTtcbiAgICB2YXIgZiA9IHUucmVkdWNlKGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICByZXR1cm4gZVtpXSA9IGtlKHQsIHtcbiAgICAgICAgcGxhY2VtZW50OiBpLFxuICAgICAgICBib3VuZGFyeTogcyxcbiAgICAgICAgcm9vdEJvdW5kYXJ5OiBvLFxuICAgICAgICBwYWRkaW5nOiByXG4gICAgICB9KVtVdChpKV0sIGU7XG4gICAgfSwge30pO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhmKS5zb3J0KGZ1bmN0aW9uICh0LCBlKSB7XG4gICAgICByZXR1cm4gZlt0XSAtIGZbZV07XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCB4ZSA9IHtcbiAgICBuYW1lOiBcImZsaXBcIixcbiAgICBlbmFibGVkOiAhMCxcbiAgICBwaGFzZTogXCJtYWluXCIsXG4gICAgZm46IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHQuc3RhdGUsXG4gICAgICAgICAgaSA9IHQub3B0aW9ucyxcbiAgICAgICAgICBuID0gdC5uYW1lO1xuXG4gICAgICBpZiAoIWUubW9kaWZpZXJzRGF0YVtuXS5fc2tpcCkge1xuICAgICAgICBmb3IgKHZhciBzID0gaS5tYWluQXhpcywgbyA9IHZvaWQgMCA9PT0gcyB8fCBzLCByID0gaS5hbHRBeGlzLCBhID0gdm9pZCAwID09PSByIHx8IHIsIGwgPSBpLmZhbGxiYWNrUGxhY2VtZW50cywgYyA9IGkucGFkZGluZywgaCA9IGkuYm91bmRhcnksIGQgPSBpLnJvb3RCb3VuZGFyeSwgdSA9IGkuYWx0Qm91bmRhcnksIGYgPSBpLmZsaXBWYXJpYXRpb25zLCBwID0gdm9pZCAwID09PSBmIHx8IGYsIG0gPSBpLmFsbG93ZWRBdXRvUGxhY2VtZW50cywgZyA9IGUub3B0aW9ucy5wbGFjZW1lbnQsIF8gPSBVdChnKSwgYiA9IGwgfHwgKF8gIT09IGcgJiYgcCA/IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaWYgKFV0KHQpID09PSB2dCkgcmV0dXJuIFtdO1xuICAgICAgICAgIHZhciBlID0gZ2UodCk7XG4gICAgICAgICAgcmV0dXJuIFtiZSh0KSwgZSwgYmUoZSldO1xuICAgICAgICB9KGcpIDogW2dlKGcpXSksIHYgPSBbZ10uY29uY2F0KGIpLnJlZHVjZShmdW5jdGlvbiAodCwgaSkge1xuICAgICAgICAgIHJldHVybiB0LmNvbmNhdChVdChpKSA9PT0gdnQgPyBMZShlLCB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IGksXG4gICAgICAgICAgICBib3VuZGFyeTogaCxcbiAgICAgICAgICAgIHJvb3RCb3VuZGFyeTogZCxcbiAgICAgICAgICAgIHBhZGRpbmc6IGMsXG4gICAgICAgICAgICBmbGlwVmFyaWF0aW9uczogcCxcbiAgICAgICAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50czogbVxuICAgICAgICAgIH0pIDogaSk7XG4gICAgICAgIH0sIFtdKSwgeSA9IGUucmVjdHMucmVmZXJlbmNlLCB3ID0gZS5yZWN0cy5wb3BwZXIsIEUgPSBuZXcgTWFwKCksIEEgPSAhMCwgVCA9IHZbMF0sIE8gPSAwOyBPIDwgdi5sZW5ndGg7IE8rKykge1xuICAgICAgICAgIHZhciBDID0gdltPXSxcbiAgICAgICAgICAgICAgayA9IFV0KEMpLFxuICAgICAgICAgICAgICBMID0gY2UoQykgPT09IHd0LFxuICAgICAgICAgICAgICB4ID0gW210LCBndF0uaW5kZXhPZihrKSA+PSAwLFxuICAgICAgICAgICAgICBEID0geCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCIsXG4gICAgICAgICAgICAgIFMgPSBrZShlLCB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IEMsXG4gICAgICAgICAgICBib3VuZGFyeTogaCxcbiAgICAgICAgICAgIHJvb3RCb3VuZGFyeTogZCxcbiAgICAgICAgICAgIGFsdEJvdW5kYXJ5OiB1LFxuICAgICAgICAgICAgcGFkZGluZzogY1xuICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBOID0geCA/IEwgPyBfdCA6IGJ0IDogTCA/IGd0IDogbXQ7XG4gICAgICAgICAgeVtEXSA+IHdbRF0gJiYgKE4gPSBnZShOKSk7XG4gICAgICAgICAgdmFyIEkgPSBnZShOKSxcbiAgICAgICAgICAgICAgUCA9IFtdO1xuXG4gICAgICAgICAgaWYgKG8gJiYgUC5wdXNoKFNba10gPD0gMCksIGEgJiYgUC5wdXNoKFNbTl0gPD0gMCwgU1tJXSA8PSAwKSwgUC5ldmVyeShmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIFQgPSBDLCBBID0gITE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBFLnNldChDLCBQKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBKSBmb3IgKHZhciBqID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICB2YXIgZSA9IHYuZmluZChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGkgPSBFLmdldChlKTtcbiAgICAgICAgICAgIGlmIChpKSByZXR1cm4gaS5zbGljZSgwLCB0KS5ldmVyeShmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChlKSByZXR1cm4gVCA9IGUsIFwiYnJlYWtcIjtcbiAgICAgICAgfSwgTSA9IHAgPyAzIDogMTsgTSA+IDAgJiYgXCJicmVha1wiICE9PSBqKE0pOyBNLS0pO1xuICAgICAgICBlLnBsYWNlbWVudCAhPT0gVCAmJiAoZS5tb2RpZmllcnNEYXRhW25dLl9za2lwID0gITAsIGUucGxhY2VtZW50ID0gVCwgZS5yZXNldCA9ICEwKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlcXVpcmVzSWZFeGlzdHM6IFtcIm9mZnNldFwiXSxcbiAgICBkYXRhOiB7XG4gICAgICBfc2tpcDogITFcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gRGUodCwgZSwgaSkge1xuICAgIHJldHVybiB2b2lkIDAgPT09IGkgJiYgKGkgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH0pLCB7XG4gICAgICB0b3A6IHQudG9wIC0gZS5oZWlnaHQgLSBpLnksXG4gICAgICByaWdodDogdC5yaWdodCAtIGUud2lkdGggKyBpLngsXG4gICAgICBib3R0b206IHQuYm90dG9tIC0gZS5oZWlnaHQgKyBpLnksXG4gICAgICBsZWZ0OiB0LmxlZnQgLSBlLndpZHRoIC0gaS54XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFNlKHQpIHtcbiAgICByZXR1cm4gW210LCBfdCwgZ3QsIGJ0XS5zb21lKGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gdFtlXSA+PSAwO1xuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgTmUgPSB7XG4gICAgbmFtZTogXCJoaWRlXCIsXG4gICAgZW5hYmxlZDogITAsXG4gICAgcGhhc2U6IFwibWFpblwiLFxuICAgIHJlcXVpcmVzSWZFeGlzdHM6IFtcInByZXZlbnRPdmVyZmxvd1wiXSxcbiAgICBmbjogZnVuY3Rpb24gKHQpIHtcbiAgICAgIHZhciBlID0gdC5zdGF0ZSxcbiAgICAgICAgICBpID0gdC5uYW1lLFxuICAgICAgICAgIG4gPSBlLnJlY3RzLnJlZmVyZW5jZSxcbiAgICAgICAgICBzID0gZS5yZWN0cy5wb3BwZXIsXG4gICAgICAgICAgbyA9IGUubW9kaWZpZXJzRGF0YS5wcmV2ZW50T3ZlcmZsb3csXG4gICAgICAgICAgciA9IGtlKGUsIHtcbiAgICAgICAgZWxlbWVudENvbnRleHQ6IFwicmVmZXJlbmNlXCJcbiAgICAgIH0pLFxuICAgICAgICAgIGEgPSBrZShlLCB7XG4gICAgICAgIGFsdEJvdW5kYXJ5OiAhMFxuICAgICAgfSksXG4gICAgICAgICAgbCA9IERlKHIsIG4pLFxuICAgICAgICAgIGMgPSBEZShhLCBzLCBvKSxcbiAgICAgICAgICBoID0gU2UobCksXG4gICAgICAgICAgZCA9IFNlKGMpO1xuICAgICAgZS5tb2RpZmllcnNEYXRhW2ldID0ge1xuICAgICAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHM6IGwsXG4gICAgICAgIHBvcHBlckVzY2FwZU9mZnNldHM6IGMsXG4gICAgICAgIGlzUmVmZXJlbmNlSGlkZGVuOiBoLFxuICAgICAgICBoYXNQb3BwZXJFc2NhcGVkOiBkXG4gICAgICB9LCBlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICAgICBcImRhdGEtcG9wcGVyLXJlZmVyZW5jZS1oaWRkZW5cIjogaCxcbiAgICAgICAgXCJkYXRhLXBvcHBlci1lc2NhcGVkXCI6IGRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgICAgICAgSWUgPSB7XG4gICAgbmFtZTogXCJvZmZzZXRcIixcbiAgICBlbmFibGVkOiAhMCxcbiAgICBwaGFzZTogXCJtYWluXCIsXG4gICAgcmVxdWlyZXM6IFtcInBvcHBlck9mZnNldHNcIl0sXG4gICAgZm46IGZ1bmN0aW9uICh0KSB7XG4gICAgICB2YXIgZSA9IHQuc3RhdGUsXG4gICAgICAgICAgaSA9IHQub3B0aW9ucyxcbiAgICAgICAgICBuID0gdC5uYW1lLFxuICAgICAgICAgIHMgPSBpLm9mZnNldCxcbiAgICAgICAgICBvID0gdm9pZCAwID09PSBzID8gWzAsIDBdIDogcyxcbiAgICAgICAgICByID0gTHQucmVkdWNlKGZ1bmN0aW9uICh0LCBpKSB7XG4gICAgICAgIHJldHVybiB0W2ldID0gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgICAgICB2YXIgbiA9IFV0KHQpLFxuICAgICAgICAgICAgICBzID0gW2J0LCBtdF0uaW5kZXhPZihuKSA+PSAwID8gLTEgOiAxLFxuICAgICAgICAgICAgICBvID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBpID8gaShPYmplY3QuYXNzaWduKHt9LCBlLCB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IHRcbiAgICAgICAgICB9KSkgOiBpLFxuICAgICAgICAgICAgICByID0gb1swXSxcbiAgICAgICAgICAgICAgYSA9IG9bMV07XG4gICAgICAgICAgcmV0dXJuIHIgPSByIHx8IDAsIGEgPSAoYSB8fCAwKSAqIHMsIFtidCwgX3RdLmluZGV4T2YobikgPj0gMCA/IHtcbiAgICAgICAgICAgIHg6IGEsXG4gICAgICAgICAgICB5OiByXG4gICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIHg6IHIsXG4gICAgICAgICAgICB5OiBhXG4gICAgICAgICAgfTtcbiAgICAgICAgfShpLCBlLnJlY3RzLCBvKSwgdDtcbiAgICAgIH0sIHt9KSxcbiAgICAgICAgICBhID0gcltlLnBsYWNlbWVudF0sXG4gICAgICAgICAgbCA9IGEueCxcbiAgICAgICAgICBjID0gYS55O1xuICAgICAgbnVsbCAhPSBlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAmJiAoZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueCArPSBsLCBlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy55ICs9IGMpLCBlLm1vZGlmaWVyc0RhdGFbbl0gPSByO1xuICAgIH1cbiAgfSxcbiAgICAgICAgUGUgPSB7XG4gICAgbmFtZTogXCJwb3BwZXJPZmZzZXRzXCIsXG4gICAgZW5hYmxlZDogITAsXG4gICAgcGhhc2U6IFwicmVhZFwiLFxuICAgIGZuOiBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0LnN0YXRlLFxuICAgICAgICAgIGkgPSB0Lm5hbWU7XG4gICAgICBlLm1vZGlmaWVyc0RhdGFbaV0gPSBDZSh7XG4gICAgICAgIHJlZmVyZW5jZTogZS5yZWN0cy5yZWZlcmVuY2UsXG4gICAgICAgIGVsZW1lbnQ6IGUucmVjdHMucG9wcGVyLFxuICAgICAgICBzdHJhdGVneTogXCJhYnNvbHV0ZVwiLFxuICAgICAgICBwbGFjZW1lbnQ6IGUucGxhY2VtZW50XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRhdGE6IHt9XG4gIH0sXG4gICAgICAgIGplID0ge1xuICAgIG5hbWU6IFwicHJldmVudE92ZXJmbG93XCIsXG4gICAgZW5hYmxlZDogITAsXG4gICAgcGhhc2U6IFwibWFpblwiLFxuICAgIGZuOiBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0LnN0YXRlLFxuICAgICAgICAgIGkgPSB0Lm9wdGlvbnMsXG4gICAgICAgICAgbiA9IHQubmFtZSxcbiAgICAgICAgICBzID0gaS5tYWluQXhpcyxcbiAgICAgICAgICBvID0gdm9pZCAwID09PSBzIHx8IHMsXG4gICAgICAgICAgciA9IGkuYWx0QXhpcyxcbiAgICAgICAgICBhID0gdm9pZCAwICE9PSByICYmIHIsXG4gICAgICAgICAgbCA9IGkuYm91bmRhcnksXG4gICAgICAgICAgYyA9IGkucm9vdEJvdW5kYXJ5LFxuICAgICAgICAgIGggPSBpLmFsdEJvdW5kYXJ5LFxuICAgICAgICAgIGQgPSBpLnBhZGRpbmcsXG4gICAgICAgICAgdSA9IGkudGV0aGVyLFxuICAgICAgICAgIGYgPSB2b2lkIDAgPT09IHUgfHwgdSxcbiAgICAgICAgICBwID0gaS50ZXRoZXJPZmZzZXQsXG4gICAgICAgICAgbSA9IHZvaWQgMCA9PT0gcCA/IDAgOiBwLFxuICAgICAgICAgIGcgPSBrZShlLCB7XG4gICAgICAgIGJvdW5kYXJ5OiBsLFxuICAgICAgICByb290Qm91bmRhcnk6IGMsXG4gICAgICAgIHBhZGRpbmc6IGQsXG4gICAgICAgIGFsdEJvdW5kYXJ5OiBoXG4gICAgICB9KSxcbiAgICAgICAgICBfID0gVXQoZS5wbGFjZW1lbnQpLFxuICAgICAgICAgIGIgPSBjZShlLnBsYWNlbWVudCksXG4gICAgICAgICAgdiA9ICFiLFxuICAgICAgICAgIHkgPSBlZShfKSxcbiAgICAgICAgICB3ID0gXCJ4XCIgPT09IHkgPyBcInlcIiA6IFwieFwiLFxuICAgICAgICAgIEUgPSBlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyxcbiAgICAgICAgICBBID0gZS5yZWN0cy5yZWZlcmVuY2UsXG4gICAgICAgICAgVCA9IGUucmVjdHMucG9wcGVyLFxuICAgICAgICAgIE8gPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG0gPyBtKE9iamVjdC5hc3NpZ24oe30sIGUucmVjdHMsIHtcbiAgICAgICAgcGxhY2VtZW50OiBlLnBsYWNlbWVudFxuICAgICAgfSkpIDogbSxcbiAgICAgICAgICBDID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuXG4gICAgICBpZiAoRSkge1xuICAgICAgICBpZiAobyB8fCBhKSB7XG4gICAgICAgICAgdmFyIGsgPSBcInlcIiA9PT0geSA/IG10IDogYnQsXG4gICAgICAgICAgICAgIEwgPSBcInlcIiA9PT0geSA/IGd0IDogX3QsXG4gICAgICAgICAgICAgIHggPSBcInlcIiA9PT0geSA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCIsXG4gICAgICAgICAgICAgIEQgPSBFW3ldLFxuICAgICAgICAgICAgICBTID0gRVt5XSArIGdba10sXG4gICAgICAgICAgICAgIE4gPSBFW3ldIC0gZ1tMXSxcbiAgICAgICAgICAgICAgSSA9IGYgPyAtVFt4XSAvIDIgOiAwLFxuICAgICAgICAgICAgICBQID0gYiA9PT0gd3QgPyBBW3hdIDogVFt4XSxcbiAgICAgICAgICAgICAgaiA9IGIgPT09IHd0ID8gLVRbeF0gOiAtQVt4XSxcbiAgICAgICAgICAgICAgTSA9IGUuZWxlbWVudHMuYXJyb3csXG4gICAgICAgICAgICAgIEggPSBmICYmIE0gPyBLdChNKSA6IHtcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICAgICAgQiA9IGUubW9kaWZpZXJzRGF0YVtcImFycm93I3BlcnNpc3RlbnRcIl0gPyBlLm1vZGlmaWVyc0RhdGFbXCJhcnJvdyNwZXJzaXN0ZW50XCJdLnBhZGRpbmcgOiB7XG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICAgIGxlZnQ6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgICAgICBSID0gQltrXSxcbiAgICAgICAgICAgICAgVyA9IEJbTF0sXG4gICAgICAgICAgICAgICQgPSBvZSgwLCBBW3hdLCBIW3hdKSxcbiAgICAgICAgICAgICAgeiA9IHYgPyBBW3hdIC8gMiAtIEkgLSAkIC0gUiAtIE8gOiBQIC0gJCAtIFIgLSBPLFxuICAgICAgICAgICAgICBxID0gdiA/IC1BW3hdIC8gMiArIEkgKyAkICsgVyArIE8gOiBqICsgJCArIFcgKyBPLFxuICAgICAgICAgICAgICBGID0gZS5lbGVtZW50cy5hcnJvdyAmJiB0ZShlLmVsZW1lbnRzLmFycm93KSxcbiAgICAgICAgICAgICAgVSA9IEYgPyBcInlcIiA9PT0geSA/IEYuY2xpZW50VG9wIHx8IDAgOiBGLmNsaWVudExlZnQgfHwgMCA6IDAsXG4gICAgICAgICAgICAgIFYgPSBlLm1vZGlmaWVyc0RhdGEub2Zmc2V0ID8gZS5tb2RpZmllcnNEYXRhLm9mZnNldFtlLnBsYWNlbWVudF1beV0gOiAwLFxuICAgICAgICAgICAgICBLID0gRVt5XSArIHogLSBWIC0gVSxcbiAgICAgICAgICAgICAgWCA9IEVbeV0gKyBxIC0gVjtcblxuICAgICAgICAgIGlmIChvKSB7XG4gICAgICAgICAgICB2YXIgWSA9IG9lKGYgPyBuZShTLCBLKSA6IFMsIEQsIGYgPyBpZShOLCBYKSA6IE4pO1xuICAgICAgICAgICAgRVt5XSA9IFksIENbeV0gPSBZIC0gRDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYSkge1xuICAgICAgICAgICAgdmFyIFEgPSBcInhcIiA9PT0geSA/IG10IDogYnQsXG4gICAgICAgICAgICAgICAgRyA9IFwieFwiID09PSB5ID8gZ3QgOiBfdCxcbiAgICAgICAgICAgICAgICBaID0gRVt3XSxcbiAgICAgICAgICAgICAgICBKID0gWiArIGdbUV0sXG4gICAgICAgICAgICAgICAgdHQgPSBaIC0gZ1tHXSxcbiAgICAgICAgICAgICAgICBldCA9IG9lKGYgPyBuZShKLCBLKSA6IEosIFosIGYgPyBpZSh0dCwgWCkgOiB0dCk7XG4gICAgICAgICAgICBFW3ddID0gZXQsIENbd10gPSBldCAtIFo7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZS5tb2RpZmllcnNEYXRhW25dID0gQztcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlcXVpcmVzSWZFeGlzdHM6IFtcIm9mZnNldFwiXVxuICB9O1xuXG4gIGZ1bmN0aW9uIE1lKHQsIGUsIGkpIHtcbiAgICB2b2lkIDAgPT09IGkgJiYgKGkgPSAhMSk7XG4gICAgdmFyIG4gPSB6dChlKTtcbiAgICB6dChlKSAmJiBmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIGUgPSB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgZS53aWR0aCwgdC5vZmZzZXRXaWR0aCwgZS5oZWlnaHQsIHQub2Zmc2V0SGVpZ2h0O1xuICAgIH0oZSk7XG4gICAgdmFyIHMsXG4gICAgICAgIG8sXG4gICAgICAgIHIgPSBHdChlKSxcbiAgICAgICAgYSA9IFZ0KHQpLFxuICAgICAgICBsID0ge1xuICAgICAgc2Nyb2xsTGVmdDogMCxcbiAgICAgIHNjcm9sbFRvcDogMFxuICAgIH0sXG4gICAgICAgIGMgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gICAgcmV0dXJuIChuIHx8ICFuICYmICFpKSAmJiAoKFwiYm9keVwiICE9PSBSdChlKSB8fCB3ZShyKSkgJiYgKGwgPSAocyA9IGUpICE9PSBXdChzKSAmJiB6dChzKSA/IHtcbiAgICAgIHNjcm9sbExlZnQ6IChvID0gcykuc2Nyb2xsTGVmdCxcbiAgICAgIHNjcm9sbFRvcDogby5zY3JvbGxUb3BcbiAgICB9IDogdmUocykpLCB6dChlKSA/ICgoYyA9IFZ0KGUpKS54ICs9IGUuY2xpZW50TGVmdCwgYy55ICs9IGUuY2xpZW50VG9wKSA6IHIgJiYgKGMueCA9IHllKHIpKSksIHtcbiAgICAgIHg6IGEubGVmdCArIGwuc2Nyb2xsTGVmdCAtIGMueCxcbiAgICAgIHk6IGEudG9wICsgbC5zY3JvbGxUb3AgLSBjLnksXG4gICAgICB3aWR0aDogYS53aWR0aCxcbiAgICAgIGhlaWdodDogYS5oZWlnaHRcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gSGUodCkge1xuICAgIHZhciBlID0gbmV3IE1hcCgpLFxuICAgICAgICBpID0gbmV3IFNldCgpLFxuICAgICAgICBuID0gW107XG5cbiAgICBmdW5jdGlvbiBzKHQpIHtcbiAgICAgIGkuYWRkKHQubmFtZSksIFtdLmNvbmNhdCh0LnJlcXVpcmVzIHx8IFtdLCB0LnJlcXVpcmVzSWZFeGlzdHMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgaWYgKCFpLmhhcyh0KSkge1xuICAgICAgICAgIHZhciBuID0gZS5nZXQodCk7XG4gICAgICAgICAgbiAmJiBzKG4pO1xuICAgICAgICB9XG4gICAgICB9KSwgbi5wdXNoKHQpO1xuICAgIH1cblxuICAgIHJldHVybiB0LmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgIGUuc2V0KHQubmFtZSwgdCk7XG4gICAgfSksIHQuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgaS5oYXModC5uYW1lKSB8fCBzKHQpO1xuICAgIH0pLCBuO1xuICB9XG5cbiAgdmFyIEJlID0ge1xuICAgIHBsYWNlbWVudDogXCJib3R0b21cIixcbiAgICBtb2RpZmllcnM6IFtdLFxuICAgIHN0cmF0ZWd5OiBcImFic29sdXRlXCJcbiAgfTtcblxuICBmdW5jdGlvbiBSZSgpIHtcbiAgICBmb3IgKHZhciB0ID0gYXJndW1lbnRzLmxlbmd0aCwgZSA9IG5ldyBBcnJheSh0KSwgaSA9IDA7IGkgPCB0OyBpKyspIGVbaV0gPSBhcmd1bWVudHNbaV07XG5cbiAgICByZXR1cm4gIWUuc29tZShmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuICEodCAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFdlKHQpIHtcbiAgICB2b2lkIDAgPT09IHQgJiYgKHQgPSB7fSk7XG4gICAgdmFyIGUgPSB0LFxuICAgICAgICBpID0gZS5kZWZhdWx0TW9kaWZpZXJzLFxuICAgICAgICBuID0gdm9pZCAwID09PSBpID8gW10gOiBpLFxuICAgICAgICBzID0gZS5kZWZhdWx0T3B0aW9ucyxcbiAgICAgICAgbyA9IHZvaWQgMCA9PT0gcyA/IEJlIDogcztcbiAgICByZXR1cm4gZnVuY3Rpb24gKHQsIGUsIGkpIHtcbiAgICAgIHZvaWQgMCA9PT0gaSAmJiAoaSA9IG8pO1xuICAgICAgdmFyIHMsXG4gICAgICAgICAgcixcbiAgICAgICAgICBhID0ge1xuICAgICAgICBwbGFjZW1lbnQ6IFwiYm90dG9tXCIsXG4gICAgICAgIG9yZGVyZWRNb2RpZmllcnM6IFtdLFxuICAgICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBCZSwgbyksXG4gICAgICAgIG1vZGlmaWVyc0RhdGE6IHt9LFxuICAgICAgICBlbGVtZW50czoge1xuICAgICAgICAgIHJlZmVyZW5jZTogdCxcbiAgICAgICAgICBwb3BwZXI6IGVcbiAgICAgICAgfSxcbiAgICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICAgIHN0eWxlczoge31cbiAgICAgIH0sXG4gICAgICAgICAgbCA9IFtdLFxuICAgICAgICAgIGMgPSAhMSxcbiAgICAgICAgICBoID0ge1xuICAgICAgICBzdGF0ZTogYSxcbiAgICAgICAgc2V0T3B0aW9uczogZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICB2YXIgcyA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaSA/IGkoYS5vcHRpb25zKSA6IGk7XG4gICAgICAgICAgZCgpLCBhLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvLCBhLm9wdGlvbnMsIHMpLCBhLnNjcm9sbFBhcmVudHMgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2U6ICR0KHQpID8gQWUodCkgOiB0LmNvbnRleHRFbGVtZW50ID8gQWUodC5jb250ZXh0RWxlbWVudCkgOiBbXSxcbiAgICAgICAgICAgIHBvcHBlcjogQWUoZSlcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIHIsXG4gICAgICAgICAgICAgIGMsXG4gICAgICAgICAgICAgIHUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdmFyIGUgPSBIZSh0KTtcbiAgICAgICAgICAgIHJldHVybiBCdC5yZWR1Y2UoZnVuY3Rpb24gKHQsIGkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHQuY29uY2F0KGUuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHQucGhhc2UgPT09IGk7XG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgICB9KChyID0gW10uY29uY2F0KG4sIGEub3B0aW9ucy5tb2RpZmllcnMpLCBjID0gci5yZWR1Y2UoZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgICAgICAgIHZhciBpID0gdFtlLm5hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIHRbZS5uYW1lXSA9IGkgPyBPYmplY3QuYXNzaWduKHt9LCBpLCBlLCB7XG4gICAgICAgICAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIGkub3B0aW9ucywgZS5vcHRpb25zKSxcbiAgICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgaS5kYXRhLCBlLmRhdGEpXG4gICAgICAgICAgICB9KSA6IGUsIHQ7XG4gICAgICAgICAgfSwge30pLCBPYmplY3Qua2V5cyhjKS5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiBjW3RdO1xuICAgICAgICAgIH0pKSk7XG5cbiAgICAgICAgICByZXR1cm4gYS5vcmRlcmVkTW9kaWZpZXJzID0gdS5maWx0ZXIoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0LmVuYWJsZWQ7XG4gICAgICAgICAgfSksIGEub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgZSA9IHQubmFtZSxcbiAgICAgICAgICAgICAgICBpID0gdC5vcHRpb25zLFxuICAgICAgICAgICAgICAgIG4gPSB2b2lkIDAgPT09IGkgPyB7fSA6IGksXG4gICAgICAgICAgICAgICAgcyA9IHQuZWZmZWN0O1xuXG4gICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBzKSB7XG4gICAgICAgICAgICAgIHZhciBvID0gcyh7XG4gICAgICAgICAgICAgICAgc3RhdGU6IGEsXG4gICAgICAgICAgICAgICAgbmFtZTogZSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogaCxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBuXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBsLnB1c2gobyB8fCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIGgudXBkYXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFjKSB7XG4gICAgICAgICAgICB2YXIgdCA9IGEuZWxlbWVudHMsXG4gICAgICAgICAgICAgICAgZSA9IHQucmVmZXJlbmNlLFxuICAgICAgICAgICAgICAgIGkgPSB0LnBvcHBlcjtcblxuICAgICAgICAgICAgaWYgKFJlKGUsIGkpKSB7XG4gICAgICAgICAgICAgIGEucmVjdHMgPSB7XG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlOiBNZShlLCB0ZShpKSwgXCJmaXhlZFwiID09PSBhLm9wdGlvbnMuc3RyYXRlZ3kpLFxuICAgICAgICAgICAgICAgIHBvcHBlcjogS3QoaSlcbiAgICAgICAgICAgICAgfSwgYS5yZXNldCA9ICExLCBhLnBsYWNlbWVudCA9IGEub3B0aW9ucy5wbGFjZW1lbnQsIGEub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEubW9kaWZpZXJzRGF0YVt0Lm5hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgdC5kYXRhKTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBhLm9yZGVyZWRNb2RpZmllcnMubGVuZ3RoOyBuKyspIGlmICghMCAhPT0gYS5yZXNldCkge1xuICAgICAgICAgICAgICAgIHZhciBzID0gYS5vcmRlcmVkTW9kaWZpZXJzW25dLFxuICAgICAgICAgICAgICAgICAgICBvID0gcy5mbixcbiAgICAgICAgICAgICAgICAgICAgciA9IHMub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgbCA9IHZvaWQgMCA9PT0gciA/IHt9IDogcixcbiAgICAgICAgICAgICAgICAgICAgZCA9IHMubmFtZTtcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIG8gJiYgKGEgPSBvKHtcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBhLFxuICAgICAgICAgICAgICAgICAgb3B0aW9uczogbCxcbiAgICAgICAgICAgICAgICAgIG5hbWU6IGQsXG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZTogaFxuICAgICAgICAgICAgICAgIH0pIHx8IGEpO1xuICAgICAgICAgICAgICB9IGVsc2UgYS5yZXNldCA9ICExLCBuID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1cGRhdGU6IChzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgaC5mb3JjZVVwZGF0ZSgpLCB0KGEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHIgfHwgKHIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHIgPSB2b2lkIDAsIHQocygpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pKSwgcjtcbiAgICAgICAgfSksXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkKCksIGMgPSAhMDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmICghUmUodCwgZSkpIHJldHVybiBoO1xuXG4gICAgICBmdW5jdGlvbiBkKCkge1xuICAgICAgICBsLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdCgpO1xuICAgICAgICB9KSwgbCA9IFtdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaC5zZXRPcHRpb25zKGkpLnRoZW4oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgIWMgJiYgaS5vbkZpcnN0VXBkYXRlICYmIGkub25GaXJzdFVwZGF0ZSh0KTtcbiAgICAgIH0pLCBoO1xuICAgIH07XG4gIH1cblxuICB2YXIgJGUgPSBXZSgpLFxuICAgICAgemUgPSBXZSh7XG4gICAgZGVmYXVsdE1vZGlmaWVyczogW3BlLCBQZSwgdWUsIEZ0XVxuICB9KSxcbiAgICAgIHFlID0gV2Uoe1xuICAgIGRlZmF1bHRNb2RpZmllcnM6IFtwZSwgUGUsIHVlLCBGdCwgSWUsIHhlLCBqZSwgbGUsIE5lXVxuICB9KTtcbiAgY29uc3QgRmUgPSBPYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgcG9wcGVyR2VuZXJhdG9yOiBXZSxcbiAgICBkZXRlY3RPdmVyZmxvdzoga2UsXG4gICAgY3JlYXRlUG9wcGVyQmFzZTogJGUsXG4gICAgY3JlYXRlUG9wcGVyOiBxZSxcbiAgICBjcmVhdGVQb3BwZXJMaXRlOiB6ZSxcbiAgICB0b3A6IG10LFxuICAgIGJvdHRvbTogZ3QsXG4gICAgcmlnaHQ6IF90LFxuICAgIGxlZnQ6IGJ0LFxuICAgIGF1dG86IHZ0LFxuICAgIGJhc2VQbGFjZW1lbnRzOiB5dCxcbiAgICBzdGFydDogd3QsXG4gICAgZW5kOiBFdCxcbiAgICBjbGlwcGluZ1BhcmVudHM6IEF0LFxuICAgIHZpZXdwb3J0OiBUdCxcbiAgICBwb3BwZXI6IE90LFxuICAgIHJlZmVyZW5jZTogQ3QsXG4gICAgdmFyaWF0aW9uUGxhY2VtZW50czoga3QsXG4gICAgcGxhY2VtZW50czogTHQsXG4gICAgYmVmb3JlUmVhZDogeHQsXG4gICAgcmVhZDogRHQsXG4gICAgYWZ0ZXJSZWFkOiBTdCxcbiAgICBiZWZvcmVNYWluOiBOdCxcbiAgICBtYWluOiBJdCxcbiAgICBhZnRlck1haW46IFB0LFxuICAgIGJlZm9yZVdyaXRlOiBqdCxcbiAgICB3cml0ZTogTXQsXG4gICAgYWZ0ZXJXcml0ZTogSHQsXG4gICAgbW9kaWZpZXJQaGFzZXM6IEJ0LFxuICAgIGFwcGx5U3R5bGVzOiBGdCxcbiAgICBhcnJvdzogbGUsXG4gICAgY29tcHV0ZVN0eWxlczogdWUsXG4gICAgZXZlbnRMaXN0ZW5lcnM6IHBlLFxuICAgIGZsaXA6IHhlLFxuICAgIGhpZGU6IE5lLFxuICAgIG9mZnNldDogSWUsXG4gICAgcG9wcGVyT2Zmc2V0czogUGUsXG4gICAgcHJldmVudE92ZXJmbG93OiBqZVxuICB9KSxcbiAgICAgICAgVWUgPSBcImRyb3Bkb3duXCIsXG4gICAgICAgIFZlID0gXCJFc2NhcGVcIixcbiAgICAgICAgS2UgPSBcIlNwYWNlXCIsXG4gICAgICAgIFhlID0gXCJBcnJvd1VwXCIsXG4gICAgICAgIFllID0gXCJBcnJvd0Rvd25cIixcbiAgICAgICAgUWUgPSBuZXcgUmVnRXhwKFwiQXJyb3dVcHxBcnJvd0Rvd258RXNjYXBlXCIpLFxuICAgICAgICBHZSA9IFwiY2xpY2suYnMuZHJvcGRvd24uZGF0YS1hcGlcIixcbiAgICAgICAgWmUgPSBcImtleWRvd24uYnMuZHJvcGRvd24uZGF0YS1hcGlcIixcbiAgICAgICAgSmUgPSBcInNob3dcIixcbiAgICAgICAgdGkgPSAnW2RhdGEtYnMtdG9nZ2xlPVwiZHJvcGRvd25cIl0nLFxuICAgICAgICBlaSA9IFwiLmRyb3Bkb3duLW1lbnVcIixcbiAgICAgICAgaWkgPSBtKCkgPyBcInRvcC1lbmRcIiA6IFwidG9wLXN0YXJ0XCIsXG4gICAgICAgIG5pID0gbSgpID8gXCJ0b3Atc3RhcnRcIiA6IFwidG9wLWVuZFwiLFxuICAgICAgICBzaSA9IG0oKSA/IFwiYm90dG9tLWVuZFwiIDogXCJib3R0b20tc3RhcnRcIixcbiAgICAgICAgb2kgPSBtKCkgPyBcImJvdHRvbS1zdGFydFwiIDogXCJib3R0b20tZW5kXCIsXG4gICAgICAgIHJpID0gbSgpID8gXCJsZWZ0LXN0YXJ0XCIgOiBcInJpZ2h0LXN0YXJ0XCIsXG4gICAgICAgIGFpID0gbSgpID8gXCJyaWdodC1zdGFydFwiIDogXCJsZWZ0LXN0YXJ0XCIsXG4gICAgICAgIGxpID0ge1xuICAgIG9mZnNldDogWzAsIDJdLFxuICAgIGJvdW5kYXJ5OiBcImNsaXBwaW5nUGFyZW50c1wiLFxuICAgIHJlZmVyZW5jZTogXCJ0b2dnbGVcIixcbiAgICBkaXNwbGF5OiBcImR5bmFtaWNcIixcbiAgICBwb3BwZXJDb25maWc6IG51bGwsXG4gICAgYXV0b0Nsb3NlOiAhMFxuICB9LFxuICAgICAgICBjaSA9IHtcbiAgICBvZmZzZXQ6IFwiKGFycmF5fHN0cmluZ3xmdW5jdGlvbilcIixcbiAgICBib3VuZGFyeTogXCIoc3RyaW5nfGVsZW1lbnQpXCIsXG4gICAgcmVmZXJlbmNlOiBcIihzdHJpbmd8ZWxlbWVudHxvYmplY3QpXCIsXG4gICAgZGlzcGxheTogXCJzdHJpbmdcIixcbiAgICBwb3BwZXJDb25maWc6IFwiKG51bGx8b2JqZWN0fGZ1bmN0aW9uKVwiLFxuICAgIGF1dG9DbG9zZTogXCIoYm9vbGVhbnxzdHJpbmcpXCJcbiAgfTtcblxuICBjbGFzcyBoaSBleHRlbmRzIEIge1xuICAgIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICAgIHN1cGVyKHQpLCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX21lbnUgPSB0aGlzLl9nZXRNZW51RWxlbWVudCgpLCB0aGlzLl9pbk5hdmJhciA9IHRoaXMuX2RldGVjdE5hdmJhcigpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBsaTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgICAgcmV0dXJuIGNpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHJldHVybiBVZTtcbiAgICB9XG5cbiAgICB0b2dnbGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNTaG93bigpID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcbiAgICB9XG5cbiAgICBzaG93KCkge1xuICAgICAgaWYgKGModGhpcy5fZWxlbWVudCkgfHwgdGhpcy5faXNTaG93bih0aGlzLl9tZW51KSkgcmV0dXJuO1xuICAgICAgY29uc3QgdCA9IHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgICAgfTtcbiAgICAgIGlmIChqLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgXCJzaG93LmJzLmRyb3Bkb3duXCIsIHQpLmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcbiAgICAgIGNvbnN0IGUgPSBoaS5nZXRQYXJlbnRGcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTtcbiAgICAgIHRoaXMuX2luTmF2YmFyID8gVS5zZXREYXRhQXR0cmlidXRlKHRoaXMuX21lbnUsIFwicG9wcGVyXCIsIFwibm9uZVwiKSA6IHRoaXMuX2NyZWF0ZVBvcHBlcihlKSwgXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgIWUuY2xvc2VzdChcIi5uYXZiYXItbmF2XCIpICYmIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKHQgPT4gai5vbih0LCBcIm1vdXNlb3ZlclwiLCBkKSksIHRoaXMuX2VsZW1lbnQuZm9jdXMoKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsICEwKSwgdGhpcy5fbWVudS5jbGFzc0xpc3QuYWRkKEplKSwgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKEplKSwgai50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFwic2hvd24uYnMuZHJvcGRvd25cIiwgdCk7XG4gICAgfVxuXG4gICAgaGlkZSgpIHtcbiAgICAgIGlmIChjKHRoaXMuX2VsZW1lbnQpIHx8ICF0aGlzLl9pc1Nob3duKHRoaXMuX21lbnUpKSByZXR1cm47XG4gICAgICBjb25zdCB0ID0ge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9jb21wbGV0ZUhpZGUodCk7XG4gICAgfVxuXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgIHRoaXMuX3BvcHBlciAmJiB0aGlzLl9wb3BwZXIuZGVzdHJveSgpLCBzdXBlci5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlKCkge1xuICAgICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKSwgdGhpcy5fcG9wcGVyICYmIHRoaXMuX3BvcHBlci51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBfY29tcGxldGVIaWRlKHQpIHtcbiAgICAgIGoudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBcImhpZGUuYnMuZHJvcGRvd25cIiwgdCkuZGVmYXVsdFByZXZlbnRlZCB8fCAoXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pLmZvckVhY2godCA9PiBqLm9mZih0LCBcIm1vdXNlb3ZlclwiLCBkKSksIHRoaXMuX3BvcHBlciAmJiB0aGlzLl9wb3BwZXIuZGVzdHJveSgpLCB0aGlzLl9tZW51LmNsYXNzTGlzdC5yZW1vdmUoSmUpLCB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoSmUpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgXCJmYWxzZVwiKSwgVS5yZW1vdmVEYXRhQXR0cmlidXRlKHRoaXMuX21lbnUsIFwicG9wcGVyXCIpLCBqLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgXCJoaWRkZW4uYnMuZHJvcGRvd25cIiwgdCkpO1xuICAgIH1cblxuICAgIF9nZXRDb25maWcodCkge1xuICAgICAgaWYgKHQgPSB7IC4uLnRoaXMuY29uc3RydWN0b3IuRGVmYXVsdCxcbiAgICAgICAgLi4uVS5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgICAgLi4udFxuICAgICAgfSwgYShVZSwgdCwgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSksIFwib2JqZWN0XCIgPT0gdHlwZW9mIHQucmVmZXJlbmNlICYmICFvKHQucmVmZXJlbmNlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIHQucmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCkgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtVZS50b1VwcGVyQ2FzZSgpfTogT3B0aW9uIFwicmVmZXJlbmNlXCIgcHJvdmlkZWQgdHlwZSBcIm9iamVjdFwiIHdpdGhvdXQgYSByZXF1aXJlZCBcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiIG1ldGhvZC5gKTtcbiAgICAgIHJldHVybiB0O1xuICAgIH1cblxuICAgIF9jcmVhdGVQb3BwZXIodCkge1xuICAgICAgaWYgKHZvaWQgMCA9PT0gRmUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJCb290c3RyYXAncyBkcm9wZG93bnMgcmVxdWlyZSBQb3BwZXIgKGh0dHBzOi8vcG9wcGVyLmpzLm9yZylcIik7XG4gICAgICBsZXQgZSA9IHRoaXMuX2VsZW1lbnQ7XG4gICAgICBcInBhcmVudFwiID09PSB0aGlzLl9jb25maWcucmVmZXJlbmNlID8gZSA9IHQgOiBvKHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UpID8gZSA9IHIodGhpcy5fY29uZmlnLnJlZmVyZW5jZSkgOiBcIm9iamVjdFwiID09IHR5cGVvZiB0aGlzLl9jb25maWcucmVmZXJlbmNlICYmIChlID0gdGhpcy5fY29uZmlnLnJlZmVyZW5jZSk7XG5cbiAgICAgIGNvbnN0IGkgPSB0aGlzLl9nZXRQb3BwZXJDb25maWcoKSxcbiAgICAgICAgICAgIG4gPSBpLm1vZGlmaWVycy5maW5kKHQgPT4gXCJhcHBseVN0eWxlc1wiID09PSB0Lm5hbWUgJiYgITEgPT09IHQuZW5hYmxlZCk7XG5cbiAgICAgIHRoaXMuX3BvcHBlciA9IHFlKGUsIHRoaXMuX21lbnUsIGkpLCBuICYmIFUuc2V0RGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCBcInBvcHBlclwiLCBcInN0YXRpY1wiKTtcbiAgICB9XG5cbiAgICBfaXNTaG93bih0ID0gdGhpcy5fZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHQuY2xhc3NMaXN0LmNvbnRhaW5zKEplKTtcbiAgICB9XG5cbiAgICBfZ2V0TWVudUVsZW1lbnQoKSB7XG4gICAgICByZXR1cm4gVi5uZXh0KHRoaXMuX2VsZW1lbnQsIGVpKVswXTtcbiAgICB9XG5cbiAgICBfZ2V0UGxhY2VtZW50KCkge1xuICAgICAgY29uc3QgdCA9IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgIGlmICh0LmNsYXNzTGlzdC5jb250YWlucyhcImRyb3BlbmRcIikpIHJldHVybiByaTtcbiAgICAgIGlmICh0LmNsYXNzTGlzdC5jb250YWlucyhcImRyb3BzdGFydFwiKSkgcmV0dXJuIGFpO1xuICAgICAgY29uc3QgZSA9IFwiZW5kXCIgPT09IGdldENvbXB1dGVkU3R5bGUodGhpcy5fbWVudSkuZ2V0UHJvcGVydHlWYWx1ZShcIi0tYnMtcG9zaXRpb25cIikudHJpbSgpO1xuICAgICAgcmV0dXJuIHQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZHJvcHVwXCIpID8gZSA/IG5pIDogaWkgOiBlID8gb2kgOiBzaTtcbiAgICB9XG5cbiAgICBfZGV0ZWN0TmF2YmFyKCkge1xuICAgICAgcmV0dXJuIG51bGwgIT09IHRoaXMuX2VsZW1lbnQuY2xvc2VzdChcIi5uYXZiYXJcIik7XG4gICAgfVxuXG4gICAgX2dldE9mZnNldCgpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2Zmc2V0OiB0XG4gICAgICB9ID0gdGhpcy5fY29uZmlnO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT0gdHlwZW9mIHQgPyB0LnNwbGl0KFwiLFwiKS5tYXAodCA9PiBOdW1iZXIucGFyc2VJbnQodCwgMTApKSA6IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdCA/IGUgPT4gdChlLCB0aGlzLl9lbGVtZW50KSA6IHQ7XG4gICAgfVxuXG4gICAgX2dldFBvcHBlckNvbmZpZygpIHtcbiAgICAgIGNvbnN0IHQgPSB7XG4gICAgICAgIHBsYWNlbWVudDogdGhpcy5fZ2V0UGxhY2VtZW50KCksXG4gICAgICAgIG1vZGlmaWVyczogW3tcbiAgICAgICAgICBuYW1lOiBcInByZXZlbnRPdmVyZmxvd1wiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLl9jb25maWcuYm91bmRhcnlcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcIm9mZnNldFwiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KClcbiAgICAgICAgICB9XG4gICAgICAgIH1dXG4gICAgICB9O1xuICAgICAgcmV0dXJuIFwic3RhdGljXCIgPT09IHRoaXMuX2NvbmZpZy5kaXNwbGF5ICYmICh0Lm1vZGlmaWVycyA9IFt7XG4gICAgICAgIG5hbWU6IFwiYXBwbHlTdHlsZXNcIixcbiAgICAgICAgZW5hYmxlZDogITFcbiAgICAgIH1dKSwgeyAuLi50LFxuICAgICAgICAuLi4oXCJmdW5jdGlvblwiID09IHR5cGVvZiB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnID8gdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyh0KSA6IHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcpXG4gICAgICB9O1xuICAgIH1cblxuICAgIF9zZWxlY3RNZW51SXRlbSh7XG4gICAgICBrZXk6IHQsXG4gICAgICB0YXJnZXQ6IGVcbiAgICB9KSB7XG4gICAgICBjb25zdCBpID0gVi5maW5kKFwiLmRyb3Bkb3duLW1lbnUgLmRyb3Bkb3duLWl0ZW06bm90KC5kaXNhYmxlZCk6bm90KDpkaXNhYmxlZClcIiwgdGhpcy5fbWVudSkuZmlsdGVyKGwpO1xuICAgICAgaS5sZW5ndGggJiYgdihpLCBlLCB0ID09PSBZZSwgIWkuaW5jbHVkZXMoZSkpLmZvY3VzKCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZSA9IGhpLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgdCk7XG5cbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHQpIHtcbiAgICAgICAgICBpZiAodm9pZCAwID09PSBlW3RdKSB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgICBlW3RdKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBjbGVhck1lbnVzKHQpIHtcbiAgICAgIGlmICh0ICYmICgyID09PSB0LmJ1dHRvbiB8fCBcImtleXVwXCIgPT09IHQudHlwZSAmJiBcIlRhYlwiICE9PSB0LmtleSkpIHJldHVybjtcbiAgICAgIGNvbnN0IGUgPSBWLmZpbmQodGkpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGUubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG4gPSBoaS5nZXRJbnN0YW5jZShlW2ldKTtcbiAgICAgICAgaWYgKCFuIHx8ICExID09PSBuLl9jb25maWcuYXV0b0Nsb3NlKSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFuLl9pc1Nob3duKCkpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBzID0ge1xuICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IG4uX2VsZW1lbnRcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodCkge1xuICAgICAgICAgIGNvbnN0IGUgPSB0LmNvbXBvc2VkUGF0aCgpLFxuICAgICAgICAgICAgICAgIGkgPSBlLmluY2x1ZGVzKG4uX21lbnUpO1xuICAgICAgICAgIGlmIChlLmluY2x1ZGVzKG4uX2VsZW1lbnQpIHx8IFwiaW5zaWRlXCIgPT09IG4uX2NvbmZpZy5hdXRvQ2xvc2UgJiYgIWkgfHwgXCJvdXRzaWRlXCIgPT09IG4uX2NvbmZpZy5hdXRvQ2xvc2UgJiYgaSkgY29udGludWU7XG4gICAgICAgICAgaWYgKG4uX21lbnUuY29udGFpbnModC50YXJnZXQpICYmIChcImtleXVwXCIgPT09IHQudHlwZSAmJiBcIlRhYlwiID09PSB0LmtleSB8fCAvaW5wdXR8c2VsZWN0fG9wdGlvbnx0ZXh0YXJlYXxmb3JtL2kudGVzdCh0LnRhcmdldC50YWdOYW1lKSkpIGNvbnRpbnVlO1xuICAgICAgICAgIFwiY2xpY2tcIiA9PT0gdC50eXBlICYmIChzLmNsaWNrRXZlbnQgPSB0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG4uX2NvbXBsZXRlSGlkZShzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0UGFyZW50RnJvbUVsZW1lbnQodCkge1xuICAgICAgcmV0dXJuIG4odCkgfHwgdC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIHN0YXRpYyBkYXRhQXBpS2V5ZG93bkhhbmRsZXIodCkge1xuICAgICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QodC50YXJnZXQudGFnTmFtZSkgPyB0LmtleSA9PT0gS2UgfHwgdC5rZXkgIT09IFZlICYmICh0LmtleSAhPT0gWWUgJiYgdC5rZXkgIT09IFhlIHx8IHQudGFyZ2V0LmNsb3Nlc3QoZWkpKSA6ICFRZS50ZXN0KHQua2V5KSkgcmV0dXJuO1xuICAgICAgY29uc3QgZSA9IHRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKEplKTtcbiAgICAgIGlmICghZSAmJiB0LmtleSA9PT0gVmUpIHJldHVybjtcbiAgICAgIGlmICh0LnByZXZlbnREZWZhdWx0KCksIHQuc3RvcFByb3BhZ2F0aW9uKCksIGModGhpcykpIHJldHVybjtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLm1hdGNoZXModGkpID8gdGhpcyA6IFYucHJldih0aGlzLCB0aSlbMF0sXG4gICAgICAgICAgICBuID0gaGkuZ2V0T3JDcmVhdGVJbnN0YW5jZShpKTtcbiAgICAgIGlmICh0LmtleSAhPT0gVmUpIHJldHVybiB0LmtleSA9PT0gWGUgfHwgdC5rZXkgPT09IFllID8gKGUgfHwgbi5zaG93KCksIHZvaWQgbi5fc2VsZWN0TWVudUl0ZW0odCkpIDogdm9pZCAoZSAmJiB0LmtleSAhPT0gS2UgfHwgaGkuY2xlYXJNZW51cygpKTtcbiAgICAgIG4uaGlkZSgpO1xuICAgIH1cblxuICB9XG5cbiAgai5vbihkb2N1bWVudCwgWmUsIHRpLCBoaS5kYXRhQXBpS2V5ZG93bkhhbmRsZXIpLCBqLm9uKGRvY3VtZW50LCBaZSwgZWksIGhpLmRhdGFBcGlLZXlkb3duSGFuZGxlciksIGoub24oZG9jdW1lbnQsIEdlLCBoaS5jbGVhck1lbnVzKSwgai5vbihkb2N1bWVudCwgXCJrZXl1cC5icy5kcm9wZG93bi5kYXRhLWFwaVwiLCBoaS5jbGVhck1lbnVzKSwgai5vbihkb2N1bWVudCwgR2UsIHRpLCBmdW5jdGlvbiAodCkge1xuICAgIHQucHJldmVudERlZmF1bHQoKSwgaGkuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKS50b2dnbGUoKTtcbiAgfSksIGcoaGkpO1xuICBjb25zdCBkaSA9IFwiLmZpeGVkLXRvcCwgLmZpeGVkLWJvdHRvbSwgLmlzLWZpeGVkLCAuc3RpY2t5LXRvcFwiLFxuICAgICAgICB1aSA9IFwiLnN0aWNreS10b3BcIjtcblxuICBjbGFzcyBmaSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gZG9jdW1lbnQuYm9keTtcbiAgICB9XG5cbiAgICBnZXRXaWR0aCgpIHtcbiAgICAgIGNvbnN0IHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICByZXR1cm4gTWF0aC5hYnMod2luZG93LmlubmVyV2lkdGggLSB0KTtcbiAgICB9XG5cbiAgICBoaWRlKCkge1xuICAgICAgY29uc3QgdCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgIHRoaXMuX2Rpc2FibGVPdmVyRmxvdygpLCB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyh0aGlzLl9lbGVtZW50LCBcInBhZGRpbmdSaWdodFwiLCBlID0+IGUgKyB0KSwgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXMoZGksIFwicGFkZGluZ1JpZ2h0XCIsIGUgPT4gZSArIHQpLCB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyh1aSwgXCJtYXJnaW5SaWdodFwiLCBlID0+IGUgLSB0KTtcbiAgICB9XG5cbiAgICBfZGlzYWJsZU92ZXJGbG93KCkge1xuICAgICAgdGhpcy5fc2F2ZUluaXRpYWxBdHRyaWJ1dGUodGhpcy5fZWxlbWVudCwgXCJvdmVyZmxvd1wiKSwgdGhpcy5fZWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgfVxuXG4gICAgX3NldEVsZW1lbnRBdHRyaWJ1dGVzKHQsIGUsIGkpIHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLmdldFdpZHRoKCk7XG5cbiAgICAgIHRoaXMuX2FwcGx5TWFuaXB1bGF0aW9uQ2FsbGJhY2sodCwgdCA9PiB7XG4gICAgICAgIGlmICh0ICE9PSB0aGlzLl9lbGVtZW50ICYmIHdpbmRvdy5pbm5lcldpZHRoID4gdC5jbGllbnRXaWR0aCArIG4pIHJldHVybjtcblxuICAgICAgICB0aGlzLl9zYXZlSW5pdGlhbEF0dHJpYnV0ZSh0LCBlKTtcblxuICAgICAgICBjb25zdCBzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodClbZV07XG4gICAgICAgIHQuc3R5bGVbZV0gPSBgJHtpKE51bWJlci5wYXJzZUZsb2F0KHMpKX1weGA7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCwgXCJvdmVyZmxvd1wiKSwgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyh0aGlzLl9lbGVtZW50LCBcInBhZGRpbmdSaWdodFwiKSwgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyhkaSwgXCJwYWRkaW5nUmlnaHRcIiksIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXModWksIFwibWFyZ2luUmlnaHRcIik7XG4gICAgfVxuXG4gICAgX3NhdmVJbml0aWFsQXR0cmlidXRlKHQsIGUpIHtcbiAgICAgIGNvbnN0IGkgPSB0LnN0eWxlW2VdO1xuICAgICAgaSAmJiBVLnNldERhdGFBdHRyaWJ1dGUodCwgZSwgaSk7XG4gICAgfVxuXG4gICAgX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXModCwgZSkge1xuICAgICAgdGhpcy5fYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayh0LCB0ID0+IHtcbiAgICAgICAgY29uc3QgaSA9IFUuZ2V0RGF0YUF0dHJpYnV0ZSh0LCBlKTtcbiAgICAgICAgdm9pZCAwID09PSBpID8gdC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShlKSA6IChVLnJlbW92ZURhdGFBdHRyaWJ1dGUodCwgZSksIHQuc3R5bGVbZV0gPSBpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrKHQsIGUpIHtcbiAgICAgIG8odCkgPyBlKHQpIDogVi5maW5kKHQsIHRoaXMuX2VsZW1lbnQpLmZvckVhY2goZSk7XG4gICAgfVxuXG4gICAgaXNPdmVyZmxvd2luZygpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFdpZHRoKCkgPiAwO1xuICAgIH1cblxuICB9XG5cbiAgY29uc3QgcGkgPSB7XG4gICAgY2xhc3NOYW1lOiBcIm1vZGFsLWJhY2tkcm9wXCIsXG4gICAgaXNWaXNpYmxlOiAhMCxcbiAgICBpc0FuaW1hdGVkOiAhMSxcbiAgICByb290RWxlbWVudDogXCJib2R5XCIsXG4gICAgY2xpY2tDYWxsYmFjazogbnVsbFxuICB9LFxuICAgICAgICBtaSA9IHtcbiAgICBjbGFzc05hbWU6IFwic3RyaW5nXCIsXG4gICAgaXNWaXNpYmxlOiBcImJvb2xlYW5cIixcbiAgICBpc0FuaW1hdGVkOiBcImJvb2xlYW5cIixcbiAgICByb290RWxlbWVudDogXCIoZWxlbWVudHxzdHJpbmcpXCIsXG4gICAgY2xpY2tDYWxsYmFjazogXCIoZnVuY3Rpb258bnVsbClcIlxuICB9LFxuICAgICAgICBnaSA9IFwic2hvd1wiLFxuICAgICAgICBfaSA9IFwibW91c2Vkb3duLmJzLmJhY2tkcm9wXCI7XG5cbiAgY2xhc3MgYmkge1xuICAgIGNvbnN0cnVjdG9yKHQpIHtcbiAgICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyh0KSwgdGhpcy5faXNBcHBlbmRlZCA9ICExLCB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICBzaG93KHQpIHtcbiAgICAgIHRoaXMuX2NvbmZpZy5pc1Zpc2libGUgPyAodGhpcy5fYXBwZW5kKCksIHRoaXMuX2NvbmZpZy5pc0FuaW1hdGVkICYmIHUodGhpcy5fZ2V0RWxlbWVudCgpKSwgdGhpcy5fZ2V0RWxlbWVudCgpLmNsYXNzTGlzdC5hZGQoZ2kpLCB0aGlzLl9lbXVsYXRlQW5pbWF0aW9uKCgpID0+IHtcbiAgICAgICAgXyh0KTtcbiAgICAgIH0pKSA6IF8odCk7XG4gICAgfVxuXG4gICAgaGlkZSh0KSB7XG4gICAgICB0aGlzLl9jb25maWcuaXNWaXNpYmxlID8gKHRoaXMuX2dldEVsZW1lbnQoKS5jbGFzc0xpc3QucmVtb3ZlKGdpKSwgdGhpcy5fZW11bGF0ZUFuaW1hdGlvbigoKSA9PiB7XG4gICAgICAgIHRoaXMuZGlzcG9zZSgpLCBfKHQpO1xuICAgICAgfSkpIDogXyh0KTtcbiAgICB9XG5cbiAgICBfZ2V0RWxlbWVudCgpIHtcbiAgICAgIGlmICghdGhpcy5fZWxlbWVudCkge1xuICAgICAgICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdC5jbGFzc05hbWUgPSB0aGlzLl9jb25maWcuY2xhc3NOYW1lLCB0aGlzLl9jb25maWcuaXNBbmltYXRlZCAmJiB0LmNsYXNzTGlzdC5hZGQoXCJmYWRlXCIpLCB0aGlzLl9lbGVtZW50ID0gdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgfVxuXG4gICAgX2dldENvbmZpZyh0KSB7XG4gICAgICByZXR1cm4gKHQgPSB7IC4uLnBpLFxuICAgICAgICAuLi4oXCJvYmplY3RcIiA9PSB0eXBlb2YgdCA/IHQgOiB7fSlcbiAgICAgIH0pLnJvb3RFbGVtZW50ID0gcih0LnJvb3RFbGVtZW50KSwgYShcImJhY2tkcm9wXCIsIHQsIG1pKSwgdDtcbiAgICB9XG5cbiAgICBfYXBwZW5kKCkge1xuICAgICAgdGhpcy5faXNBcHBlbmRlZCB8fCAodGhpcy5fY29uZmlnLnJvb3RFbGVtZW50LmFwcGVuZCh0aGlzLl9nZXRFbGVtZW50KCkpLCBqLm9uKHRoaXMuX2dldEVsZW1lbnQoKSwgX2ksICgpID0+IHtcbiAgICAgICAgXyh0aGlzLl9jb25maWcuY2xpY2tDYWxsYmFjayk7XG4gICAgICB9KSwgdGhpcy5faXNBcHBlbmRlZCA9ICEwKTtcbiAgICB9XG5cbiAgICBkaXNwb3NlKCkge1xuICAgICAgdGhpcy5faXNBcHBlbmRlZCAmJiAoai5vZmYodGhpcy5fZWxlbWVudCwgX2kpLCB0aGlzLl9lbGVtZW50LnJlbW92ZSgpLCB0aGlzLl9pc0FwcGVuZGVkID0gITEpO1xuICAgIH1cblxuICAgIF9lbXVsYXRlQW5pbWF0aW9uKHQpIHtcbiAgICAgIGIodCwgdGhpcy5fZ2V0RWxlbWVudCgpLCB0aGlzLl9jb25maWcuaXNBbmltYXRlZCk7XG4gICAgfVxuXG4gIH1cblxuICBjb25zdCB2aSA9IHtcbiAgICB0cmFwRWxlbWVudDogbnVsbCxcbiAgICBhdXRvZm9jdXM6ICEwXG4gIH0sXG4gICAgICAgIHlpID0ge1xuICAgIHRyYXBFbGVtZW50OiBcImVsZW1lbnRcIixcbiAgICBhdXRvZm9jdXM6IFwiYm9vbGVhblwiXG4gIH0sXG4gICAgICAgIHdpID0gXCIuYnMuZm9jdXN0cmFwXCIsXG4gICAgICAgIEVpID0gXCJiYWNrd2FyZFwiO1xuXG4gIGNsYXNzIEFpIHtcbiAgICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcodCksIHRoaXMuX2lzQWN0aXZlID0gITEsIHRoaXMuX2xhc3RUYWJOYXZEaXJlY3Rpb24gPSBudWxsO1xuICAgIH1cblxuICAgIGFjdGl2YXRlKCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0cmFwRWxlbWVudDogdCxcbiAgICAgICAgYXV0b2ZvY3VzOiBlXG4gICAgICB9ID0gdGhpcy5fY29uZmlnO1xuICAgICAgdGhpcy5faXNBY3RpdmUgfHwgKGUgJiYgdC5mb2N1cygpLCBqLm9mZihkb2N1bWVudCwgd2kpLCBqLm9uKGRvY3VtZW50LCBcImZvY3VzaW4uYnMuZm9jdXN0cmFwXCIsIHQgPT4gdGhpcy5faGFuZGxlRm9jdXNpbih0KSksIGoub24oZG9jdW1lbnQsIFwia2V5ZG93bi50YWIuYnMuZm9jdXN0cmFwXCIsIHQgPT4gdGhpcy5faGFuZGxlS2V5ZG93bih0KSksIHRoaXMuX2lzQWN0aXZlID0gITApO1xuICAgIH1cblxuICAgIGRlYWN0aXZhdGUoKSB7XG4gICAgICB0aGlzLl9pc0FjdGl2ZSAmJiAodGhpcy5faXNBY3RpdmUgPSAhMSwgai5vZmYoZG9jdW1lbnQsIHdpKSk7XG4gICAgfVxuXG4gICAgX2hhbmRsZUZvY3VzaW4odCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0YXJnZXQ6IGVcbiAgICAgIH0gPSB0LFxuICAgICAgICAgICAge1xuICAgICAgICB0cmFwRWxlbWVudDogaVxuICAgICAgfSA9IHRoaXMuX2NvbmZpZztcbiAgICAgIGlmIChlID09PSBkb2N1bWVudCB8fCBlID09PSBpIHx8IGkuY29udGFpbnMoZSkpIHJldHVybjtcbiAgICAgIGNvbnN0IG4gPSBWLmZvY3VzYWJsZUNoaWxkcmVuKGkpO1xuICAgICAgMCA9PT0gbi5sZW5ndGggPyBpLmZvY3VzKCkgOiB0aGlzLl9sYXN0VGFiTmF2RGlyZWN0aW9uID09PSBFaSA/IG5bbi5sZW5ndGggLSAxXS5mb2N1cygpIDogblswXS5mb2N1cygpO1xuICAgIH1cblxuICAgIF9oYW5kbGVLZXlkb3duKHQpIHtcbiAgICAgIFwiVGFiXCIgPT09IHQua2V5ICYmICh0aGlzLl9sYXN0VGFiTmF2RGlyZWN0aW9uID0gdC5zaGlmdEtleSA/IEVpIDogXCJmb3J3YXJkXCIpO1xuICAgIH1cblxuICAgIF9nZXRDb25maWcodCkge1xuICAgICAgcmV0dXJuIHQgPSB7IC4uLnZpLFxuICAgICAgICAuLi4oXCJvYmplY3RcIiA9PSB0eXBlb2YgdCA/IHQgOiB7fSlcbiAgICAgIH0sIGEoXCJmb2N1c3RyYXBcIiwgdCwgeWkpLCB0O1xuICAgIH1cblxuICB9XG5cbiAgY29uc3QgVGkgPSBcIm1vZGFsXCIsXG4gICAgICAgIE9pID0gXCJFc2NhcGVcIixcbiAgICAgICAgQ2kgPSB7XG4gICAgYmFja2Ryb3A6ICEwLFxuICAgIGtleWJvYXJkOiAhMCxcbiAgICBmb2N1czogITBcbiAgfSxcbiAgICAgICAga2kgPSB7XG4gICAgYmFja2Ryb3A6IFwiKGJvb2xlYW58c3RyaW5nKVwiLFxuICAgIGtleWJvYXJkOiBcImJvb2xlYW5cIixcbiAgICBmb2N1czogXCJib29sZWFuXCJcbiAgfSxcbiAgICAgICAgTGkgPSBcImhpZGRlbi5icy5tb2RhbFwiLFxuICAgICAgICB4aSA9IFwic2hvdy5icy5tb2RhbFwiLFxuICAgICAgICBEaSA9IFwicmVzaXplLmJzLm1vZGFsXCIsXG4gICAgICAgIFNpID0gXCJjbGljay5kaXNtaXNzLmJzLm1vZGFsXCIsXG4gICAgICAgIE5pID0gXCJrZXlkb3duLmRpc21pc3MuYnMubW9kYWxcIixcbiAgICAgICAgSWkgPSBcIm1vdXNlZG93bi5kaXNtaXNzLmJzLm1vZGFsXCIsXG4gICAgICAgIFBpID0gXCJtb2RhbC1vcGVuXCIsXG4gICAgICAgIGppID0gXCJzaG93XCIsXG4gICAgICAgIE1pID0gXCJtb2RhbC1zdGF0aWNcIjtcblxuICBjbGFzcyBIaSBleHRlbmRzIEIge1xuICAgIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICAgIHN1cGVyKHQpLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2RpYWxvZyA9IFYuZmluZE9uZShcIi5tb2RhbC1kaWFsb2dcIiwgdGhpcy5fZWxlbWVudCksIHRoaXMuX2JhY2tkcm9wID0gdGhpcy5faW5pdGlhbGl6ZUJhY2tEcm9wKCksIHRoaXMuX2ZvY3VzdHJhcCA9IHRoaXMuX2luaXRpYWxpemVGb2N1c1RyYXAoKSwgdGhpcy5faXNTaG93biA9ICExLCB0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gITEsIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICExLCB0aGlzLl9zY3JvbGxCYXIgPSBuZXcgZmkoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gQ2k7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIFRpO1xuICAgIH1cblxuICAgIHRvZ2dsZSh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KHQpO1xuICAgIH1cblxuICAgIHNob3codCkge1xuICAgICAgdGhpcy5faXNTaG93biB8fCB0aGlzLl9pc1RyYW5zaXRpb25pbmcgfHwgai50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHhpLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRcbiAgICAgIH0pLmRlZmF1bHRQcmV2ZW50ZWQgfHwgKHRoaXMuX2lzU2hvd24gPSAhMCwgdGhpcy5faXNBbmltYXRlZCgpICYmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMCksIHRoaXMuX3Njcm9sbEJhci5oaWRlKCksIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChQaSksIHRoaXMuX2FkanVzdERpYWxvZygpLCB0aGlzLl9zZXRFc2NhcGVFdmVudCgpLCB0aGlzLl9zZXRSZXNpemVFdmVudCgpLCBqLm9uKHRoaXMuX2RpYWxvZywgSWksICgpID0+IHtcbiAgICAgICAgai5vbmUodGhpcy5fZWxlbWVudCwgXCJtb3VzZXVwLmRpc21pc3MuYnMubW9kYWxcIiwgdCA9PiB7XG4gICAgICAgICAgdC50YXJnZXQgPT09IHRoaXMuX2VsZW1lbnQgJiYgKHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSAhMCk7XG4gICAgICAgIH0pO1xuICAgICAgfSksIHRoaXMuX3Nob3dCYWNrZHJvcCgoKSA9PiB0aGlzLl9zaG93RWxlbWVudCh0KSkpO1xuICAgIH1cblxuICAgIGhpZGUoKSB7XG4gICAgICBpZiAoIXRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nKSByZXR1cm47XG4gICAgICBpZiAoai50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFwiaGlkZS5icy5tb2RhbFwiKS5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG4gICAgICB0aGlzLl9pc1Nob3duID0gITE7XG5cbiAgICAgIGNvbnN0IHQgPSB0aGlzLl9pc0FuaW1hdGVkKCk7XG5cbiAgICAgIHQgJiYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICEwKSwgdGhpcy5fc2V0RXNjYXBlRXZlbnQoKSwgdGhpcy5fc2V0UmVzaXplRXZlbnQoKSwgdGhpcy5fZm9jdXN0cmFwLmRlYWN0aXZhdGUoKSwgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGppKSwgai5vZmYodGhpcy5fZWxlbWVudCwgU2kpLCBqLm9mZih0aGlzLl9kaWFsb2csIElpKSwgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB0aGlzLl9oaWRlTW9kYWwoKSwgdGhpcy5fZWxlbWVudCwgdCk7XG4gICAgfVxuXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgIFt3aW5kb3csIHRoaXMuX2RpYWxvZ10uZm9yRWFjaCh0ID0+IGoub2ZmKHQsIFwiLmJzLm1vZGFsXCIpKSwgdGhpcy5fYmFja2Ryb3AuZGlzcG9zZSgpLCB0aGlzLl9mb2N1c3RyYXAuZGVhY3RpdmF0ZSgpLCBzdXBlci5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgaGFuZGxlVXBkYXRlKCkge1xuICAgICAgdGhpcy5fYWRqdXN0RGlhbG9nKCk7XG4gICAgfVxuXG4gICAgX2luaXRpYWxpemVCYWNrRHJvcCgpIHtcbiAgICAgIHJldHVybiBuZXcgYmkoe1xuICAgICAgICBpc1Zpc2libGU6IEJvb2xlYW4odGhpcy5fY29uZmlnLmJhY2tkcm9wKSxcbiAgICAgICAgaXNBbmltYXRlZDogdGhpcy5faXNBbmltYXRlZCgpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfaW5pdGlhbGl6ZUZvY3VzVHJhcCgpIHtcbiAgICAgIHJldHVybiBuZXcgQWkoe1xuICAgICAgICB0cmFwRWxlbWVudDogdGhpcy5fZWxlbWVudFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2dldENvbmZpZyh0KSB7XG4gICAgICByZXR1cm4gdCA9IHsgLi4uQ2ksXG4gICAgICAgIC4uLlUuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAgIC4uLihcIm9iamVjdFwiID09IHR5cGVvZiB0ID8gdCA6IHt9KVxuICAgICAgfSwgYShUaSwgdCwga2kpLCB0O1xuICAgIH1cblxuICAgIF9zaG93RWxlbWVudCh0KSB7XG4gICAgICBjb25zdCBlID0gdGhpcy5faXNBbmltYXRlZCgpLFxuICAgICAgICAgICAgaSA9IFYuZmluZE9uZShcIi5tb2RhbC1ib2R5XCIsIHRoaXMuX2RpYWxvZyk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSAmJiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFIHx8IGRvY3VtZW50LmJvZHkuYXBwZW5kKHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCIsIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1tb2RhbFwiLCAhMCksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImRpYWxvZ1wiKSwgdGhpcy5fZWxlbWVudC5zY3JvbGxUb3AgPSAwLCBpICYmIChpLnNjcm9sbFRvcCA9IDApLCBlICYmIHUodGhpcy5fZWxlbWVudCksIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChqaSksIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICB0aGlzLl9jb25maWcuZm9jdXMgJiYgdGhpcy5fZm9jdXN0cmFwLmFjdGl2YXRlKCksIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICExLCBqLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgXCJzaG93bi5icy5tb2RhbFwiLCB7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogdFxuICAgICAgICB9KTtcbiAgICAgIH0sIHRoaXMuX2RpYWxvZywgZSk7XG4gICAgfVxuXG4gICAgX3NldEVzY2FwZUV2ZW50KCkge1xuICAgICAgdGhpcy5faXNTaG93biA/IGoub24odGhpcy5fZWxlbWVudCwgTmksIHQgPT4ge1xuICAgICAgICB0aGlzLl9jb25maWcua2V5Ym9hcmQgJiYgdC5rZXkgPT09IE9pID8gKHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5oaWRlKCkpIDogdGhpcy5fY29uZmlnLmtleWJvYXJkIHx8IHQua2V5ICE9PSBPaSB8fCB0aGlzLl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCk7XG4gICAgICB9KSA6IGoub2ZmKHRoaXMuX2VsZW1lbnQsIE5pKTtcbiAgICB9XG5cbiAgICBfc2V0UmVzaXplRXZlbnQoKSB7XG4gICAgICB0aGlzLl9pc1Nob3duID8gai5vbih3aW5kb3csIERpLCAoKSA9PiB0aGlzLl9hZGp1c3REaWFsb2coKSkgOiBqLm9mZih3aW5kb3csIERpKTtcbiAgICB9XG5cbiAgICBfaGlkZU1vZGFsKCkge1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIsIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgITApLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtbW9kYWxcIiksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwicm9sZVwiKSwgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITEsIHRoaXMuX2JhY2tkcm9wLmhpZGUoKCkgPT4ge1xuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoUGkpLCB0aGlzLl9yZXNldEFkanVzdG1lbnRzKCksIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpLCBqLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgTGkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX3Nob3dCYWNrZHJvcCh0KSB7XG4gICAgICBqLm9uKHRoaXMuX2VsZW1lbnQsIFNpLCB0ID0+IHtcbiAgICAgICAgdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA/IHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSAhMSA6IHQudGFyZ2V0ID09PSB0LmN1cnJlbnRUYXJnZXQgJiYgKCEwID09PSB0aGlzLl9jb25maWcuYmFja2Ryb3AgPyB0aGlzLmhpZGUoKSA6IFwic3RhdGljXCIgPT09IHRoaXMuX2NvbmZpZy5iYWNrZHJvcCAmJiB0aGlzLl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCkpO1xuICAgICAgfSksIHRoaXMuX2JhY2tkcm9wLnNob3codCk7XG4gICAgfVxuXG4gICAgX2lzQW5pbWF0ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJmYWRlXCIpO1xuICAgIH1cblxuICAgIF90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCkge1xuICAgICAgaWYgKGoudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBcImhpZGVQcmV2ZW50ZWQuYnMubW9kYWxcIikuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbGFzc0xpc3Q6IHQsXG4gICAgICAgIHNjcm9sbEhlaWdodDogZSxcbiAgICAgICAgc3R5bGU6IGlcbiAgICAgIH0gPSB0aGlzLl9lbGVtZW50LFxuICAgICAgICAgICAgbiA9IGUgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgIW4gJiYgXCJoaWRkZW5cIiA9PT0gaS5vdmVyZmxvd1kgfHwgdC5jb250YWlucyhNaSkgfHwgKG4gfHwgKGkub3ZlcmZsb3dZID0gXCJoaWRkZW5cIiksIHQuYWRkKE1pKSwgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHQucmVtb3ZlKE1pKSwgbiB8fCB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICBpLm92ZXJmbG93WSA9IFwiXCI7XG4gICAgICAgIH0sIHRoaXMuX2RpYWxvZyk7XG4gICAgICB9LCB0aGlzLl9kaWFsb2cpLCB0aGlzLl9lbGVtZW50LmZvY3VzKCkpO1xuICAgIH1cblxuICAgIF9hZGp1c3REaWFsb2coKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5fZWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LFxuICAgICAgICAgICAgZSA9IHRoaXMuX3Njcm9sbEJhci5nZXRXaWR0aCgpLFxuICAgICAgICAgICAgaSA9IGUgPiAwO1xuXG4gICAgICAoIWkgJiYgdCAmJiAhbSgpIHx8IGkgJiYgIXQgJiYgbSgpKSAmJiAodGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdCA9IGAke2V9cHhgKSwgKGkgJiYgIXQgJiYgIW0oKSB8fCAhaSAmJiB0ICYmIG0oKSkgJiYgKHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gYCR7ZX1weGApO1xuICAgIH1cblxuICAgIF9yZXNldEFkanVzdG1lbnRzKCkge1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdCA9IFwiXCIsIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gXCJcIjtcbiAgICB9XG5cbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQsIGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBpID0gSGkuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcblxuICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCkge1xuICAgICAgICAgIGlmICh2b2lkIDAgPT09IGlbdF0pIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICAgIGlbdF0oZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICB9XG5cbiAgai5vbihkb2N1bWVudCwgXCJjbGljay5icy5tb2RhbC5kYXRhLWFwaVwiLCAnW2RhdGEtYnMtdG9nZ2xlPVwibW9kYWxcIl0nLCBmdW5jdGlvbiAodCkge1xuICAgIGNvbnN0IGUgPSBuKHRoaXMpO1xuICAgIFtcIkFcIiwgXCJBUkVBXCJdLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkgJiYgdC5wcmV2ZW50RGVmYXVsdCgpLCBqLm9uZShlLCB4aSwgdCA9PiB7XG4gICAgICB0LmRlZmF1bHRQcmV2ZW50ZWQgfHwgai5vbmUoZSwgTGksICgpID0+IHtcbiAgICAgICAgbCh0aGlzKSAmJiB0aGlzLmZvY3VzKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBpID0gVi5maW5kT25lKFwiLm1vZGFsLnNob3dcIik7XG4gICAgaSAmJiBIaS5nZXRJbnN0YW5jZShpKS5oaWRlKCksIEhpLmdldE9yQ3JlYXRlSW5zdGFuY2UoZSkudG9nZ2xlKHRoaXMpO1xuICB9KSwgUihIaSksIGcoSGkpO1xuICBjb25zdCBCaSA9IFwib2ZmY2FudmFzXCIsXG4gICAgICAgIFJpID0ge1xuICAgIGJhY2tkcm9wOiAhMCxcbiAgICBrZXlib2FyZDogITAsXG4gICAgc2Nyb2xsOiAhMVxuICB9LFxuICAgICAgICBXaSA9IHtcbiAgICBiYWNrZHJvcDogXCJib29sZWFuXCIsXG4gICAga2V5Ym9hcmQ6IFwiYm9vbGVhblwiLFxuICAgIHNjcm9sbDogXCJib29sZWFuXCJcbiAgfSxcbiAgICAgICAgJGkgPSBcInNob3dcIixcbiAgICAgICAgemkgPSBcIi5vZmZjYW52YXMuc2hvd1wiLFxuICAgICAgICBxaSA9IFwiaGlkZGVuLmJzLm9mZmNhbnZhc1wiO1xuXG4gIGNsYXNzIEZpIGV4dGVuZHMgQiB7XG4gICAgY29uc3RydWN0b3IodCwgZSkge1xuICAgICAgc3VwZXIodCksIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5faXNTaG93biA9ICExLCB0aGlzLl9iYWNrZHJvcCA9IHRoaXMuX2luaXRpYWxpemVCYWNrRHJvcCgpLCB0aGlzLl9mb2N1c3RyYXAgPSB0aGlzLl9pbml0aWFsaXplRm9jdXNUcmFwKCksIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIEJpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBSaTtcbiAgICB9XG5cbiAgICB0b2dnbGUodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzU2hvd24gPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdyh0KTtcbiAgICB9XG5cbiAgICBzaG93KHQpIHtcbiAgICAgIHRoaXMuX2lzU2hvd24gfHwgai50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFwic2hvdy5icy5vZmZjYW52YXNcIiwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0XG4gICAgICB9KS5kZWZhdWx0UHJldmVudGVkIHx8ICh0aGlzLl9pc1Nob3duID0gITAsIHRoaXMuX2VsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiLCB0aGlzLl9iYWNrZHJvcC5zaG93KCksIHRoaXMuX2NvbmZpZy5zY3JvbGwgfHwgbmV3IGZpKCkuaGlkZSgpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbW9kYWxcIiwgITApLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJkaWFsb2dcIiksIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZCgkaSksIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICB0aGlzLl9jb25maWcuc2Nyb2xsIHx8IHRoaXMuX2ZvY3VzdHJhcC5hY3RpdmF0ZSgpLCBqLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgXCJzaG93bi5icy5vZmZjYW52YXNcIiwge1xuICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRcbiAgICAgICAgfSk7XG4gICAgICB9LCB0aGlzLl9lbGVtZW50LCAhMCkpO1xuICAgIH1cblxuICAgIGhpZGUoKSB7XG4gICAgICB0aGlzLl9pc1Nob3duICYmIChqLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgXCJoaWRlLmJzLm9mZmNhbnZhc1wiKS5kZWZhdWx0UHJldmVudGVkIHx8ICh0aGlzLl9mb2N1c3RyYXAuZGVhY3RpdmF0ZSgpLCB0aGlzLl9lbGVtZW50LmJsdXIoKSwgdGhpcy5faXNTaG93biA9ICExLCB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJGkpLCB0aGlzLl9iYWNrZHJvcC5oaWRlKCksIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsICEwKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLW1vZGFsXCIpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInJvbGVcIiksIHRoaXMuX2VsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCIsIHRoaXMuX2NvbmZpZy5zY3JvbGwgfHwgbmV3IGZpKCkucmVzZXQoKSwgai50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHFpKTtcbiAgICAgIH0sIHRoaXMuX2VsZW1lbnQsICEwKSkpO1xuICAgIH1cblxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICB0aGlzLl9iYWNrZHJvcC5kaXNwb3NlKCksIHRoaXMuX2ZvY3VzdHJhcC5kZWFjdGl2YXRlKCksIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB9XG5cbiAgICBfZ2V0Q29uZmlnKHQpIHtcbiAgICAgIHJldHVybiB0ID0geyAuLi5SaSxcbiAgICAgICAgLi4uVS5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgICAgLi4uKFwib2JqZWN0XCIgPT0gdHlwZW9mIHQgPyB0IDoge30pXG4gICAgICB9LCBhKEJpLCB0LCBXaSksIHQ7XG4gICAgfVxuXG4gICAgX2luaXRpYWxpemVCYWNrRHJvcCgpIHtcbiAgICAgIHJldHVybiBuZXcgYmkoe1xuICAgICAgICBjbGFzc05hbWU6IFwib2ZmY2FudmFzLWJhY2tkcm9wXCIsXG4gICAgICAgIGlzVmlzaWJsZTogdGhpcy5fY29uZmlnLmJhY2tkcm9wLFxuICAgICAgICBpc0FuaW1hdGVkOiAhMCxcbiAgICAgICAgcm9vdEVsZW1lbnQ6IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSxcbiAgICAgICAgY2xpY2tDYWxsYmFjazogKCkgPT4gdGhpcy5oaWRlKClcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF9pbml0aWFsaXplRm9jdXNUcmFwKCkge1xuICAgICAgcmV0dXJuIG5ldyBBaSh7XG4gICAgICAgIHRyYXBFbGVtZW50OiB0aGlzLl9lbGVtZW50XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICBqLm9uKHRoaXMuX2VsZW1lbnQsIFwia2V5ZG93bi5kaXNtaXNzLmJzLm9mZmNhbnZhc1wiLCB0ID0+IHtcbiAgICAgICAgdGhpcy5fY29uZmlnLmtleWJvYXJkICYmIFwiRXNjYXBlXCIgPT09IHQua2V5ICYmIHRoaXMuaGlkZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZSA9IEZpLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgdCk7XG5cbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHQpIHtcbiAgICAgICAgICBpZiAodm9pZCAwID09PSBlW3RdIHx8IHQuc3RhcnRzV2l0aChcIl9cIikgfHwgXCJjb25zdHJ1Y3RvclwiID09PSB0KSB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgICBlW3RdKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfVxuXG4gIGoub24oZG9jdW1lbnQsIFwiY2xpY2suYnMub2ZmY2FudmFzLmRhdGEtYXBpXCIsICdbZGF0YS1icy10b2dnbGU9XCJvZmZjYW52YXNcIl0nLCBmdW5jdGlvbiAodCkge1xuICAgIGNvbnN0IGUgPSBuKHRoaXMpO1xuICAgIGlmIChbXCJBXCIsIFwiQVJFQVwiXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpICYmIHQucHJldmVudERlZmF1bHQoKSwgYyh0aGlzKSkgcmV0dXJuO1xuICAgIGoub25lKGUsIHFpLCAoKSA9PiB7XG4gICAgICBsKHRoaXMpICYmIHRoaXMuZm9jdXMoKTtcbiAgICB9KTtcbiAgICBjb25zdCBpID0gVi5maW5kT25lKHppKTtcbiAgICBpICYmIGkgIT09IGUgJiYgRmkuZ2V0SW5zdGFuY2UoaSkuaGlkZSgpLCBGaS5nZXRPckNyZWF0ZUluc3RhbmNlKGUpLnRvZ2dsZSh0aGlzKTtcbiAgfSksIGoub24od2luZG93LCBcImxvYWQuYnMub2ZmY2FudmFzLmRhdGEtYXBpXCIsICgpID0+IFYuZmluZCh6aSkuZm9yRWFjaCh0ID0+IEZpLmdldE9yQ3JlYXRlSW5zdGFuY2UodCkuc2hvdygpKSksIFIoRmkpLCBnKEZpKTtcblxuICBjb25zdCBVaSA9IG5ldyBTZXQoW1wiYmFja2dyb3VuZFwiLCBcImNpdGVcIiwgXCJocmVmXCIsIFwiaXRlbXR5cGVcIiwgXCJsb25nZGVzY1wiLCBcInBvc3RlclwiLCBcInNyY1wiLCBcInhsaW5rOmhyZWZcIl0pLFxuICAgICAgICBWaSA9IC9eKD86KD86aHR0cHM/fG1haWx0b3xmdHB8dGVsfGZpbGV8c21zKTp8W14jJi86P10qKD86WyMvP118JCkpL2ksXG4gICAgICAgIEtpID0gL15kYXRhOig/OmltYWdlXFwvKD86Ym1wfGdpZnxqcGVnfGpwZ3xwbmd8dGlmZnx3ZWJwKXx2aWRlb1xcLyg/Om1wZWd8bXA0fG9nZ3x3ZWJtKXxhdWRpb1xcLyg/Om1wM3xvZ2F8b2dnfG9wdXMpKTtiYXNlNjQsW1xcZCsvYS16XSs9KiQvaSxcbiAgICAgICAgWGkgPSAodCwgZSkgPT4ge1xuICAgIGNvbnN0IGkgPSB0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGUuaW5jbHVkZXMoaSkpIHJldHVybiAhVWkuaGFzKGkpIHx8IEJvb2xlYW4oVmkudGVzdCh0Lm5vZGVWYWx1ZSkgfHwgS2kudGVzdCh0Lm5vZGVWYWx1ZSkpO1xuICAgIGNvbnN0IG4gPSBlLmZpbHRlcih0ID0+IHQgaW5zdGFuY2VvZiBSZWdFeHApO1xuXG4gICAgZm9yIChsZXQgdCA9IDAsIGUgPSBuLmxlbmd0aDsgdCA8IGU7IHQrKykgaWYgKG5bdF0udGVzdChpKSkgcmV0dXJuICEwO1xuXG4gICAgcmV0dXJuICExO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFlpKHQsIGUsIGkpIHtcbiAgICBpZiAoIXQubGVuZ3RoKSByZXR1cm4gdDtcbiAgICBpZiAoaSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGkpIHJldHVybiBpKHQpO1xuICAgIGNvbnN0IG4gPSBuZXcgd2luZG93LkRPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyh0LCBcInRleHQvaHRtbFwiKSxcbiAgICAgICAgICBzID0gW10uY29uY2F0KC4uLm4uYm9keS5xdWVyeVNlbGVjdG9yQWxsKFwiKlwiKSk7XG5cbiAgICBmb3IgKGxldCB0ID0gMCwgaSA9IHMubGVuZ3RoOyB0IDwgaTsgdCsrKSB7XG4gICAgICBjb25zdCBpID0gc1t0XSxcbiAgICAgICAgICAgIG4gPSBpLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGlmICghT2JqZWN0LmtleXMoZSkuaW5jbHVkZXMobikpIHtcbiAgICAgICAgaS5yZW1vdmUoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG8gPSBbXS5jb25jYXQoLi4uaS5hdHRyaWJ1dGVzKSxcbiAgICAgICAgICAgIHIgPSBbXS5jb25jYXQoZVtcIipcIl0gfHwgW10sIGVbbl0gfHwgW10pO1xuICAgICAgby5mb3JFYWNoKHQgPT4ge1xuICAgICAgICBYaSh0LCByKSB8fCBpLnJlbW92ZUF0dHJpYnV0ZSh0Lm5vZGVOYW1lKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBuLmJvZHkuaW5uZXJIVE1MO1xuICB9XG5cbiAgY29uc3QgUWkgPSBcInRvb2x0aXBcIixcbiAgICAgICAgR2kgPSBuZXcgU2V0KFtcInNhbml0aXplXCIsIFwiYWxsb3dMaXN0XCIsIFwic2FuaXRpemVGblwiXSksXG4gICAgICAgIFppID0ge1xuICAgIGFuaW1hdGlvbjogXCJib29sZWFuXCIsXG4gICAgdGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gICAgdGl0bGU6IFwiKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKVwiLFxuICAgIHRyaWdnZXI6IFwic3RyaW5nXCIsXG4gICAgZGVsYXk6IFwiKG51bWJlcnxvYmplY3QpXCIsXG4gICAgaHRtbDogXCJib29sZWFuXCIsXG4gICAgc2VsZWN0b3I6IFwiKHN0cmluZ3xib29sZWFuKVwiLFxuICAgIHBsYWNlbWVudDogXCIoc3RyaW5nfGZ1bmN0aW9uKVwiLFxuICAgIG9mZnNldDogXCIoYXJyYXl8c3RyaW5nfGZ1bmN0aW9uKVwiLFxuICAgIGNvbnRhaW5lcjogXCIoc3RyaW5nfGVsZW1lbnR8Ym9vbGVhbilcIixcbiAgICBmYWxsYmFja1BsYWNlbWVudHM6IFwiYXJyYXlcIixcbiAgICBib3VuZGFyeTogXCIoc3RyaW5nfGVsZW1lbnQpXCIsXG4gICAgY3VzdG9tQ2xhc3M6IFwiKHN0cmluZ3xmdW5jdGlvbilcIixcbiAgICBzYW5pdGl6ZTogXCJib29sZWFuXCIsXG4gICAgc2FuaXRpemVGbjogXCIobnVsbHxmdW5jdGlvbilcIixcbiAgICBhbGxvd0xpc3Q6IFwib2JqZWN0XCIsXG4gICAgcG9wcGVyQ29uZmlnOiBcIihudWxsfG9iamVjdHxmdW5jdGlvbilcIlxuICB9LFxuICAgICAgICBKaSA9IHtcbiAgICBBVVRPOiBcImF1dG9cIixcbiAgICBUT1A6IFwidG9wXCIsXG4gICAgUklHSFQ6IG0oKSA/IFwibGVmdFwiIDogXCJyaWdodFwiLFxuICAgIEJPVFRPTTogXCJib3R0b21cIixcbiAgICBMRUZUOiBtKCkgPyBcInJpZ2h0XCIgOiBcImxlZnRcIlxuICB9LFxuICAgICAgICB0biA9IHtcbiAgICBhbmltYXRpb246ICEwLFxuICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInRvb2x0aXBcIiByb2xlPVwidG9vbHRpcFwiPjxkaXYgY2xhc3M9XCJ0b29sdGlwLWFycm93XCI+PC9kaXY+PGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIj48L2Rpdj48L2Rpdj4nLFxuICAgIHRyaWdnZXI6IFwiaG92ZXIgZm9jdXNcIixcbiAgICB0aXRsZTogXCJcIixcbiAgICBkZWxheTogMCxcbiAgICBodG1sOiAhMSxcbiAgICBzZWxlY3RvcjogITEsXG4gICAgcGxhY2VtZW50OiBcInRvcFwiLFxuICAgIG9mZnNldDogWzAsIDBdLFxuICAgIGNvbnRhaW5lcjogITEsXG4gICAgZmFsbGJhY2tQbGFjZW1lbnRzOiBbXCJ0b3BcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIl0sXG4gICAgYm91bmRhcnk6IFwiY2xpcHBpbmdQYXJlbnRzXCIsXG4gICAgY3VzdG9tQ2xhc3M6IFwiXCIsXG4gICAgc2FuaXRpemU6ICEwLFxuICAgIHNhbml0aXplRm46IG51bGwsXG4gICAgYWxsb3dMaXN0OiB7XG4gICAgICBcIipcIjogW1wiY2xhc3NcIiwgXCJkaXJcIiwgXCJpZFwiLCBcImxhbmdcIiwgXCJyb2xlXCIsIC9eYXJpYS1bXFx3LV0qJC9pXSxcbiAgICAgIGE6IFtcInRhcmdldFwiLCBcImhyZWZcIiwgXCJ0aXRsZVwiLCBcInJlbFwiXSxcbiAgICAgIGFyZWE6IFtdLFxuICAgICAgYjogW10sXG4gICAgICBicjogW10sXG4gICAgICBjb2w6IFtdLFxuICAgICAgY29kZTogW10sXG4gICAgICBkaXY6IFtdLFxuICAgICAgZW06IFtdLFxuICAgICAgaHI6IFtdLFxuICAgICAgaDE6IFtdLFxuICAgICAgaDI6IFtdLFxuICAgICAgaDM6IFtdLFxuICAgICAgaDQ6IFtdLFxuICAgICAgaDU6IFtdLFxuICAgICAgaDY6IFtdLFxuICAgICAgaTogW10sXG4gICAgICBpbWc6IFtcInNyY1wiLCBcInNyY3NldFwiLCBcImFsdFwiLCBcInRpdGxlXCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIl0sXG4gICAgICBsaTogW10sXG4gICAgICBvbDogW10sXG4gICAgICBwOiBbXSxcbiAgICAgIHByZTogW10sXG4gICAgICBzOiBbXSxcbiAgICAgIHNtYWxsOiBbXSxcbiAgICAgIHNwYW46IFtdLFxuICAgICAgc3ViOiBbXSxcbiAgICAgIHN1cDogW10sXG4gICAgICBzdHJvbmc6IFtdLFxuICAgICAgdTogW10sXG4gICAgICB1bDogW11cbiAgICB9LFxuICAgIHBvcHBlckNvbmZpZzogbnVsbFxuICB9LFxuICAgICAgICBlbiA9IHtcbiAgICBISURFOiBcImhpZGUuYnMudG9vbHRpcFwiLFxuICAgIEhJRERFTjogXCJoaWRkZW4uYnMudG9vbHRpcFwiLFxuICAgIFNIT1c6IFwic2hvdy5icy50b29sdGlwXCIsXG4gICAgU0hPV046IFwic2hvd24uYnMudG9vbHRpcFwiLFxuICAgIElOU0VSVEVEOiBcImluc2VydGVkLmJzLnRvb2x0aXBcIixcbiAgICBDTElDSzogXCJjbGljay5icy50b29sdGlwXCIsXG4gICAgRk9DVVNJTjogXCJmb2N1c2luLmJzLnRvb2x0aXBcIixcbiAgICBGT0NVU09VVDogXCJmb2N1c291dC5icy50b29sdGlwXCIsXG4gICAgTU9VU0VFTlRFUjogXCJtb3VzZWVudGVyLmJzLnRvb2x0aXBcIixcbiAgICBNT1VTRUxFQVZFOiBcIm1vdXNlbGVhdmUuYnMudG9vbHRpcFwiXG4gIH0sXG4gICAgICAgIG5uID0gXCJmYWRlXCIsXG4gICAgICAgIHNuID0gXCJzaG93XCIsXG4gICAgICAgIG9uID0gXCJzaG93XCIsXG4gICAgICAgIHJuID0gXCJvdXRcIixcbiAgICAgICAgYW4gPSBcIi50b29sdGlwLWlubmVyXCIsXG4gICAgICAgIGxuID0gXCIubW9kYWxcIixcbiAgICAgICAgY24gPSBcImhpZGUuYnMubW9kYWxcIixcbiAgICAgICAgaG4gPSBcImhvdmVyXCIsXG4gICAgICAgIGRuID0gXCJmb2N1c1wiO1xuXG4gIGNsYXNzIHVuIGV4dGVuZHMgQiB7XG4gICAgY29uc3RydWN0b3IodCwgZSkge1xuICAgICAgaWYgKHZvaWQgMCA9PT0gRmUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJCb290c3RyYXAncyB0b29sdGlwcyByZXF1aXJlIFBvcHBlciAoaHR0cHM6Ly9wb3BwZXIuanMub3JnKVwiKTtcbiAgICAgIHN1cGVyKHQpLCB0aGlzLl9pc0VuYWJsZWQgPSAhMCwgdGhpcy5fdGltZW91dCA9IDAsIHRoaXMuX2hvdmVyU3RhdGUgPSBcIlwiLCB0aGlzLl9hY3RpdmVUcmlnZ2VyID0ge30sIHRoaXMuX3BvcHBlciA9IG51bGwsIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy50aXAgPSBudWxsLCB0aGlzLl9zZXRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gdG47XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIFFpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgRXZlbnQoKSB7XG4gICAgICByZXR1cm4gZW47XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICAgIHJldHVybiBaaTtcbiAgICB9XG5cbiAgICBlbmFibGUoKSB7XG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSAhMDtcbiAgICB9XG5cbiAgICBkaXNhYmxlKCkge1xuICAgICAgdGhpcy5faXNFbmFibGVkID0gITE7XG4gICAgfVxuXG4gICAgdG9nZ2xlRW5hYmxlZCgpIHtcbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9ICF0aGlzLl9pc0VuYWJsZWQ7XG4gICAgfVxuXG4gICAgdG9nZ2xlKHQpIHtcbiAgICAgIGlmICh0aGlzLl9pc0VuYWJsZWQpIGlmICh0KSB7XG4gICAgICAgIGNvbnN0IGUgPSB0aGlzLl9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQodCk7XG5cbiAgICAgICAgZS5fYWN0aXZlVHJpZ2dlci5jbGljayA9ICFlLl9hY3RpdmVUcmlnZ2VyLmNsaWNrLCBlLl9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkgPyBlLl9lbnRlcihudWxsLCBlKSA6IGUuX2xlYXZlKG51bGwsIGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0VGlwRWxlbWVudCgpLmNsYXNzTGlzdC5jb250YWlucyhzbikpIHJldHVybiB2b2lkIHRoaXMuX2xlYXZlKG51bGwsIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX2VudGVyKG51bGwsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCksIGoub2ZmKHRoaXMuX2VsZW1lbnQuY2xvc2VzdChsbiksIGNuLCB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyKSwgdGhpcy50aXAgJiYgdGhpcy50aXAucmVtb3ZlKCksIHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKSwgc3VwZXIuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIHNob3coKSB7XG4gICAgICBpZiAoXCJub25lXCIgPT09IHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSkgdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHVzZSBzaG93IG9uIHZpc2libGUgZWxlbWVudHNcIik7XG4gICAgICBpZiAoIXRoaXMuaXNXaXRoQ29udGVudCgpIHx8ICF0aGlzLl9pc0VuYWJsZWQpIHJldHVybjtcbiAgICAgIGNvbnN0IHQgPSBqLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5TSE9XKSxcbiAgICAgICAgICAgIGUgPSBoKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgICAgICAgaSA9IG51bGwgPT09IGUgPyB0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKHRoaXMuX2VsZW1lbnQpIDogZS5jb250YWlucyh0aGlzLl9lbGVtZW50KTtcbiAgICAgIGlmICh0LmRlZmF1bHRQcmV2ZW50ZWQgfHwgIWkpIHJldHVybjtcbiAgICAgIFwidG9vbHRpcFwiID09PSB0aGlzLmNvbnN0cnVjdG9yLk5BTUUgJiYgdGhpcy50aXAgJiYgdGhpcy5nZXRUaXRsZSgpICE9PSB0aGlzLnRpcC5xdWVyeVNlbGVjdG9yKGFuKS5pbm5lckhUTUwgJiYgKHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKSwgdGhpcy50aXAucmVtb3ZlKCksIHRoaXMudGlwID0gbnVsbCk7XG5cbiAgICAgIGNvbnN0IG4gPSB0aGlzLmdldFRpcEVsZW1lbnQoKSxcbiAgICAgICAgICAgIHMgPSAodCA9PiB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB0ICs9IE1hdGguZmxvb3IoMWU2ICogTWF0aC5yYW5kb20oKSk7XG4gICAgICAgIH0gd2hpbGUgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHQpKTtcblxuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH0pKHRoaXMuY29uc3RydWN0b3IuTkFNRSk7XG5cbiAgICAgIG4uc2V0QXR0cmlidXRlKFwiaWRcIiwgcyksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiLCBzKSwgdGhpcy5fY29uZmlnLmFuaW1hdGlvbiAmJiBuLmNsYXNzTGlzdC5hZGQobm4pO1xuXG4gICAgICBjb25zdCBvID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiB0aGlzLl9jb25maWcucGxhY2VtZW50ID8gdGhpcy5fY29uZmlnLnBsYWNlbWVudC5jYWxsKHRoaXMsIG4sIHRoaXMuX2VsZW1lbnQpIDogdGhpcy5fY29uZmlnLnBsYWNlbWVudCxcbiAgICAgICAgICAgIHIgPSB0aGlzLl9nZXRBdHRhY2htZW50KG8pO1xuXG4gICAgICB0aGlzLl9hZGRBdHRhY2htZW50Q2xhc3Mocik7XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29udGFpbmVyOiBhXG4gICAgICB9ID0gdGhpcy5fY29uZmlnO1xuICAgICAgSC5zZXQobiwgdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSwgdGhpcyksIHRoaXMuX2VsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnModGhpcy50aXApIHx8IChhLmFwcGVuZChuKSwgai50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuSU5TRVJURUQpKSwgdGhpcy5fcG9wcGVyID8gdGhpcy5fcG9wcGVyLnVwZGF0ZSgpIDogdGhpcy5fcG9wcGVyID0gcWUodGhpcy5fZWxlbWVudCwgbiwgdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKHIpKSwgbi5jbGFzc0xpc3QuYWRkKHNuKTtcblxuICAgICAgY29uc3QgbCA9IHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy5jdXN0b21DbGFzcyk7XG5cbiAgICAgIGwgJiYgbi5jbGFzc0xpc3QuYWRkKC4uLmwuc3BsaXQoXCIgXCIpKSwgXCJvbnRvdWNoc3RhcnRcIiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pLmZvckVhY2godCA9PiB7XG4gICAgICAgIGoub24odCwgXCJtb3VzZW92ZXJcIiwgZCk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGMgPSB0aGlzLnRpcC5jbGFzc0xpc3QuY29udGFpbnMobm4pO1xuXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMuX2hvdmVyU3RhdGU7XG4gICAgICAgIHRoaXMuX2hvdmVyU3RhdGUgPSBudWxsLCBqLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5TSE9XTiksIHQgPT09IHJuICYmIHRoaXMuX2xlYXZlKG51bGwsIHRoaXMpO1xuICAgICAgfSwgdGhpcy50aXAsIGMpO1xuICAgIH1cblxuICAgIGhpZGUoKSB7XG4gICAgICBpZiAoIXRoaXMuX3BvcHBlcikgcmV0dXJuO1xuICAgICAgY29uc3QgdCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpO1xuICAgICAgaWYgKGoudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkhJREUpLmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcbiAgICAgIHQuY2xhc3NMaXN0LnJlbW92ZShzbiksIFwib250b3VjaHN0YXJ0XCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKHQgPT4gai5vZmYodCwgXCJtb3VzZW92ZXJcIiwgZCkpLCB0aGlzLl9hY3RpdmVUcmlnZ2VyLmNsaWNrID0gITEsIHRoaXMuX2FjdGl2ZVRyaWdnZXIuZm9jdXMgPSAhMSwgdGhpcy5fYWN0aXZlVHJpZ2dlci5ob3ZlciA9ICExO1xuICAgICAgY29uc3QgZSA9IHRoaXMudGlwLmNsYXNzTGlzdC5jb250YWlucyhubik7XG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5faXNXaXRoQWN0aXZlVHJpZ2dlcigpIHx8ICh0aGlzLl9ob3ZlclN0YXRlICE9PSBvbiAmJiB0LnJlbW92ZSgpLCB0aGlzLl9jbGVhblRpcENsYXNzKCksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiKSwgai50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuSElEREVOKSwgdGhpcy5fZGlzcG9zZVBvcHBlcigpKTtcbiAgICAgIH0sIHRoaXMudGlwLCBlKSwgdGhpcy5faG92ZXJTdGF0ZSA9IFwiXCI7XG4gICAgfVxuXG4gICAgdXBkYXRlKCkge1xuICAgICAgbnVsbCAhPT0gdGhpcy5fcG9wcGVyICYmIHRoaXMuX3BvcHBlci51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBpc1dpdGhDb250ZW50KCkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5nZXRUaXRsZSgpKTtcbiAgICB9XG5cbiAgICBnZXRUaXBFbGVtZW50KCkge1xuICAgICAgaWYgKHRoaXMudGlwKSByZXR1cm4gdGhpcy50aXA7XG4gICAgICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHQuaW5uZXJIVE1MID0gdGhpcy5fY29uZmlnLnRlbXBsYXRlO1xuICAgICAgY29uc3QgZSA9IHQuY2hpbGRyZW5bMF07XG4gICAgICByZXR1cm4gdGhpcy5zZXRDb250ZW50KGUpLCBlLmNsYXNzTGlzdC5yZW1vdmUobm4sIHNuKSwgdGhpcy50aXAgPSBlLCB0aGlzLnRpcDtcbiAgICB9XG5cbiAgICBzZXRDb250ZW50KHQpIHtcbiAgICAgIHRoaXMuX3Nhbml0aXplQW5kU2V0Q29udGVudCh0LCB0aGlzLmdldFRpdGxlKCksIGFuKTtcbiAgICB9XG5cbiAgICBfc2FuaXRpemVBbmRTZXRDb250ZW50KHQsIGUsIGkpIHtcbiAgICAgIGNvbnN0IG4gPSBWLmZpbmRPbmUoaSwgdCk7XG4gICAgICBlIHx8ICFuID8gdGhpcy5zZXRFbGVtZW50Q29udGVudChuLCBlKSA6IG4ucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgc2V0RWxlbWVudENvbnRlbnQodCwgZSkge1xuICAgICAgaWYgKG51bGwgIT09IHQpIHJldHVybiBvKGUpID8gKGUgPSByKGUpLCB2b2lkICh0aGlzLl9jb25maWcuaHRtbCA/IGUucGFyZW50Tm9kZSAhPT0gdCAmJiAodC5pbm5lckhUTUwgPSBcIlwiLCB0LmFwcGVuZChlKSkgOiB0LnRleHRDb250ZW50ID0gZS50ZXh0Q29udGVudCkpIDogdm9pZCAodGhpcy5fY29uZmlnLmh0bWwgPyAodGhpcy5fY29uZmlnLnNhbml0aXplICYmIChlID0gWWkoZSwgdGhpcy5fY29uZmlnLmFsbG93TGlzdCwgdGhpcy5fY29uZmlnLnNhbml0aXplRm4pKSwgdC5pbm5lckhUTUwgPSBlKSA6IHQudGV4dENvbnRlbnQgPSBlKTtcbiAgICB9XG5cbiAgICBnZXRUaXRsZSgpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtYnMtb3JpZ2luYWwtdGl0bGVcIikgfHwgdGhpcy5fY29uZmlnLnRpdGxlO1xuXG4gICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24odCk7XG4gICAgfVxuXG4gICAgdXBkYXRlQXR0YWNobWVudCh0KSB7XG4gICAgICByZXR1cm4gXCJyaWdodFwiID09PSB0ID8gXCJlbmRcIiA6IFwibGVmdFwiID09PSB0ID8gXCJzdGFydFwiIDogdDtcbiAgICB9XG5cbiAgICBfaW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KHQsIGUpIHtcbiAgICAgIHJldHVybiBlIHx8IHRoaXMuY29uc3RydWN0b3IuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LmRlbGVnYXRlVGFyZ2V0LCB0aGlzLl9nZXREZWxlZ2F0ZUNvbmZpZygpKTtcbiAgICB9XG5cbiAgICBfZ2V0T2Zmc2V0KCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBvZmZzZXQ6IHRcbiAgICAgIH0gPSB0aGlzLl9jb25maWc7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCA/IHQuc3BsaXQoXCIsXCIpLm1hcCh0ID0+IE51bWJlci5wYXJzZUludCh0LCAxMCkpIDogXCJmdW5jdGlvblwiID09IHR5cGVvZiB0ID8gZSA9PiB0KGUsIHRoaXMuX2VsZW1lbnQpIDogdDtcbiAgICB9XG5cbiAgICBfcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgdCA/IHQuY2FsbCh0aGlzLl9lbGVtZW50KSA6IHQ7XG4gICAgfVxuXG4gICAgX2dldFBvcHBlckNvbmZpZyh0KSB7XG4gICAgICBjb25zdCBlID0ge1xuICAgICAgICBwbGFjZW1lbnQ6IHQsXG4gICAgICAgIG1vZGlmaWVyczogW3tcbiAgICAgICAgICBuYW1lOiBcImZsaXBcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBmYWxsYmFja1BsYWNlbWVudHM6IHRoaXMuX2NvbmZpZy5mYWxsYmFja1BsYWNlbWVudHNcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcIm9mZnNldFwiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KClcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcInByZXZlbnRPdmVyZmxvd1wiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLl9jb25maWcuYm91bmRhcnlcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImFycm93XCIsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgZWxlbWVudDogYC4ke3RoaXMuY29uc3RydWN0b3IuTkFNRX0tYXJyb3dgXG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJvbkNoYW5nZVwiLFxuICAgICAgICAgIGVuYWJsZWQ6ICEwLFxuICAgICAgICAgIHBoYXNlOiBcImFmdGVyV3JpdGVcIixcbiAgICAgICAgICBmbjogdCA9PiB0aGlzLl9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UodClcbiAgICAgICAgfV0sXG4gICAgICAgIG9uRmlyc3RVcGRhdGU6IHQgPT4ge1xuICAgICAgICAgIHQub3B0aW9ucy5wbGFjZW1lbnQgIT09IHQucGxhY2VtZW50ICYmIHRoaXMuX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZSh0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7IC4uLmUsXG4gICAgICAgIC4uLihcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcgPyB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnKGUpIDogdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZylcbiAgICAgIH07XG4gICAgfVxuXG4gICAgX2FkZEF0dGFjaG1lbnRDbGFzcyh0KSB7XG4gICAgICB0aGlzLmdldFRpcEVsZW1lbnQoKS5jbGFzc0xpc3QuYWRkKGAke3RoaXMuX2dldEJhc2ljQ2xhc3NQcmVmaXgoKX0tJHt0aGlzLnVwZGF0ZUF0dGFjaG1lbnQodCl9YCk7XG4gICAgfVxuXG4gICAgX2dldEF0dGFjaG1lbnQodCkge1xuICAgICAgcmV0dXJuIEppW3QudG9VcHBlckNhc2UoKV07XG4gICAgfVxuXG4gICAgX3NldExpc3RlbmVycygpIHtcbiAgICAgIHRoaXMuX2NvbmZpZy50cmlnZ2VyLnNwbGl0KFwiIFwiKS5mb3JFYWNoKHQgPT4ge1xuICAgICAgICBpZiAoXCJjbGlja1wiID09PSB0KSBqLm9uKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuQ0xJQ0ssIHRoaXMuX2NvbmZpZy5zZWxlY3RvciwgdCA9PiB0aGlzLnRvZ2dsZSh0KSk7ZWxzZSBpZiAoXCJtYW51YWxcIiAhPT0gdCkge1xuICAgICAgICAgIGNvbnN0IGUgPSB0ID09PSBobiA/IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuTU9VU0VFTlRFUiA6IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuRk9DVVNJTixcbiAgICAgICAgICAgICAgICBpID0gdCA9PT0gaG4gPyB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50Lk1PVVNFTEVBVkUgOiB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkZPQ1VTT1VUO1xuICAgICAgICAgIGoub24odGhpcy5fZWxlbWVudCwgZSwgdGhpcy5fY29uZmlnLnNlbGVjdG9yLCB0ID0+IHRoaXMuX2VudGVyKHQpKSwgai5vbih0aGlzLl9lbGVtZW50LCBpLCB0aGlzLl9jb25maWcuc2VsZWN0b3IsIHQgPT4gdGhpcy5fbGVhdmUodCkpO1xuICAgICAgICB9XG4gICAgICB9KSwgdGhpcy5faGlkZU1vZGFsSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5fZWxlbWVudCAmJiB0aGlzLmhpZGUoKTtcbiAgICAgIH0sIGoub24odGhpcy5fZWxlbWVudC5jbG9zZXN0KGxuKSwgY24sIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIpLCB0aGlzLl9jb25maWcuc2VsZWN0b3IgPyB0aGlzLl9jb25maWcgPSB7IC4uLnRoaXMuX2NvbmZpZyxcbiAgICAgICAgdHJpZ2dlcjogXCJtYW51YWxcIixcbiAgICAgICAgc2VsZWN0b3I6IFwiXCJcbiAgICAgIH0gOiB0aGlzLl9maXhUaXRsZSgpO1xuICAgIH1cblxuICAgIF9maXhUaXRsZSgpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZShcInRpdGxlXCIpLFxuICAgICAgICAgICAgZSA9IHR5cGVvZiB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtYnMtb3JpZ2luYWwtdGl0bGVcIik7XG5cbiAgICAgICh0IHx8IFwic3RyaW5nXCIgIT09IGUpICYmICh0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtYnMtb3JpZ2luYWwtdGl0bGVcIiwgdCB8fCBcIlwiKSwgIXQgfHwgdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIpIHx8IHRoaXMuX2VsZW1lbnQudGV4dENvbnRlbnQgfHwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHQpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIFwiXCIpKTtcbiAgICB9XG5cbiAgICBfZW50ZXIodCwgZSkge1xuICAgICAgZSA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldCh0LCBlKSwgdCAmJiAoZS5fYWN0aXZlVHJpZ2dlcltcImZvY3VzaW5cIiA9PT0gdC50eXBlID8gZG4gOiBobl0gPSAhMCksIGUuZ2V0VGlwRWxlbWVudCgpLmNsYXNzTGlzdC5jb250YWlucyhzbikgfHwgZS5faG92ZXJTdGF0ZSA9PT0gb24gPyBlLl9ob3ZlclN0YXRlID0gb24gOiAoY2xlYXJUaW1lb3V0KGUuX3RpbWVvdXQpLCBlLl9ob3ZlclN0YXRlID0gb24sIGUuX2NvbmZpZy5kZWxheSAmJiBlLl9jb25maWcuZGVsYXkuc2hvdyA/IGUuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZS5faG92ZXJTdGF0ZSA9PT0gb24gJiYgZS5zaG93KCk7XG4gICAgICB9LCBlLl9jb25maWcuZGVsYXkuc2hvdykgOiBlLnNob3coKSk7XG4gICAgfVxuXG4gICAgX2xlYXZlKHQsIGUpIHtcbiAgICAgIGUgPSB0aGlzLl9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQodCwgZSksIHQgJiYgKGUuX2FjdGl2ZVRyaWdnZXJbXCJmb2N1c291dFwiID09PSB0LnR5cGUgPyBkbiA6IGhuXSA9IGUuX2VsZW1lbnQuY29udGFpbnModC5yZWxhdGVkVGFyZ2V0KSksIGUuX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSB8fCAoY2xlYXJUaW1lb3V0KGUuX3RpbWVvdXQpLCBlLl9ob3ZlclN0YXRlID0gcm4sIGUuX2NvbmZpZy5kZWxheSAmJiBlLl9jb25maWcuZGVsYXkuaGlkZSA/IGUuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZS5faG92ZXJTdGF0ZSA9PT0gcm4gJiYgZS5oaWRlKCk7XG4gICAgICB9LCBlLl9jb25maWcuZGVsYXkuaGlkZSkgOiBlLmhpZGUoKSk7XG4gICAgfVxuXG4gICAgX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSB7XG4gICAgICBmb3IgKGNvbnN0IHQgaW4gdGhpcy5fYWN0aXZlVHJpZ2dlcikgaWYgKHRoaXMuX2FjdGl2ZVRyaWdnZXJbdF0pIHJldHVybiAhMDtcblxuICAgICAgcmV0dXJuICExO1xuICAgIH1cblxuICAgIF9nZXRDb25maWcodCkge1xuICAgICAgY29uc3QgZSA9IFUuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoZSkuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgR2kuaGFzKHQpICYmIGRlbGV0ZSBlW3RdO1xuICAgICAgfSksICh0ID0geyAuLi50aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHQsXG4gICAgICAgIC4uLmUsXG4gICAgICAgIC4uLihcIm9iamVjdFwiID09IHR5cGVvZiB0ICYmIHQgPyB0IDoge30pXG4gICAgICB9KS5jb250YWluZXIgPSAhMSA9PT0gdC5jb250YWluZXIgPyBkb2N1bWVudC5ib2R5IDogcih0LmNvbnRhaW5lciksIFwibnVtYmVyXCIgPT0gdHlwZW9mIHQuZGVsYXkgJiYgKHQuZGVsYXkgPSB7XG4gICAgICAgIHNob3c6IHQuZGVsYXksXG4gICAgICAgIGhpZGU6IHQuZGVsYXlcbiAgICAgIH0pLCBcIm51bWJlclwiID09IHR5cGVvZiB0LnRpdGxlICYmICh0LnRpdGxlID0gdC50aXRsZS50b1N0cmluZygpKSwgXCJudW1iZXJcIiA9PSB0eXBlb2YgdC5jb250ZW50ICYmICh0LmNvbnRlbnQgPSB0LmNvbnRlbnQudG9TdHJpbmcoKSksIGEoUWksIHQsIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpLCB0LnNhbml0aXplICYmICh0LnRlbXBsYXRlID0gWWkodC50ZW1wbGF0ZSwgdC5hbGxvd0xpc3QsIHQuc2FuaXRpemVGbikpLCB0O1xuICAgIH1cblxuICAgIF9nZXREZWxlZ2F0ZUNvbmZpZygpIHtcbiAgICAgIGNvbnN0IHQgPSB7fTtcblxuICAgICAgZm9yIChjb25zdCBlIGluIHRoaXMuX2NvbmZpZykgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0W2VdICE9PSB0aGlzLl9jb25maWdbZV0gJiYgKHRbZV0gPSB0aGlzLl9jb25maWdbZV0pO1xuXG4gICAgICByZXR1cm4gdDtcbiAgICB9XG5cbiAgICBfY2xlYW5UaXBDbGFzcygpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLmdldFRpcEVsZW1lbnQoKSxcbiAgICAgICAgICAgIGUgPSBuZXcgUmVnRXhwKGAoXnxcXFxccykke3RoaXMuX2dldEJhc2ljQ2xhc3NQcmVmaXgoKX1cXFxcUytgLCBcImdcIiksXG4gICAgICAgICAgICBpID0gdC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKS5tYXRjaChlKTtcbiAgICAgIG51bGwgIT09IGkgJiYgaS5sZW5ndGggPiAwICYmIGkubWFwKHQgPT4gdC50cmltKCkpLmZvckVhY2goZSA9PiB0LmNsYXNzTGlzdC5yZW1vdmUoZSkpO1xuICAgIH1cblxuICAgIF9nZXRCYXNpY0NsYXNzUHJlZml4KCkge1xuICAgICAgcmV0dXJuIFwiYnMtdG9vbHRpcFwiO1xuICAgIH1cblxuICAgIF9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UodCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdGF0ZTogZVxuICAgICAgfSA9IHQ7XG4gICAgICBlICYmICh0aGlzLnRpcCA9IGUuZWxlbWVudHMucG9wcGVyLCB0aGlzLl9jbGVhblRpcENsYXNzKCksIHRoaXMuX2FkZEF0dGFjaG1lbnRDbGFzcyh0aGlzLl9nZXRBdHRhY2htZW50KGUucGxhY2VtZW50KSkpO1xuICAgIH1cblxuICAgIF9kaXNwb3NlUG9wcGVyKCkge1xuICAgICAgdGhpcy5fcG9wcGVyICYmICh0aGlzLl9wb3BwZXIuZGVzdHJveSgpLCB0aGlzLl9wb3BwZXIgPSBudWxsKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBlID0gdW4uZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcblxuICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCkge1xuICAgICAgICAgIGlmICh2b2lkIDAgPT09IGVbdF0pIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICAgIGVbdF0oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gIH1cblxuICBnKHVuKTtcbiAgY29uc3QgZm4gPSB7IC4uLnVuLkRlZmF1bHQsXG4gICAgcGxhY2VtZW50OiBcInJpZ2h0XCIsXG4gICAgb2Zmc2V0OiBbMCwgOF0sXG4gICAgdHJpZ2dlcjogXCJjbGlja1wiLFxuICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwicG9wb3ZlclwiIHJvbGU9XCJ0b29sdGlwXCI+PGRpdiBjbGFzcz1cInBvcG92ZXItYXJyb3dcIj48L2Rpdj48aDMgY2xhc3M9XCJwb3BvdmVyLWhlYWRlclwiPjwvaDM+PGRpdiBjbGFzcz1cInBvcG92ZXItYm9keVwiPjwvZGl2PjwvZGl2PidcbiAgfSxcbiAgICAgICAgcG4gPSB7IC4uLnVuLkRlZmF1bHRUeXBlLFxuICAgIGNvbnRlbnQ6IFwiKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKVwiXG4gIH0sXG4gICAgICAgIG1uID0ge1xuICAgIEhJREU6IFwiaGlkZS5icy5wb3BvdmVyXCIsXG4gICAgSElEREVOOiBcImhpZGRlbi5icy5wb3BvdmVyXCIsXG4gICAgU0hPVzogXCJzaG93LmJzLnBvcG92ZXJcIixcbiAgICBTSE9XTjogXCJzaG93bi5icy5wb3BvdmVyXCIsXG4gICAgSU5TRVJURUQ6IFwiaW5zZXJ0ZWQuYnMucG9wb3ZlclwiLFxuICAgIENMSUNLOiBcImNsaWNrLmJzLnBvcG92ZXJcIixcbiAgICBGT0NVU0lOOiBcImZvY3VzaW4uYnMucG9wb3ZlclwiLFxuICAgIEZPQ1VTT1VUOiBcImZvY3Vzb3V0LmJzLnBvcG92ZXJcIixcbiAgICBNT1VTRUVOVEVSOiBcIm1vdXNlZW50ZXIuYnMucG9wb3ZlclwiLFxuICAgIE1PVVNFTEVBVkU6IFwibW91c2VsZWF2ZS5icy5wb3BvdmVyXCJcbiAgfTtcblxuICBjbGFzcyBnbiBleHRlbmRzIHVuIHtcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gZm47XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIFwicG9wb3ZlclwiO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgRXZlbnQoKSB7XG4gICAgICByZXR1cm4gbW47XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICAgIHJldHVybiBwbjtcbiAgICB9XG5cbiAgICBpc1dpdGhDb250ZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0VGl0bGUoKSB8fCB0aGlzLl9nZXRDb250ZW50KCk7XG4gICAgfVxuXG4gICAgc2V0Q29udGVudCh0KSB7XG4gICAgICB0aGlzLl9zYW5pdGl6ZUFuZFNldENvbnRlbnQodCwgdGhpcy5nZXRUaXRsZSgpLCBcIi5wb3BvdmVyLWhlYWRlclwiKSwgdGhpcy5fc2FuaXRpemVBbmRTZXRDb250ZW50KHQsIHRoaXMuX2dldENvbnRlbnQoKSwgXCIucG9wb3Zlci1ib2R5XCIpO1xuICAgIH1cblxuICAgIF9nZXRDb250ZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy5jb250ZW50KTtcbiAgICB9XG5cbiAgICBfZ2V0QmFzaWNDbGFzc1ByZWZpeCgpIHtcbiAgICAgIHJldHVybiBcImJzLXBvcG92ZXJcIjtcbiAgICB9XG5cbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBlID0gZ24uZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcblxuICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCkge1xuICAgICAgICAgIGlmICh2b2lkIDAgPT09IGVbdF0pIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICAgIGVbdF0oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gIH1cblxuICBnKGduKTtcbiAgY29uc3QgX24gPSBcInNjcm9sbHNweVwiLFxuICAgICAgICBibiA9IHtcbiAgICBvZmZzZXQ6IDEwLFxuICAgIG1ldGhvZDogXCJhdXRvXCIsXG4gICAgdGFyZ2V0OiBcIlwiXG4gIH0sXG4gICAgICAgIHZuID0ge1xuICAgIG9mZnNldDogXCJudW1iZXJcIixcbiAgICBtZXRob2Q6IFwic3RyaW5nXCIsXG4gICAgdGFyZ2V0OiBcIihzdHJpbmd8ZWxlbWVudClcIlxuICB9LFxuICAgICAgICB5biA9IFwiYWN0aXZlXCIsXG4gICAgICAgIHduID0gXCIubmF2LWxpbmssIC5saXN0LWdyb3VwLWl0ZW0sIC5kcm9wZG93bi1pdGVtXCIsXG4gICAgICAgIEVuID0gXCJwb3NpdGlvblwiO1xuXG4gIGNsYXNzIEFuIGV4dGVuZHMgQiB7XG4gICAgY29uc3RydWN0b3IodCwgZSkge1xuICAgICAgc3VwZXIodCksIHRoaXMuX3Njcm9sbEVsZW1lbnQgPSBcIkJPRFlcIiA9PT0gdGhpcy5fZWxlbWVudC50YWdOYW1lID8gd2luZG93IDogdGhpcy5fZWxlbWVudCwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9vZmZzZXRzID0gW10sIHRoaXMuX3RhcmdldHMgPSBbXSwgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gbnVsbCwgdGhpcy5fc2Nyb2xsSGVpZ2h0ID0gMCwgai5vbih0aGlzLl9zY3JvbGxFbGVtZW50LCBcInNjcm9sbC5icy5zY3JvbGxzcHlcIiwgKCkgPT4gdGhpcy5fcHJvY2VzcygpKSwgdGhpcy5yZWZyZXNoKCksIHRoaXMuX3Byb2Nlc3MoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gYm47XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIF9uO1xuICAgIH1cblxuICAgIHJlZnJlc2goKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gdGhpcy5fc2Nyb2xsRWxlbWVudC53aW5kb3cgPyBcIm9mZnNldFwiIDogRW4sXG4gICAgICAgICAgICBlID0gXCJhdXRvXCIgPT09IHRoaXMuX2NvbmZpZy5tZXRob2QgPyB0IDogdGhpcy5fY29uZmlnLm1ldGhvZCxcbiAgICAgICAgICAgIG4gPSBlID09PSBFbiA/IHRoaXMuX2dldFNjcm9sbFRvcCgpIDogMDtcbiAgICAgIHRoaXMuX29mZnNldHMgPSBbXSwgdGhpcy5fdGFyZ2V0cyA9IFtdLCB0aGlzLl9zY3JvbGxIZWlnaHQgPSB0aGlzLl9nZXRTY3JvbGxIZWlnaHQoKSwgVi5maW5kKHduLCB0aGlzLl9jb25maWcudGFyZ2V0KS5tYXAodCA9PiB7XG4gICAgICAgIGNvbnN0IHMgPSBpKHQpLFxuICAgICAgICAgICAgICBvID0gcyA/IFYuZmluZE9uZShzKSA6IG51bGw7XG5cbiAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICBjb25zdCB0ID0gby5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICBpZiAodC53aWR0aCB8fCB0LmhlaWdodCkgcmV0dXJuIFtVW2VdKG8pLnRvcCArIG4sIHNdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KS5maWx0ZXIodCA9PiB0KS5zb3J0KCh0LCBlKSA9PiB0WzBdIC0gZVswXSkuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgdGhpcy5fb2Zmc2V0cy5wdXNoKHRbMF0pLCB0aGlzLl90YXJnZXRzLnB1c2godFsxXSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBkaXNwb3NlKCkge1xuICAgICAgai5vZmYodGhpcy5fc2Nyb2xsRWxlbWVudCwgXCIuYnMuc2Nyb2xsc3B5XCIpLCBzdXBlci5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgX2dldENvbmZpZyh0KSB7XG4gICAgICByZXR1cm4gKHQgPSB7IC4uLmJuLFxuICAgICAgICAuLi5VLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgICAuLi4oXCJvYmplY3RcIiA9PSB0eXBlb2YgdCAmJiB0ID8gdCA6IHt9KVxuICAgICAgfSkudGFyZ2V0ID0gcih0LnRhcmdldCkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBhKF9uLCB0LCB2biksIHQ7XG4gICAgfVxuXG4gICAgX2dldFNjcm9sbFRvcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50ID09PSB3aW5kb3cgPyB0aGlzLl9zY3JvbGxFbGVtZW50LnBhZ2VZT2Zmc2V0IDogdGhpcy5fc2Nyb2xsRWxlbWVudC5zY3JvbGxUb3A7XG4gICAgfVxuXG4gICAgX2dldFNjcm9sbEhlaWdodCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50LnNjcm9sbEhlaWdodCB8fCBNYXRoLm1heChkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCk7XG4gICAgfVxuXG4gICAgX2dldE9mZnNldEhlaWdodCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50ID09PSB3aW5kb3cgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiB0aGlzLl9zY3JvbGxFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICB9XG5cbiAgICBfcHJvY2VzcygpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLl9nZXRTY3JvbGxUb3AoKSArIHRoaXMuX2NvbmZpZy5vZmZzZXQsXG4gICAgICAgICAgICBlID0gdGhpcy5fZ2V0U2Nyb2xsSGVpZ2h0KCksXG4gICAgICAgICAgICBpID0gdGhpcy5fY29uZmlnLm9mZnNldCArIGUgLSB0aGlzLl9nZXRPZmZzZXRIZWlnaHQoKTtcblxuICAgICAgaWYgKHRoaXMuX3Njcm9sbEhlaWdodCAhPT0gZSAmJiB0aGlzLnJlZnJlc2goKSwgdCA+PSBpKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLl90YXJnZXRzW3RoaXMuX3RhcmdldHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCAhPT0gdCAmJiB0aGlzLl9hY3RpdmF0ZSh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVUYXJnZXQgJiYgdCA8IHRoaXMuX29mZnNldHNbMF0gJiYgdGhpcy5fb2Zmc2V0c1swXSA+IDApIHJldHVybiB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsLCB2b2lkIHRoaXMuX2NsZWFyKCk7XG5cbiAgICAgICAgZm9yIChsZXQgZSA9IHRoaXMuX29mZnNldHMubGVuZ3RoOyBlLS07KSB0aGlzLl9hY3RpdmVUYXJnZXQgIT09IHRoaXMuX3RhcmdldHNbZV0gJiYgdCA+PSB0aGlzLl9vZmZzZXRzW2VdICYmICh2b2lkIDAgPT09IHRoaXMuX29mZnNldHNbZSArIDFdIHx8IHQgPCB0aGlzLl9vZmZzZXRzW2UgKyAxXSkgJiYgdGhpcy5fYWN0aXZhdGUodGhpcy5fdGFyZ2V0c1tlXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2FjdGl2YXRlKHQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IHQsIHRoaXMuX2NsZWFyKCk7XG4gICAgICBjb25zdCBlID0gd24uc3BsaXQoXCIsXCIpLm1hcChlID0+IGAke2V9W2RhdGEtYnMtdGFyZ2V0PVwiJHt0fVwiXSwke2V9W2hyZWY9XCIke3R9XCJdYCksXG4gICAgICAgICAgICBpID0gVi5maW5kT25lKGUuam9pbihcIixcIiksIHRoaXMuX2NvbmZpZy50YXJnZXQpO1xuICAgICAgaS5jbGFzc0xpc3QuYWRkKHluKSwgaS5jbGFzc0xpc3QuY29udGFpbnMoXCJkcm9wZG93bi1pdGVtXCIpID8gVi5maW5kT25lKFwiLmRyb3Bkb3duLXRvZ2dsZVwiLCBpLmNsb3Nlc3QoXCIuZHJvcGRvd25cIikpLmNsYXNzTGlzdC5hZGQoeW4pIDogVi5wYXJlbnRzKGksIFwiLm5hdiwgLmxpc3QtZ3JvdXBcIikuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgVi5wcmV2KHQsIFwiLm5hdi1saW5rLCAubGlzdC1ncm91cC1pdGVtXCIpLmZvckVhY2godCA9PiB0LmNsYXNzTGlzdC5hZGQoeW4pKSwgVi5wcmV2KHQsIFwiLm5hdi1pdGVtXCIpLmZvckVhY2godCA9PiB7XG4gICAgICAgICAgVi5jaGlsZHJlbih0LCBcIi5uYXYtbGlua1wiKS5mb3JFYWNoKHQgPT4gdC5jbGFzc0xpc3QuYWRkKHluKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSksIGoudHJpZ2dlcih0aGlzLl9zY3JvbGxFbGVtZW50LCBcImFjdGl2YXRlLmJzLnNjcm9sbHNweVwiLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF9jbGVhcigpIHtcbiAgICAgIFYuZmluZCh3biwgdGhpcy5fY29uZmlnLnRhcmdldCkuZmlsdGVyKHQgPT4gdC5jbGFzc0xpc3QuY29udGFpbnMoeW4pKS5mb3JFYWNoKHQgPT4gdC5jbGFzc0xpc3QucmVtb3ZlKHluKSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZSA9IEFuLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgdCk7XG5cbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHQpIHtcbiAgICAgICAgICBpZiAodm9pZCAwID09PSBlW3RdKSB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgICBlW3RdKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICB9XG5cbiAgai5vbih3aW5kb3csIFwibG9hZC5icy5zY3JvbGxzcHkuZGF0YS1hcGlcIiwgKCkgPT4ge1xuICAgIFYuZmluZCgnW2RhdGEtYnMtc3B5PVwic2Nyb2xsXCJdJykuZm9yRWFjaCh0ID0+IG5ldyBBbih0KSk7XG4gIH0pLCBnKEFuKTtcbiAgY29uc3QgVG4gPSBcImFjdGl2ZVwiLFxuICAgICAgICBPbiA9IFwiZmFkZVwiLFxuICAgICAgICBDbiA9IFwic2hvd1wiLFxuICAgICAgICBrbiA9IFwiLmFjdGl2ZVwiLFxuICAgICAgICBMbiA9IFwiOnNjb3BlID4gbGkgPiAuYWN0aXZlXCI7XG5cbiAgY2xhc3MgeG4gZXh0ZW5kcyBCIHtcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgICByZXR1cm4gXCJ0YWJcIjtcbiAgICB9XG5cbiAgICBzaG93KCkge1xuICAgICAgaWYgKHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSAmJiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFRuKSkgcmV0dXJuO1xuICAgICAgbGV0IHQ7XG5cbiAgICAgIGNvbnN0IGUgPSBuKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgICAgICAgaSA9IHRoaXMuX2VsZW1lbnQuY2xvc2VzdChcIi5uYXYsIC5saXN0LWdyb3VwXCIpO1xuXG4gICAgICBpZiAoaSkge1xuICAgICAgICBjb25zdCBlID0gXCJVTFwiID09PSBpLm5vZGVOYW1lIHx8IFwiT0xcIiA9PT0gaS5ub2RlTmFtZSA/IExuIDoga247XG4gICAgICAgIHQgPSBWLmZpbmQoZSwgaSksIHQgPSB0W3QubGVuZ3RoIC0gMV07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHMgPSB0ID8gai50cmlnZ2VyKHQsIFwiaGlkZS5icy50YWJcIiwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgICB9KSA6IG51bGw7XG4gICAgICBpZiAoai50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFwic2hvdy5icy50YWJcIiwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0XG4gICAgICB9KS5kZWZhdWx0UHJldmVudGVkIHx8IG51bGwgIT09IHMgJiYgcy5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cbiAgICAgIHRoaXMuX2FjdGl2YXRlKHRoaXMuX2VsZW1lbnQsIGkpO1xuXG4gICAgICBjb25zdCBvID0gKCkgPT4ge1xuICAgICAgICBqLnRyaWdnZXIodCwgXCJoaWRkZW4uYnMudGFiXCIsIHtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgICAgIH0pLCBqLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgXCJzaG93bi5icy50YWJcIiwge1xuICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBlID8gdGhpcy5fYWN0aXZhdGUoZSwgZS5wYXJlbnROb2RlLCBvKSA6IG8oKTtcbiAgICB9XG5cbiAgICBfYWN0aXZhdGUodCwgZSwgaSkge1xuICAgICAgY29uc3QgbiA9ICghZSB8fCBcIlVMXCIgIT09IGUubm9kZU5hbWUgJiYgXCJPTFwiICE9PSBlLm5vZGVOYW1lID8gVi5jaGlsZHJlbihlLCBrbikgOiBWLmZpbmQoTG4sIGUpKVswXSxcbiAgICAgICAgICAgIHMgPSBpICYmIG4gJiYgbi5jbGFzc0xpc3QuY29udGFpbnMoT24pLFxuICAgICAgICAgICAgbyA9ICgpID0+IHRoaXMuX3RyYW5zaXRpb25Db21wbGV0ZSh0LCBuLCBpKTtcblxuICAgICAgbiAmJiBzID8gKG4uY2xhc3NMaXN0LnJlbW92ZShDbiksIHRoaXMuX3F1ZXVlQ2FsbGJhY2sobywgdCwgITApKSA6IG8oKTtcbiAgICB9XG5cbiAgICBfdHJhbnNpdGlvbkNvbXBsZXRlKHQsIGUsIGkpIHtcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGUuY2xhc3NMaXN0LnJlbW92ZShUbik7XG4gICAgICAgIGNvbnN0IHQgPSBWLmZpbmRPbmUoXCI6c2NvcGUgPiAuZHJvcGRvd24tbWVudSAuYWN0aXZlXCIsIGUucGFyZW50Tm9kZSk7XG4gICAgICAgIHQgJiYgdC5jbGFzc0xpc3QucmVtb3ZlKFRuKSwgXCJ0YWJcIiA9PT0gZS5nZXRBdHRyaWJ1dGUoXCJyb2xlXCIpICYmIGUuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCAhMSk7XG4gICAgICB9XG5cbiAgICAgIHQuY2xhc3NMaXN0LmFkZChUbiksIFwidGFiXCIgPT09IHQuZ2V0QXR0cmlidXRlKFwicm9sZVwiKSAmJiB0LnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgITApLCB1KHQpLCB0LmNsYXNzTGlzdC5jb250YWlucyhPbikgJiYgdC5jbGFzc0xpc3QuYWRkKENuKTtcbiAgICAgIGxldCBuID0gdC5wYXJlbnROb2RlO1xuXG4gICAgICBpZiAobiAmJiBcIkxJXCIgPT09IG4ubm9kZU5hbWUgJiYgKG4gPSBuLnBhcmVudE5vZGUpLCBuICYmIG4uY2xhc3NMaXN0LmNvbnRhaW5zKFwiZHJvcGRvd24tbWVudVwiKSkge1xuICAgICAgICBjb25zdCBlID0gdC5jbG9zZXN0KFwiLmRyb3Bkb3duXCIpO1xuICAgICAgICBlICYmIFYuZmluZChcIi5kcm9wZG93bi10b2dnbGVcIiwgZSkuZm9yRWFjaCh0ID0+IHQuY2xhc3NMaXN0LmFkZChUbikpLCB0LnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgITApO1xuICAgICAgfVxuXG4gICAgICBpICYmIGkoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBlID0geG4uZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKTtcblxuICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCkge1xuICAgICAgICAgIGlmICh2b2lkIDAgPT09IGVbdF0pIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICAgIGVbdF0oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gIH1cblxuICBqLm9uKGRvY3VtZW50LCBcImNsaWNrLmJzLnRhYi5kYXRhLWFwaVwiLCAnW2RhdGEtYnMtdG9nZ2xlPVwidGFiXCJdLCBbZGF0YS1icy10b2dnbGU9XCJwaWxsXCJdLCBbZGF0YS1icy10b2dnbGU9XCJsaXN0XCJdJywgZnVuY3Rpb24gKHQpIHtcbiAgICBbXCJBXCIsIFwiQVJFQVwiXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpICYmIHQucHJldmVudERlZmF1bHQoKSwgYyh0aGlzKSB8fCB4bi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpLnNob3coKTtcbiAgfSksIGcoeG4pO1xuICBjb25zdCBEbiA9IFwidG9hc3RcIixcbiAgICAgICAgU24gPSBcImhpZGVcIixcbiAgICAgICAgTm4gPSBcInNob3dcIixcbiAgICAgICAgSW4gPSBcInNob3dpbmdcIixcbiAgICAgICAgUG4gPSB7XG4gICAgYW5pbWF0aW9uOiBcImJvb2xlYW5cIixcbiAgICBhdXRvaGlkZTogXCJib29sZWFuXCIsXG4gICAgZGVsYXk6IFwibnVtYmVyXCJcbiAgfSxcbiAgICAgICAgam4gPSB7XG4gICAgYW5pbWF0aW9uOiAhMCxcbiAgICBhdXRvaGlkZTogITAsXG4gICAgZGVsYXk6IDVlM1xuICB9O1xuXG4gIGNsYXNzIE1uIGV4dGVuZHMgQiB7XG4gICAgY29uc3RydWN0b3IodCwgZSkge1xuICAgICAgc3VwZXIodCksIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fdGltZW91dCA9IG51bGwsIHRoaXMuX2hhc01vdXNlSW50ZXJhY3Rpb24gPSAhMSwgdGhpcy5faGFzS2V5Ym9hcmRJbnRlcmFjdGlvbiA9ICExLCB0aGlzLl9zZXRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgICAgcmV0dXJuIFBuO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBqbjtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgICByZXR1cm4gRG47XG4gICAgfVxuXG4gICAgc2hvdygpIHtcbiAgICAgIGoudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBcInNob3cuYnMudG9hc3RcIikuZGVmYXVsdFByZXZlbnRlZCB8fCAodGhpcy5fY2xlYXJUaW1lb3V0KCksIHRoaXMuX2NvbmZpZy5hbmltYXRpb24gJiYgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZmFkZVwiKSwgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFNuKSwgdSh0aGlzLl9lbGVtZW50KSwgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKE5uKSwgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKEluKSwgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShJbiksIGoudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBcInNob3duLmJzLnRvYXN0XCIpLCB0aGlzLl9tYXliZVNjaGVkdWxlSGlkZSgpO1xuICAgICAgfSwgdGhpcy5fZWxlbWVudCwgdGhpcy5fY29uZmlnLmFuaW1hdGlvbikpO1xuICAgIH1cblxuICAgIGhpZGUoKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhObikgJiYgKGoudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBcImhpZGUuYnMudG9hc3RcIikuZGVmYXVsdFByZXZlbnRlZCB8fCAodGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKEluKSwgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChTbiksIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShJbiksIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShObiksIGoudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBcImhpZGRlbi5icy50b2FzdFwiKTtcbiAgICAgIH0sIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NvbmZpZy5hbmltYXRpb24pKSk7XG4gICAgfVxuXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgIHRoaXMuX2NsZWFyVGltZW91dCgpLCB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhObikgJiYgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKE5uKSwgc3VwZXIuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIF9nZXRDb25maWcodCkge1xuICAgICAgcmV0dXJuIHQgPSB7IC4uLmpuLFxuICAgICAgICAuLi5VLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgICAuLi4oXCJvYmplY3RcIiA9PSB0eXBlb2YgdCAmJiB0ID8gdCA6IHt9KVxuICAgICAgfSwgYShEbiwgdCwgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSksIHQ7XG4gICAgfVxuXG4gICAgX21heWJlU2NoZWR1bGVIaWRlKCkge1xuICAgICAgdGhpcy5fY29uZmlnLmF1dG9oaWRlICYmICh0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uIHx8IHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24gfHwgKHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9LCB0aGlzLl9jb25maWcuZGVsYXkpKSk7XG4gICAgfVxuXG4gICAgX29uSW50ZXJhY3Rpb24odCwgZSkge1xuICAgICAgc3dpdGNoICh0LnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm1vdXNlb3ZlclwiOlxuICAgICAgICBjYXNlIFwibW91c2VvdXRcIjpcbiAgICAgICAgICB0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uID0gZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiZm9jdXNpblwiOlxuICAgICAgICBjYXNlIFwiZm9jdXNvdXRcIjpcbiAgICAgICAgICB0aGlzLl9oYXNLZXlib2FyZEludGVyYWN0aW9uID0gZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGUpIHJldHVybiB2b2lkIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuICAgICAgY29uc3QgaSA9IHQucmVsYXRlZFRhcmdldDtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPT09IGkgfHwgdGhpcy5fZWxlbWVudC5jb250YWlucyhpKSB8fCB0aGlzLl9tYXliZVNjaGVkdWxlSGlkZSgpO1xuICAgIH1cblxuICAgIF9zZXRMaXN0ZW5lcnMoKSB7XG4gICAgICBqLm9uKHRoaXMuX2VsZW1lbnQsIFwibW91c2VvdmVyLmJzLnRvYXN0XCIsIHQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbih0LCAhMCkpLCBqLm9uKHRoaXMuX2VsZW1lbnQsIFwibW91c2VvdXQuYnMudG9hc3RcIiwgdCA9PiB0aGlzLl9vbkludGVyYWN0aW9uKHQsICExKSksIGoub24odGhpcy5fZWxlbWVudCwgXCJmb2N1c2luLmJzLnRvYXN0XCIsIHQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbih0LCAhMCkpLCBqLm9uKHRoaXMuX2VsZW1lbnQsIFwiZm9jdXNvdXQuYnMudG9hc3RcIiwgdCA9PiB0aGlzLl9vbkludGVyYWN0aW9uKHQsICExKSk7XG4gICAgfVxuXG4gICAgX2NsZWFyVGltZW91dCgpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KSwgdGhpcy5fdGltZW91dCA9IG51bGw7XG4gICAgfVxuXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZSA9IE1uLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgdCk7XG5cbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHQpIHtcbiAgICAgICAgICBpZiAodm9pZCAwID09PSBlW3RdKSB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgICBlW3RdKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBSKE1uKSwgZyhNbiksIHtcbiAgICBBbGVydDogVyxcbiAgICBCdXR0b246IHosXG4gICAgQ2Fyb3VzZWw6IHN0LFxuICAgIENvbGxhcHNlOiBwdCxcbiAgICBEcm9wZG93bjogaGksXG4gICAgTW9kYWw6IEhpLFxuICAgIE9mZmNhbnZhczogRmksXG4gICAgUG9wb3ZlcjogZ24sXG4gICAgU2Nyb2xsU3B5OiBBbixcbiAgICBUYWI6IHhuLFxuICAgIFRvYXN0OiBNbixcbiAgICBUb29sdGlwOiB1blxuICB9O1xufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///106\n')},818:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval("\n// EXTERNAL MODULE: ./node_modules/bootstrap/dist/js/bootstrap.bundle.min.js\nvar bootstrap_bundle_min = __webpack_require__(106);\n;// CONCATENATED MODULE: ./assets/js/main.js\n\n;// CONCATENATED MODULE: ./pages/global/scripts.js\n// Assets\n\n // Components\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODE4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanVzZG9jcy1ib2lsZXJwbGF0ZS8uL2Fzc2V0cy9qcy9tYWluLmpzPzg0OWQiLCJ3ZWJwYWNrOi8vanVzZG9jcy1ib2lsZXJwbGF0ZS8uL3BhZ2VzL2dsb2JhbC9zY3JpcHRzLmpzPzMyNGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFwiYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwLmJ1bmRsZS5taW5cIjsiLCIvLyBBc3NldHNcbmltcG9ydCBcIi4uLy4uL2Fzc2V0cy9qcy9tYWluXCI7XG5pbXBvcnQgXCIuLi8uLi9hc3NldHMvZm9udHMvaWNvbnMuZm9udFwiOyAvLyBDb21wb25lbnRzXG5cbmltcG9ydCBcIi4uLy4uL2NvbXBvbmVudHMvUGV0aXRpb25zR3JpZC9cIjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///818\n")},546:()=>{"use strict";eval("// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQ2LmpzIiwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vanVzZG9jcy1ib2lsZXJwbGF0ZS8uL3BhZ2VzL2dsb2JhbC9zdHlsZXMuc2Nzcz9jMDJjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///546\n")}},__webpack_module_cache__={};function __webpack_require__(g){var I=__webpack_module_cache__[g];if(void 0!==I)return I.exports;var t=__webpack_module_cache__[g]={exports:{}};return __webpack_modules__[g].call(t.exports,t,t.exports,__webpack_require__),t.exports}__webpack_require__(818);var __webpack_exports__=__webpack_require__(546)})();